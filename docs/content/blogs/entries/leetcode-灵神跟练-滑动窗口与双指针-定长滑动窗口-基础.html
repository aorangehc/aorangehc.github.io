<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-11-09">

<title>leetcode-灵神跟练-滑动窗口与双指针-定长滑动窗口-基础</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-dark-b758ccaa5987ceb1b75504551e579abf.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/bootstrap/bootstrap-dark-0d4a9d19931feb4fee1ddab4b2489000.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../pages/index.html"> 
<span class="menu-text"><span class="lang-en">About Me</span><span class="lang-zh">关于我</span></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../pages/home.html"> 
<span class="menu-text"><span class="lang-en">Home</span><span class="lang-zh">主页</span></span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../content/blogs/index.html"> 
<span class="menu-text"><span class="lang-en">Blogs</span><span class="lang-zh">博客</span></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../content/projects/index.html"> 
<span class="menu-text"><span class="lang-en">Projects</span><span class="lang-zh">项目</span></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../content/papers/index.html"> 
<span class="menu-text"><span class="lang-en">Papers</span><span class="lang-zh">论文</span></span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-span-classlang-enlearning-notesspanspan-classlang-zh学习笔记span" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text"><span class="lang-en">Learning Notes</span><span class="lang-zh">学习笔记</span></span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-span-classlang-enlearning-notesspanspan-classlang-zh学习笔记span">    
        <li>
    <a class="dropdown-item" href="../../../content/learning-notes/index.html">
 <span class="dropdown-text">Overview</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../content/learning-notes/golang/index.html">
 <span class="dropdown-text">golang基础</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../content/learning-notes/microservices/index.html">
 <span class="dropdown-text">微服务(golang)</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools tools-wide">
    <a href="https://github.com/aorangehc" title="" class="quarto-navigation-tool px-1" aria-label="GitHub"><i class="bi bi-github"></i></a>
    <a href="mailto:morange0205@gmail.com" title="" class="quarto-navigation-tool px-1" aria-label="Email"><i class="bi bi-envelope"></i></a>
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#定长滑动窗口-基础" id="toc-定长滑动窗口-基础" class="nav-link active" data-scroll-target="#定长滑动窗口-基础">定长滑动窗口-基础</a>
  <ul class="collapse">
  <li><a href="#定长子串中元音的最大数目" id="toc-定长子串中元音的最大数目" class="nav-link" data-scroll-target="#定长子串中元音的最大数目">1456. 定长子串中元音的最大数目</a></li>
  <li><a href="#子数组最大平均数-i" id="toc-子数组最大平均数-i" class="nav-link" data-scroll-target="#子数组最大平均数-i">643. 子数组最大平均数 I</a></li>
  <li><a href="#大小为-k-且平均值大于等于阈值的子数组数目" id="toc-大小为-k-且平均值大于等于阈值的子数组数目" class="nav-link" data-scroll-target="#大小为-k-且平均值大于等于阈值的子数组数目">1343. 大小为 K 且平均值大于等于阈值的子数组数目</a></li>
  <li><a href="#半径为-k-的子数组平均值" id="toc-半径为-k-的子数组平均值" class="nav-link" data-scroll-target="#半径为-k-的子数组平均值">2090. 半径为 k 的子数组平均值</a></li>
  <li><a href="#得到-k-个黑块的最少涂色次数" id="toc-得到-k-个黑块的最少涂色次数" class="nav-link" data-scroll-target="#得到-k-个黑块的最少涂色次数">2379. 得到 K 个黑块的最少涂色次数</a></li>
  <li><a href="#几乎唯一子数组的最大和" id="toc-几乎唯一子数组的最大和" class="nav-link" data-scroll-target="#几乎唯一子数组的最大和">2841. 几乎唯一子数组的最大和</a></li>
  <li><a href="#长度为-k-子数组中的最大和" id="toc-长度为-k-子数组中的最大和" class="nav-link" data-scroll-target="#长度为-k-子数组中的最大和">2461. 长度为 K 子数组中的最大和</a></li>
  <li><a href="#可获得的最大点数" id="toc-可获得的最大点数" class="nav-link" data-scroll-target="#可获得的最大点数">1423. 可获得的最大点数</a></li>
  <li><a href="#健身计划评估" id="toc-健身计划评估" class="nav-link" data-scroll-target="#健身计划评估">1176. 健身计划评估</a></li>
  <li><a href="#长度为-k-的无重复字符子串" id="toc-长度为-k-的无重复字符子串" class="nav-link" data-scroll-target="#长度为-k-的无重复字符子串">1100. 长度为 K 的无重复字符子串</a></li>
  <li><a href="#每个子数组的数字种类数" id="toc-每个子数组的数字种类数" class="nav-link" data-scroll-target="#每个子数组的数字种类数">1852. 每个子数组的数字种类数</a></li>
  <li><a href="#最少交换次数来组合所有的-1" id="toc-最少交换次数来组合所有的-1" class="nav-link" data-scroll-target="#最少交换次数来组合所有的-1">1151. 最少交换次数来组合所有的 1</a></li>
  <li><a href="#分享-k-个糖果后独特口味的数量" id="toc-分享-k-个糖果后独特口味的数量" class="nav-link" data-scroll-target="#分享-k-个糖果后独特口味的数量">2107. 分享 K 个糖果后独特口味的数量</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">leetcode-灵神跟练-滑动窗口与双指针-定长滑动窗口-基础</h1>
  <div class="quarto-categories">
    <div class="quarto-category">算法</div>
    <div class="quarto-category">leetcode</div>
    <div class="quarto-category">滑动窗口与双指针</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 9, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="定长滑动窗口-基础" class="level1">
<h1>定长滑动窗口-基础</h1>
<section id="定长子串中元音的最大数目" class="level3">
<h3 class="anchored" data-anchor-id="定长子串中元音的最大数目"><a href="https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/">1456. 定长子串中元音的最大数目</a></h3>
<section id="题面" class="level4">
<h4 class="anchored" data-anchor-id="题面">题面</h4>
<p>给你字符串 s 和整数 k 。 请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。 英文中的 元音字母 为（a, e, i, o, u）。</p>
<p>示例 1： 输入：s = “abciiidef”, k = 3 输出：3 解释：子字符串 “iii” 包含 3 个元音字母。</p>
<p>示例 2： 输入：s = “aeiou”, k = 2 输出：2 解释：任意长度为 2 的子字符串都包含 2 个元音字母。</p>
<p>示例 3： 输入：s = “leetcode”, k = 3 输出：2 解释：“lee”、“eet” 和 “ode” 都包含 2 个元音字母。</p>
<p>示例 4： 输入：s = “rhythms”, k = 4 输出：0 解释：字符串 s 中不含任何元音字母。</p>
<p>示例 5： 输入：s = “tryhard”, k = 4 输出：1</p>
<p>提示： 1 &lt;= s.length &lt;= 10^5 s 由小写英文字母组成 1 &lt;= k &lt;= s.length</p>
</section>
<section id="思路说明" class="level4">
<h4 class="anchored" data-anchor-id="思路说明">思路说明</h4>
<p>本题是一个比较简单的滑动窗口，窗口的大小固定不变是K，要做的是判断窗口内元音字母的个数</p>
<p>首先我们构建一个变量用来统计当前窗口内元音字母的数量，设置为<strong>cnt</strong></p>
<p>窗口只要不断向右滑动的，还需要一个变量存储所有经历过的窗口中元音字母数的最大值，也就是我们最后需要的结果，设置为<strong>ans</strong></p>
<p>然后我们就是对字符串进行遍历</p>
<p>针对定长滑动窗口的类型，我们可以简单总结一个规律 - 先进行条件判断，修改对应变量值 - 判断窗口是否需要移动，如果移动修改对应值 - 判断窗口是否已经达到了固定长度，如果达到了，进行结果更新</p>
<p>一个简单的总结，仅供参考</p>
<p>针对我们现在的题目 - 创建一个变量记录当前窗口内元音字母的个数，设置为<strong>cnt</strong> - 创建一个变量记录所有经历过的窗口内元音字母数最大值，设置为<strong>ans</strong> - 然后进行遍历 - 先判断是不是元音字母，如果是窗口内元音字母个数cnt+1 - 然后判断窗口是否需要滑动，如果需要，判断最左边元素是不是元音字母，如果是cnt-1，如果不是，不需要进行更新 - 最后，判断当前窗口长度是不是达到要求，如果是，进行最大值的更新 - 返回最终结果ans</p>
</section>
<section id="题解" class="level4">
<h4 class="anchored" data-anchor-id="题解">题解</h4>
<pre class="golang"><code>package main

import "fmt"

func judge(ch byte) bool {
    if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {
        return true
    }

    return false
}

func maxVowels(s string, k int) int {
    ans := 0
    cnt := 0

    for i := 0; i &lt; len(s); i++ {
        if judge(s[i]) {
            cnt++
        }
        if i &gt;= k {
            if judge(s[i-k]) {
                cnt -= 1
            }
        }
        if i &gt;= k-1 {
            ans = max(ans, cnt)
        }
    }

    return ans
}

func main() {
    testCases := []struct {
        s string
        k int
    }{
        {"abciiidef", 3},
        {"aeiou", 2},
        {"leetcode", 3},
        {"rhythms", 4},
        {"tryhard", 4},
    }

    for _, testCase := range testCases {
        fmt.Println(maxVowels(testCase.s, testCase.k))
    }
}

</code></pre>
</section>
</section>
<section id="子数组最大平均数-i" class="level3">
<h3 class="anchored" data-anchor-id="子数组最大平均数-i"><a href="https://leetcode.cn/problems/maximum-average-subarray-i/description/">643. 子数组最大平均数 I</a></h3>
<section id="题面-1" class="level4">
<h4 class="anchored" data-anchor-id="题面-1">题面</h4>
<p>给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。 请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。 任何误差小于 10-5 的答案都将被视为正确答案。</p>
<p>示例 1：</p>
<p>输入：nums = [1,12,-5,-6,50,3], k = 4</p>
<p>输出：12.75</p>
<p>解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75</p>
<p>示例 2：</p>
<p>输入：nums = [5], k = 1</p>
<p>输出：5.00000</p>
<p>提示：</p>
<p>n == nums.length</p>
<p>1 &lt;= k &lt;= n &lt;= 10^5</p>
<p>-10^4 &lt;= nums[i] &lt;= 10^4</p>
</section>
<section id="思路说明-1" class="level4">
<h4 class="anchored" data-anchor-id="思路说明-1">思路说明</h4>
<p>构建长度为k的滑动窗口，设置变量计算窗口内数字的和，当窗口滑动的时候更新变量</p>
<p>设置变量动态更新最大平均数，注意这个变量初始化的时候设置成 math.MinInt</p>
</section>
<section id="题解-1" class="level4">
<h4 class="anchored" data-anchor-id="题解-1">题解</h4>
<pre class="golang"><code>
// 643.子数组最大平均数I
package main

import (
    "fmt"
    "math"
)

func findMaxAverage(nums []int, k int) float64 {
    ans, cnt := math.MinInt, 0

    for i, num := range nums {
        cnt += num

        if i &gt;= k {
            cnt -= nums[i-k]
        }

        if i &gt;= k-1 {
            ans = max(ans, cnt)
        }
    }

    return float64(ans) / float64(k)
}

func main() {
    testCases := []struct {
        nums []int
        k    int
    }{
        {[]int{1, 12, -5, -6, 50, 3}, 4},
        {[]int{5}, 1},
    }

    for _, testCase := range testCases {
        fmt.Println(findMaxAverage(testCase.nums, testCase.k))
    }
}
</code></pre>
</section>
</section>
<section id="大小为-k-且平均值大于等于阈值的子数组数目" class="level3">
<h3 class="anchored" data-anchor-id="大小为-k-且平均值大于等于阈值的子数组数目"><a href="https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/description/">1343. 大小为 K 且平均值大于等于阈值的子数组数目</a></h3>
<section id="题面-2" class="level4">
<h4 class="anchored" data-anchor-id="题面-2">题面</h4>
<p>给你一个整数数组 arr 和两个整数 k 和 threshold 。</p>
<p>请你返回长度为 k 且平均值大于等于 threshold 的子数组数目。</p>
<p>示例 1：</p>
<p>输入：arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4</p>
<p>输出：3</p>
<p>解释：子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4，5 和 6 。其他长度为 3 的子数组的平均值都小于 4 （threshold 的值)。</p>
<p>示例 2：</p>
<p>输入：arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5</p>
<p>输出：6</p>
<p>解释：前 6 个长度为 3 的子数组平均值都大于 5 。注意平均值不是整数。</p>
<p>提示：</p>
<p>1 &lt;= arr.length &lt;= 10^5</p>
<p>1 &lt;= arr[i] &lt;= 10^4</p>
<p>1 &lt;= k &lt;= arr.length</p>
<p>0 &lt;= threshold &lt;= 10^4</p>
</section>
<section id="思路说明-2" class="level4">
<h4 class="anchored" data-anchor-id="思路说明-2">思路说明</h4>
<p>基本思路就是构建大小为k的窗口，计算窗口内元素的和，然后计算平均值是否大于等于某个阈值</p>
<p>还是按照咱们的步骤来</p>
</section>
<section id="题解-2" class="level4">
<h4 class="anchored" data-anchor-id="题解-2">题解</h4>
<pre class="golang"><code>
// 1343.大小为K且平均值大于等于阈值的子数组数目
package main

import "fmt"

func numOfSubarrays(arr []int, k, threshold int) int {
    ans, cnt := 0, 0

    for i, num := range arr {
        cnt += num
        if i &gt;= k {
            cnt -= arr[i-k]
        }

        if i &gt;= k-1 &amp;&amp; cnt &gt;= k*threshold {
            ans += 1
        }
    }

    return ans
}

func main() {
    testCases := []struct {
        arr       []int
        k         int
        threshold int
    }{
        {[]int{2, 2, 2, 2, 5, 5, 5, 8}, 3, 4},
        {[]int{11, 13, 17, 23, 29, 31, 7, 5, 2, 3}, 3, 5},
    }

    for _, testCase := range testCases {
        fmt.Println(numOfSubarrays(testCase.arr, testCase.k, testCase.threshold))
    }
}

</code></pre>
</section>
</section>
<section id="半径为-k-的子数组平均值" class="level3">
<h3 class="anchored" data-anchor-id="半径为-k-的子数组平均值"><a href="https://leetcode.cn/problems/k-radius-subarray-averages/description/">2090. 半径为 k 的子数组平均值</a></h3>
<section id="题面-3" class="level4">
<h4 class="anchored" data-anchor-id="题面-3">题面</h4>
<p>给你一个下标从 0 开始的数组 nums ，数组中有 n 个整数，另给你一个整数 k 。</p>
<p>半径为 k 的子数组平均值 是指：nums 中一个以下标 i 为 中心 且 半径 为 k 的子数组中所有元素的平均值，即下标在 i - k 和 i + k 范围（含 i - k 和 i + k）内所有元素的平均值。如果在下标 i 前或后不足 k 个元素，那么 半径为 k 的子数组平均值 是 -1 。</p>
<p>构建并返回一个长度为 n 的数组 avgs ，其中 avgs[i] 是以下标 i 为中心的子数组的 半径为 k 的子数组平均值 。</p>
<p>x 个元素的 平均值 是 x 个元素相加之和除以 x ，此时使用截断式 整数除法 ，即需要去掉结果的小数部分。</p>
<p>例如，四个元素 2、3、1 和 5 的平均值是 (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75，截断后得到 2 。</p>
<p>示例 1：</p>
<p>输入：nums = [7,4,3,9,1,8,5,2,6], k = 3</p>
<p>输出：[-1,-1,-1,5,4,4,-1,-1,-1]</p>
<p>解释： - avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。 - 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。 使用截断式 整数除法，avg[3] = 37 / 7 = 5 。 - 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。 - 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。 - avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。</p>
<p>示例 2：</p>
<p>输入：nums = [100000], k = 0</p>
<p>输出：[100000]</p>
<p>解释： - 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。 avg[0] = 100000 / 1 = 100000 。</p>
<p>示例 3：</p>
<p>输入：nums = [8], k = 100000</p>
<p>输出：[-1]</p>
<p>解释： - avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。</p>
<p>提示：</p>
<p>n == nums.length</p>
<p>1 &lt;= n &lt;= 10^5</p>
<p>0 &lt;= nums[i], k &lt;= 10^5</p>
</section>
<section id="思路说明-3" class="level4">
<h4 class="anchored" data-anchor-id="思路说明-3">思路说明</h4>
<p>本题提出了一个概念，半径为k的字数组</p>
<p>这个时候滑动窗口的实际大小是<strong>k * 2 + 1</strong></p>
<p>之后能作为圆心的点才能够有平均值，其他的都是-1</p>
<p>所以，先设置答案存储的数组 ans 然后将全部的值初始化为-1</p>
<p>之后还是按照我们之前总结的思路来</p>
</section>
<section id="题解-3" class="level4">
<h4 class="anchored" data-anchor-id="题解-3">题解</h4>
<pre class="golang"><code>// 2090.半径为k的子数组平均值
package main

import "fmt"

func getAverages(nums []int, k int) []int {
    ans := make([]int, len(nums))

    for i := range ans {
        ans[i] = -1
    }

    cnt := 0

    for i, num := range nums {
        cnt += num

        if i &gt;= 2*k {
            ans[i-k] = cnt / (k*2 + 1)
            cnt -= nums[i-2*k]
        }
    }

    return ans
}

func main() {
    testCases := []struct {
        nums []int
        k    int
    }{
        {[]int{7, 4, 3, 9, 1, 8, 5, 2, 6}, 3},
        {[]int{100000}, 0},
        {[]int{8}, 100000},
    }

    for _, testCase := range testCases {
        fmt.Println(getAverages(testCase.nums, testCase.k))
    }
}

</code></pre>
</section>
</section>
<section id="得到-k-个黑块的最少涂色次数" class="level3">
<h3 class="anchored" data-anchor-id="得到-k-个黑块的最少涂色次数"><a href="https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/description/">2379. 得到 K 个黑块的最少涂色次数</a></h3>
<section id="题面-4" class="level4">
<h4 class="anchored" data-anchor-id="题面-4">题面</h4>
<p>给你一个长度为 n 下标从 0 开始的字符串 blocks ，blocks[i] 要么是 ‘W’ 要么是 ‘B’ ，表示第 i 块的颜色。字符 ‘W’ 和 ‘B’ 分别表示白色和黑色。</p>
<p>给你一个整数 k ，表示想要 连续 黑色块的数目。</p>
<p>每一次操作中，你可以选择一个白色块将它 涂成 黑色块。</p>
<p>请你返回至少出现 一次 连续 k 个黑色块的 最少 操作次数。</p>
<p>示例 1：</p>
<p>输入：blocks = “WBBWWBBWBW”, k = 7</p>
<p>输出：3</p>
<p>解释： 一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色。</p>
<p>得到 blocks = “BBBBBBBWBW” 。</p>
<p>可以证明无法用少于 3 次操作得到 7 个连续的黑块。</p>
<p>所以我们返回 3 。</p>
<p>示例 2：</p>
<p>输入：blocks = “WBWBBBW”, k = 2</p>
<p>输出：0</p>
<p>解释：</p>
<p>不需要任何操作，因为已经有 2 个连续的黑块。</p>
<p>所以我们返回 0 。</p>
<p>提示：</p>
<p>n == blocks.length</p>
<p>1 &lt;= n &lt;= 100</p>
<p>blocks[i] 要么是 ‘W’ ，要么是 ‘B’ 。</p>
<p>1 &lt;= k &lt;= n</p>
</section>
<section id="思路说明-4" class="level4">
<h4 class="anchored" data-anchor-id="思路说明-4">思路说明</h4>
<p>我们需要的是K个连续的黑色块，也就是把大小为k的窗口中的白色块全部涂黑</p>
<p>我们要到这个最小的涂色数，也是黑色块最多，白色块最少</p>
<p>我们找到黑色块最多的然后用k减去这个数量即可</p>
</section>
<section id="题解-4" class="level4">
<h4 class="anchored" data-anchor-id="题解-4">题解</h4>
<pre class="golang"><code>// 2379.得到K个黑块的最少涂色次数
package main

import "fmt"

func minimumRecolors(blocks string, k int) int {
    ans, cnt := 0, 0

    for i, block := range blocks {
        if block == 'B' {
            cnt += 1
        }

        if i &gt;= k {
            if blocks[i-k] == 'B' {
                cnt -= 1
            }
        }

        if i &gt;= k-1 {
            ans = max(ans, cnt)
        }
    }

    return k - ans
}

func main() {
    testCases := []struct {
        blocks string
        k      int
    }{
        {"WBBWWBBWBW", 7},
        {"WBWBBBW", 2},
    }

    for _, testCase := range testCases {
        fmt.Println(minimumRecolors(testCase.blocks, testCase.k))
    }
}

</code></pre>
</section>
</section>
<section id="几乎唯一子数组的最大和" class="level3">
<h3 class="anchored" data-anchor-id="几乎唯一子数组的最大和"><a href="https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/description/">2841. 几乎唯一子数组的最大和</a></h3>
<section id="题面-5" class="level4">
<h4 class="anchored" data-anchor-id="题面-5">题面</h4>
<p>给你一个整数数组 nums 和两个正整数 m 和 k 。</p>
<p>请你返回 nums 中长度为 k 的 几乎唯一 子数组的 最大和 ，如果不存在几乎唯一子数组，请你返回 0 。</p>
<p>如果 nums 的一个子数组有至少 m 个互不相同的元素，我们称它是 几乎唯一 子数组。</p>
<p>子数组指的是一个数组中一段连续 非空 的元素序列。</p>
<p>示例 1：</p>
<p>输入：nums = [2,6,7,3,1,7], m = 3, k = 4</p>
<p>输出：18</p>
<p>解释：总共有 3 个长度为 k = 4 的几乎唯一子数组。分别为 [2, 6, 7, 3] ，[6, 7, 3, 1] 和 [7, 3, 1, 7] 。这些子数组中，和最大的是 [2, 6, 7, 3] ，和为 18 。</p>
<p>示例 2：</p>
<p>输入：nums = [5,9,9,2,4,5,4], m = 1, k = 3</p>
<p>输出：23</p>
<p>解释：总共有 5 个长度为 k = 3 的几乎唯一子数组。分别为 [5, 9, 9] ，[9, 9, 2] ，[9, 2, 4] ，[2, 4, 5] 和 [4, 5, 4] 。这些子数组中，和最大的是 [5, 9, 9] ，和为 23 。</p>
<p>示例 3：</p>
<p>输入：nums = [1,2,1,2,1,2,1], m = 3, k = 3</p>
<p>输出：0</p>
<p>解释：输入数组中不存在长度为 k = 3 的子数组含有至少 m = 3 个互不相同元素的子数组。所以不存在几乎唯一子数组，最大和为 0 。</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 2 * 10^4</p>
<p>1 &lt;= m &lt;= k &lt;= nums.length</p>
<p>1 &lt;= nums[i] &lt;= 10^9</p>
</section>
<section id="思路说明-5" class="level4">
<h4 class="anchored" data-anchor-id="思路说明-5">思路说明</h4>
<p>从这道题开始引入一个<strong>变量</strong>，开始对窗口中元素的数量进行控制</p>
<p>对数量的统计和控制可以通过引入哈希表实现，在golang中，我们可以使用map[type]type 来表示哈希表</p>
<p>通过map[num]可以统计num的数量，通过len(map)可以控制元素的种类，这也是最常用的两种方式</p>
<p>在本题中，我们要把len(map)控制在m以内</p>
<p>然后其他的逻辑都是固定的</p>
</section>
<section id="题解-5" class="level4">
<h4 class="anchored" data-anchor-id="题解-5">题解</h4>
<pre class="golang"><code>
// 2841.几乎唯一子数组的最大和
package main

import "fmt"

func maxSum(nums []int, m, k int) int64 {
    mp := make(map[int]int)
    var ans, cnt int64
    for i, num := range nums {
        cnt += int64(num)
        mp[num] += 1

        if i &gt;= k {
            cnt -= int64(nums[i-k])
            mp[nums[i-k]] -= 1
            if mp[nums[i-k]] == 0 {
                delete(mp, nums[i-k])
            }
        }

        if i &gt;= k-1 &amp;&amp; len(mp) &gt;= m {
            ans = max(ans, cnt)
        }
    }

    return ans
}

func main() {
    testCases := []struct {
        nums []int
        m    int
        k    int
    }{
        {[]int{2, 6, 7, 3, 1, 7}, 3, 4},
        {[]int{5, 9, 9, 2, 4, 5, 4}, 1, 3},
        {[]int{1, 2, 1, 2, 1, 2, 1}, 3, 3},
    }

    for _, testCase := range testCases {
        fmt.Println(maxSum(testCase.nums, testCase.m, testCase.k))
    }
}

</code></pre>
</section>
</section>
<section id="长度为-k-子数组中的最大和" class="level3">
<h3 class="anchored" data-anchor-id="长度为-k-子数组中的最大和"><a href="https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/description/">2461. 长度为 K 子数组中的最大和</a></h3>
<section id="题面-6" class="level4">
<h4 class="anchored" data-anchor-id="题面-6">题面</h4>
<p>给你一个整数数组 nums 和一个整数 k 。请你从 nums 中满足下述条件的全部子数组中找出最大子数组和：</p>
<p>子数组的长度是 k，且</p>
<p>子数组中的所有元素 各不相同 。</p>
<p>返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 0 。</p>
<p>子数组 是数组中一段连续非空的元素序列。</p>
<p>示例 1：</p>
<p>输入：nums = [1,5,4,2,9,9,9], k = 3</p>
<p>输出：15</p>
<p>解释：nums 中长度为 3 的子数组是： - [1,5,4] 满足全部条件，和为 10 。 - [5,4,2] 满足全部条件，和为 11 。 - [4,2,9] 满足全部条件，和为 15 。 - [2,9,9] 不满足全部条件，因为元素 9 出现重复。 - [9,9,9] 不满足全部条件，因为元素 9 出现重复。</p>
<p>因为 15 是满足全部条件的所有子数组中的最大子数组和，所以返回 15 。</p>
<p>示例 2：</p>
<p>输入：nums = [4,4,4], k = 3</p>
<p>输出：0</p>
<p>解释：nums 中长度为 3 的子数组是： - [4,4,4] 不满足全部条件，因为元素 4 出现重复。</p>
<p>因为不存在满足全部条件的子数组，所以返回 0 。</p>
<p>提示：</p>
<p>1 &lt;= k &lt;= nums.length &lt;= 10^5</p>
<p>1 &lt;= nums[i] &lt;= 10^5</p>
</section>
<section id="思路说明-6" class="level4">
<h4 class="anchored" data-anchor-id="思路说明-6">思路说明</h4>
<p>通过哈希表大小控制所有元素各不相同的要求，通过滑动窗口控制字数组的长度k</p>
</section>
<section id="题解-6" class="level4">
<h4 class="anchored" data-anchor-id="题解-6">题解</h4>
<pre class="golang"><code>
// 2461.长度为K子数组中的最大和
package main

import "fmt"

func maximumSubarraySum(nums []int, k int) int64 {
    mp := make(map[int]int)
    var ans, cnt int64

    for i, num := range nums {
        cnt += int64(num)
        mp[num] += 1

        if i &gt;= k {
            cnt -= int64(nums[i-k])
            mp[nums[i-k]] -= 1
            if mp[nums[i-k]] == 0 {
                delete(mp, nums[i-k])
            }

        }

        if i &gt;= k-1 &amp;&amp; len(mp) == k {
            ans = max(ans, cnt)
        }
    }

    return ans
}

func main() {
    testCases := []struct {
        nums []int
        k    int
    }{
        {[]int{1, 5, 4, 2, 9, 9, 9}, 3},
        {[]int{4, 4, 4}, 3},
    }

    for _, testCase := range testCases {
        fmt.Println(maximumSubarraySum(testCase.nums, testCase.k))
    }
}
</code></pre>
</section>
</section>
<section id="可获得的最大点数" class="level3">
<h3 class="anchored" data-anchor-id="可获得的最大点数"><a href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/description/">1423. 可获得的最大点数</a></h3>
<section id="题面-7" class="level4">
<h4 class="anchored" data-anchor-id="题面-7">题面</h4>
<p>几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。</p>
<p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。</p>
<p>你的点数就是你拿到手中的所有卡牌的点数之和。</p>
<p>给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。</p>
<p>示例 1：</p>
<p>输入：cardPoints = [1,2,3,4,5,6,1], k = 3</p>
<p>输出：12</p>
<p>解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。</p>
<p>示例 2：</p>
<p>输入：cardPoints = [2,2,2], k = 2</p>
<p>输出：4</p>
<p>解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。</p>
<p>示例 3：</p>
<p>输入：cardPoints = [9,7,7,9,7,7,9], k = 7</p>
<p>输出：55</p>
<p>解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。</p>
<p>示例 4：</p>
<p>输入：cardPoints = [1,1000,1], k = 1</p>
<p>输出：1</p>
<p>解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。</p>
<p>示例 5：</p>
<p>输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3</p>
<p>输出：202</p>
<p>提示：</p>
<p>1 &lt;= cardPoints.length &lt;= 10^5</p>
<p>1 &lt;= cardPoints[i] &lt;= 10^4</p>
<p>1 &lt;= k &lt;= cardPoints.length</p>
</section>
<section id="思路说明-7" class="level4">
<h4 class="anchored" data-anchor-id="思路说明-7">思路说明</h4>
<p>这道题同样归类于滑动窗口，它是首尾构成一个滑动窗口</p>
<p>我的做法现在数组首部构建一个长度为k的滑动窗口</p>
<p>然后移动窗口开始尾部移动，直到尾部移动k</p>
</section>
<section id="题解-7" class="level4">
<h4 class="anchored" data-anchor-id="题解-7">题解</h4>
<pre class="golang"><code>
// 1423.可获得的最大点数
package main

import "fmt"

func maxScore(cardPoints []int, k int) int {
    left := k - 1
    ans, cnt := 0, 0

    for i := 0; i &lt; k; i++ {
        cnt += cardPoints[i]
    }

    ans = cnt

    for i := len(cardPoints) - 1; i &gt;= len(cardPoints)-k; i-- {
        cnt -= cardPoints[left]
        left -= 1
        cnt += cardPoints[i]

        ans = max(ans, cnt)
    }

    return ans
}

func main() {
    testCases := []struct {
        nums []int
        k    int
    }{
        {[]int{1, 2, 3, 4, 5, 6, 1}, 3},
        {[]int{2, 2, 2}, 2},
        {[]int{9, 7, 7, 9, 7, 7, 9}, 7},
        {[]int{1, 1000, 1}, 1},
        {[]int{1, 79, 80, 1, 1, 1, 200, 1}, 3},
    }

    for _, testCase := range testCases {
        fmt.Println(maxSore(testCase.nums, testCase.k))
    }
}

</code></pre>
</section>
</section>
<section id="健身计划评估" class="level3">
<h3 class="anchored" data-anchor-id="健身计划评估"><a href="https://leetcode.cn/problems/diet-plan-performance/description/">1176. 健身计划评估</a></h3>
<section id="题面-8" class="level4">
<h4 class="anchored" data-anchor-id="题面-8">题面</h4>
<p>你的好友是一位健身爱好者。前段日子，他给自己制定了一份健身计划。现在想请你帮他评估一下这份计划是否合理。</p>
<p>他会有一份计划消耗的卡路里表，其中 calories[i] 给出了你的这位好友在第 i 天需要消耗的卡路里总量。</p>
<p>为了更好地评估这份计划，对于卡路里表中的每一天，你都需要计算他 「这一天以及之后的连续几天」 （共 k 天）内消耗的总卡路里 T：</p>
<p>如果 T &lt; lower，那么这份计划相对糟糕，并失去 1 分；</p>
<p>如果 T &gt; upper，那么这份计划相对优秀，并获得 1 分；</p>
<p>否则，这份计划普普通通，分值不做变动。</p>
<p>请返回统计完所有 calories.length 天后得到的总分作为评估结果。</p>
<p>注意：总分可能是负数。</p>
<p>示例 1：</p>
<p>输入：calories = [1,2,3,4,5], k = 1, lower = 3, upper = 3</p>
<p>输出：0</p>
<p>解释：calories[0], calories[1] &lt; lower 而 calories[3], calories[4] &gt; upper, 总分 = 0.</p>
<p>示例 2：</p>
<p>输入：calories = [3,2], k = 2, lower = 0, upper = 1</p>
<p>输出：1</p>
<p>解释：calories[0] + calories[1] &gt; upper, 总分 = 1.</p>
<p>示例 3：</p>
<p>输入：calories = [6,5,0,0], k = 2, lower = 1, upper = 5</p>
<p>输出：0</p>
<p>解释：calories[0] + calories[1] &gt; upper, calories[2] + calories[3] &lt; lower, 总分 = 0.</p>
<p>提示：</p>
<p>1 &lt;= k &lt;= calories.length &lt;= 10^5</p>
<p>0 &lt;= calories[i] &lt;= 20000</p>
<p>0 &lt;= lower &lt;= upper</p>
</section>
<section id="思路说明-8" class="level4">
<h4 class="anchored" data-anchor-id="思路说明-8">思路说明</h4>
<p>构建滑动窗口，统计窗口中消耗的卡路里，然后判断</p>
<p>基本思路还是按照之前的步骤</p>
</section>
<section id="题解-8" class="level4">
<h4 class="anchored" data-anchor-id="题解-8">题解</h4>
<pre class="golang"><code>
// 1176.健身计划评估
package main

import "fmt"

func dietPlanPerformance(calories []int, k, lower, upper int) int {
    ans, cnt := 0, 0

    for i, calorie := range calories {
        cnt += calorie

        if i &gt;= k {
            cnt -= calories[i-k]
        }

        if i &gt;= k-1 {
            if cnt &gt; upper {
                ans += 1
            }

            if cnt &lt; lower {
                ans -= 1
            }
        }
    }

    return ans
}

func main() {
    testCases := []struct {
        calories []int
        k        int
        lower    int
        upper    int
    }{
        {[]int{1, 2, 3, 4, 5}, 1, 3, 3},
        {[]int{3, 2}, 2, 0, 1},
        {[]int{6, 5, 0, 0}, 2, 1, 5},
    }

    for _, testCase := range testCases {
        fmt.Println(dietPlanPerformance(testCase.calories, testCase.k, testCase.lower, testCase.upper))
    }
}
</code></pre>
</section>
</section>
<section id="长度为-k-的无重复字符子串" class="level3">
<h3 class="anchored" data-anchor-id="长度为-k-的无重复字符子串"><a href="https://leetcode.cn/problems/find-k-length-substrings-with-no-repeated-characters/description/">1100. 长度为 K 的无重复字符子串</a></h3>
<section id="题面-9" class="level4">
<h4 class="anchored" data-anchor-id="题面-9">题面</h4>
<p>给你一个字符串 S，找出所有长度为 K 且不含重复字符的子串，请你返回全部满足要求的子串的 数目。</p>
<p>示例 1：</p>
<p>输入：S = “havefunonleetcode”, K = 5</p>
<p>输出：6</p>
<p>解释： 这里有 6 个满足题意的子串，分别是：‘havef’,‘avefu’,‘vefun’,‘efuno’,‘etcod’,‘tcode’。</p>
<p>示例 2：</p>
<p>输入：S = “home”, K = 5</p>
<p>输出：0</p>
<p>解释： 注意：K 可能会大于 S 的长度。在这种情况下，就无法找到任何长度为 K 的子串。</p>
<p>提示：</p>
<p>1 &lt;= S.length &lt;= 10^4</p>
<p>S 中的所有字符均为小写英文字母</p>
<p>1 &lt;= K &lt;= 10^4</p>
</section>
<section id="思路说明-9" class="level4">
<h4 class="anchored" data-anchor-id="思路说明-9">思路说明</h4>
<p>使用哈希表控制字符串是否重复</p>
<p>使用滑动窗口构建长度为k的子串</p>
</section>
<section id="题解-9" class="level4">
<h4 class="anchored" data-anchor-id="题解-9">题解</h4>
<pre class="golang"><code>
// 1100.长度为K的无重复字符子串
package main

import "fmt"

func numKLenSubstrNoRepeats(s string, k int) int {
    mp := make(map[byte]int)
    ans := 0

    for i := 0; i &lt; len(s); i++ {
        mp[s[i]] += 1

        if i &gt;= k {
            mp[s[i-k]] -= 1
            if mp[s[i-k]] == 0 {
                delete(mp, s[i-k])
            }
        }

        if i &gt;= k-1 &amp;&amp; len(mp) == k {
            ans += 1
        }
    }

    return ans
}

func main() {
    testCases := []struct {
        s string
        k int
    }{
        {"havefunonleetcode", 5},
        {"home", 5},
    }

    for _, testCase := range testCases {
        fmt.Println(numKLenSubstrNoRepeats(testCase.s, testCase.k))
    }
}
</code></pre>
</section>
</section>
<section id="每个子数组的数字种类数" class="level3">
<h3 class="anchored" data-anchor-id="每个子数组的数字种类数"><a href="https://leetcode.cn/problems/distinct-numbers-in-each-subarray/description/">1852. 每个子数组的数字种类数</a></h3>
<section id="题面-10" class="level4">
<h4 class="anchored" data-anchor-id="题面-10">题面</h4>
<p>给你一个长度为 n 的整数数组 nums 与一个整数 k。你的任务是找到 nums 所有 长度为 k 的子数组中 不同 元素的数量。</p>
<p>返回一个数组 ans，其中 ans[i] 是对于每个索引 0 &lt;= i &lt; n - k，nums[i..(i + k - 1)] 中不同元素的数量。</p>
<p>示例 1:</p>
<p>输入: nums = [1,2,3,2,2,1,3], k = 3</p>
<p>输出: [3,2,2,2,3]</p>
<p>解释：每个子数组的数字种类计算方法如下： - nums[0..2] = [1,2,3] 所以 ans[0] = 3 - nums[1..3] = [2,3,2] 所以 ans[1] = 2 - nums[2..4] = [3,2,2] 所以 ans[2] = 2 - nums[3..5] = [2,2,1] 所以 ans[3] = 2 - nums[4..6] = [2,1,3] 所以 ans[4] = 3</p>
<p>示例 2:</p>
<p>输入: nums = [1,1,1,1,2,3,4], k = 4</p>
<p>输出: [1,2,3,4]</p>
<p>解释: 每个子数组的数字种类计算方法如下： - nums[0..3] = [1,1,1,1] 所以 ans[0] = 1 - nums[1..4] = [1,1,1,2] 所以 ans[1] = 2 - nums[2..5] = [1,1,2,3] 所以 ans[2] = 3 - nums[3..6] = [1,2,3,4] 所以 ans[3] = 4</p>
<p>提示:</p>
<p>1 &lt;= k &lt;= nums.length &lt;= 10^5</p>
<p>1 &lt;= nums[i] &lt;= 10^5</p>
</section>
<section id="思路说明-10" class="level4">
<h4 class="anchored" data-anchor-id="思路说明-10">思路说明</h4>
<p>构建滑动窗口，长度固定为k</p>
<p>使用哈希表记录一下窗口内数字的种类，并实时更新</p>
</section>
<section id="题解-10" class="level4">
<h4 class="anchored" data-anchor-id="题解-10">题解</h4>
<pre class="golang"><code>
// 1852.每个子数组的数字种类数
package main

import "fmt"

func distinctNumbers(nums []int, k int) []int {
    mp := make(map[int]int)
    ans := make([]int, len(nums)-k+1)

    for i, num := range nums {
        mp[num] += 1

        if i &gt;= k {
            mp[nums[i-k]] -= 1
            if mp[nums[i-k]] == 0 {
                delete(mp, nums[i-k])
            }
        }

        if i &gt;= k-1 {
            ans[i-k+1] = len(mp)
        }
    }

    return ans
}

func main() {
    testCases := []struct {
        nums []int
        k    int
    }{
        {[]int{1, 2, 3, 2, 2, 1, 3}, 3},
        {[]int{1, 1, 1, 1, 2, 3, 4}, 4},
    }

    for _, testCase := range testCases {
        fmt.Println(distinctNumbers(testCase.nums, testCase.k))
    }
}
</code></pre>
</section>
</section>
<section id="最少交换次数来组合所有的-1" class="level3">
<h3 class="anchored" data-anchor-id="最少交换次数来组合所有的-1"><a href="https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/">1151. 最少交换次数来组合所有的 1</a></h3>
<section id="题面-11" class="level4">
<h4 class="anchored" data-anchor-id="题面-11">题面</h4>
<p>给出一个二进制数组 data，你需要通过交换位置，将数组中 任何位置 上的 1 组合到一起，并返回所有可能中所需 最少的交换次数。</p>
<p>示例 1:</p>
<p>输入: data = [1,0,1,0,1]</p>
<p>输出: 1</p>
<p>解释:</p>
<p>有三种可能的方法可以把所有的 1 组合在一起：</p>
<p>[1,1,1,0,0]，交换 1 次；</p>
<p>[0,1,1,1,0]，交换 2 次；</p>
<p>[0,0,1,1,1]，交换 1 次。</p>
<p>所以最少的交换次数为 1。</p>
<p>示例 2:</p>
<p>输入：data = [0,0,0,1,0]</p>
<p>输出：0</p>
<p>解释：</p>
<p>由于数组中只有一个 1，所以不需要交换。</p>
<p>示例 3:</p>
<p>输入：data = [1,0,1,0,1,0,0,1,1,0,1]</p>
<p>输出：3</p>
<p>解释：</p>
<p>交换 3 次，一种可行的只用 3 次交换的解决方案是 [0,0,0,0,0,1,1,1,1,1,1]。</p>
<p>示例 4:</p>
<p>输入: data = [1,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,0,1]</p>
<p>输出: 8</p>
<p>提示:</p>
<p>1 &lt;= data.length &lt;= 10^5</p>
<p>data[i] == 0 or 1.</p>
</section>
<section id="思路说明-11" class="level4">
<h4 class="anchored" data-anchor-id="思路说明-11">思路说明</h4>
<p>题目的要求是把所有的1都组合在一起，并返回所需要的最少交换次数</p>
<p>我们首先需要知道数组中1的个数，将这个数量作为滑动窗口的大小</p>
<p>我们已经得到滑动窗口的大小，然后统计窗口中最大的1的数量，用窗口大小减去这个最大值，就是我们需要的最少交换次数</p>
</section>
<section id="题解-11" class="level4">
<h4 class="anchored" data-anchor-id="题解-11">题解</h4>
<pre class="golang"><code>
// 1151.最少交换次数来组合所有的1
package main

import "fmt"

func minSwaps(data []int) int {
    k := 0 // 滑动窗口的大小
    for _, val := range data {
        k += val
    }

    ans, cnt := 0, 0

    for i, val := range data {
        cnt += val

        if i &gt;= k {
            cnt -= data[i-k]
        }

        if i &gt;= k-1 {
            ans = max(ans, cnt)
        }
    }

    return k - ans
}

func main() {
    testCases := [][]int{
        []int{1, 0, 1, 0, 1},
        []int{0, 0, 0, 1, 0},
        []int{1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1},
        []int{1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1},
    }

    for _, testCase := range testCases {
        fmt.Println(minSwaps(testCase))
    }
}
</code></pre>
</section>
</section>
<section id="分享-k-个糖果后独特口味的数量" class="level3">
<h3 class="anchored" data-anchor-id="分享-k-个糖果后独特口味的数量"><a href="https://leetcode.cn/problems/number-of-unique-flavors-after-sharing-k-candies/description/">2107. 分享 K 个糖果后独特口味的数量</a></h3>
<section id="题面-12" class="level4">
<h4 class="anchored" data-anchor-id="题面-12">题面</h4>
<p>您将获得一个 从0开始的 整数数组 candies ，其中 candies[i] 表示第 i 个糖果的味道。你妈妈想让你和你妹妹分享这些糖果，给她 k 个 连续 的糖果，但你想保留尽可能多的糖果口味。</p>
<p>在与妹妹分享后，返回 最多 可保留的 独特 口味的糖果。</p>
<p>示例 1：</p>
<p>输入: candies = [1,2,2,3,4,3], k = 3</p>
<p>输出: 3</p>
<p>解释: 将[1,3]（含[2,2,3]）范围内的糖果加入[2,2,3]口味。 你可以吃各种口味的糖果[1,4,3]。 有3种独特的口味，所以返回3。</p>
<p>示例 2:</p>
<p>输入: candies = [2,2,2,2,3,3], k = 2</p>
<p>输出: 2</p>
<p>解释: 在[3,4]范围内（含[2,3]）的糖果中加入[2,3]口味。 你可以吃各种口味的糖果[2,2,2,3]。 有两种独特的口味，所以返回2。 请注意，你也可以分享口味为[2,2]的糖果，吃口味为[2,2,3,3]的糖果。</p>
<p>示例 3:</p>
<p>输入: candies = [2,4,5], k = 0</p>
<p>输出: 3</p>
<p>解释: 你不必给任何糖果。 你可以吃各种口味的糖果[2,4,5]。 有3种独特的口味，所以返回3。</p>
<p>提示:</p>
<p>0 &lt;= candies.length &lt;= 10^5</p>
<p>1 &lt;= candies[i] &lt;= 10^5</p>
<p>0 &lt;= k &lt;= candies.length</p>
</section>
<section id="思路说明-12" class="level4">
<h4 class="anchored" data-anchor-id="思路说明-12">思路说明</h4>
<p>这个题目比较特殊，是要构建一个连续数组，数组长度为k，删除这个数组后剩余的数字种类尽量多</p>
<p>这样就使用哈希表存储剩余种类和对应数量即可</p>
<p>还是按照三步进行即可</p>
</section>
<section id="题解-12" class="level4">
<h4 class="anchored" data-anchor-id="题解-12">题解</h4>
<pre class="golang"><code>
// 2107.分享K个糖果后独特口味的数量
package main

import "fmt"

func shareCandies(candies []int, k int) int {
    mp := make(map[int]int)
    ans := 0

    for _, candie := range candies {
        mp[candie] += 1
    }

    for i, candie := range candies {
        mp[candie] -= 1

        if mp[candie] == 0 {
            delete(mp, candie)
        }

        if i &gt;= k {
            mp[candies[i-k]] += 1
        }

        if i &gt;= k-1 {
            ans = max(ans, len(mp))
        }
    }

    return ans
}

func main() {
    testCases := []struct {
        candies []int
        k       int
    }{
        {[]int{1, 2, 2, 3, 4, 3}, 3},
        {[]int{2, 2, 2, 2, 3, 3}, 2},
        {[]int{2, 4, 5}, 0},
    }

    for _, testCase := range testCases {
        fmt.Println(shareCandies(testCase.candies, testCase.k))
    }
}
</code></pre>


</section>
</section>
</section>

</main> <!-- /main -->
<button id="lang-toggle" type="button" aria-label="Toggle language"></button>
<script>
  (() => {
    const storageKey = "site-lang";
    const defaultLang = "zh";
    const button = document.getElementById("lang-toggle");
    if (!button) {
      return;
    }

    const applyLang = (lang) => {
      document.body.dataset.lang = lang;
      button.textContent = lang === "zh" ? "EN" : "中文";
      button.setAttribute("aria-label", lang === "zh" ? "Switch to English" : "切换中文");
      window.localStorage.setItem(storageKey, lang);
    };

    const stored = window.localStorage.getItem(storageKey);
    applyLang(stored || defaultLang);

    button.addEventListener("click", () => {
      const next = document.body.dataset.lang === "zh" ? "en" : "zh";
      applyLang(next);
    });
  })();
</script>
<script>
  (() => {
    const storageKey = "theme-preference";
    const getStored = () => {
      try {
        return window.localStorage.getItem(storageKey);
      } catch {
        return null;
      }
    };
    const setStored = (value) => {
      try {
        window.localStorage.setItem(storageKey, value);
      } catch {}
    };
    const currentTheme = () =>
      document.body.classList.contains("quarto-dark") ? "dark" : "light";

    const applyStored = () => {
      const stored = getStored();
      if (!stored) {
        return;
      }
      if (stored !== currentTheme() && window.quartoToggleColorScheme) {
        window.quartoToggleColorScheme();
      }
    };

    const bindToggle = () => {
      const toggles = document.querySelectorAll(".quarto-color-scheme-toggle");
      toggles.forEach((toggle) => {
        toggle.addEventListener("click", () => {
          window.setTimeout(() => setStored(currentTheme()), 0);
        });
      });
    };

    applyStored();
    bindToggle();
  })();
</script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>© 2026</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>Built with Quarto</p>
</div>
  </div>
</footer>




</body></html>