[
  {
    "objectID": "content/projects/entries/Quarto-Blogs-Template.html#项目介绍",
    "href": "content/projects/entries/Quarto-Blogs-Template.html#项目介绍",
    "title": "Quarto-Blogs-Template",
    "section": "项目介绍",
    "text": "项目介绍\n这是一个基于 Quarto 构建的现代化个人博客/网站模板，专为研究人员、学生和开发者设计，用于展示研究笔记、项目成果、论文阅读心得和学习记录。\n项目链接\n\n主要特点\n\n模块化结构：支持博客、项目、论文阅读和学习笔记等多种内容类型\n中英文双语支持：内置语言切换功能，轻松实现内容国际化\n响应式设计：适配各种设备屏幕尺寸\n快速开发：提供一键脚本，简化本地预览、构建和发布流程\n自动聚合：首页自动聚合各模块最新内容\n可扩展性：支持自定义样式和内容结构"
  },
  {
    "objectID": "content/projects/entries/Quarto-Blogs-Template.html#环境要求",
    "href": "content/projects/entries/Quarto-Blogs-Template.html#环境要求",
    "title": "Quarto-Blogs-Template",
    "section": "环境要求",
    "text": "环境要求\n\nQuarto：安装指南\nBash：用于运行脚本（Windows 用户可使用 WSL 或 Git Bash）\nrsync：用于发布时的文件同步（部分脚本需要）"
  },
  {
    "objectID": "content/projects/entries/Quarto-Blogs-Template.html#快速开始",
    "href": "content/projects/entries/Quarto-Blogs-Template.html#快速开始",
    "title": "Quarto-Blogs-Template",
    "section": "快速开始",
    "text": "快速开始\n\n本地预览\n./scripts/preview.sh   # 启动本地服务器（热更新）\n\n\n构建项目\n./scripts/build.sh     # 构建网站到 site/ 目录\n\n\n发布网站\n./scripts/publish.sh   # 备份旧 docs/ 并同步 site/ -&gt; docs/"
  },
  {
    "objectID": "content/projects/entries/Quarto-Blogs-Template.html#详细使用说明",
    "href": "content/projects/entries/Quarto-Blogs-Template.html#详细使用说明",
    "title": "Quarto-Blogs-Template",
    "section": "详细使用说明",
    "text": "详细使用说明\n\n目录结构（核心）\n├── content/              # 所有可渲染内容\n│   ├── assets/           # 全站共享图片素材\n│   ├── blogs/entries/    # 博客文章\n│   ├── projects/entries/ # 项目介绍\n│   ├── papers/entries/   # 论文阅读笔记\n│   └── learning-notes/   # 学习笔记（含子模块）\n├── includes/             # 页面片段（如语言切换按钮）\n├── pages/                # 页面文件\n│   ├── index.qmd         # 默认首页（About Me）\n│   └── home.qmd          # Home 页面（聚合各模块最新内容）\n├── scripts/              # 一键脚本\n├── site/                 # 构建产物（默认输出目录）\n├── docs/                 # 发布目录（GitHub Pages）\n├── styles.css            # 全站样式\n└── _quarto.yml           # 项目配置文件\n\n\n新增内容\n\n1. 新增博客文章\n\n进入博客文章目录：content/blogs/entries/\n新建文件，例如 my-blog-post.qmd\n添加 YAML 头部并开始写作：\n\n---\ntitle: \"我的博客文章\"\ndate: 2026-01-13\ncategories: [blogs]\ndescription: \"这是一篇示例博客文章\"\n---\n\n插入图片（使用相对路径）：\n\n![示例图片](../../assets/image.png)\n\n\n2. 新增项目\n\n进入项目目录：content/projects/entries/\n新建文件，例如 my-project.qmd\n按照上述博客文章的格式编写内容\n\n\n\n3. 新增论文阅读笔记\n\n进入论文目录：content/papers/entries/\n新建文件，例如 paper-review.qmd\n按照上述格式编写内容\n\n\n\n4. 新增学习笔记\n\n进入学习笔记目录：content/learning-notes/\n可以创建新的子模块（如 lesson4/）并在其中添加 entries/ 目录\n或者在现有子模块中添加新笔记\n\n\n\n\n语言切换功能\n项目支持中英文双语内容切换，使用方法如下：\n::: {.lang-zh}\n这是中文内容\n:::\n\n::: {.lang-en}\nThis is English content\n:::\n在导航栏和页面标题中也可以使用 HTML 标签实现语言切换：\n&lt;span class=\"lang-en\"&gt;About Me&lt;/span&gt;&lt;span class=\"lang-zh\"&gt;关于我&lt;/span&gt;\n\n\n自定义样式\n\n修改 styles.css 文件可以自定义全站样式\n支持自定义主题颜色、字体大小、布局等"
  },
  {
    "objectID": "content/projects/entries/Quarto-Blogs-Template.html#脚本说明",
    "href": "content/projects/entries/Quarto-Blogs-Template.html#脚本说明",
    "title": "Quarto-Blogs-Template",
    "section": "脚本说明",
    "text": "脚本说明\n\n1. 本地预览脚本 (preview.sh)\n\n启动 Quarto 本地服务器\n支持热更新，修改内容后自动刷新页面\n默认端口：4321\n\n\n\n2. 构建脚本 (build.sh)\n\n构建网站到 site/ 目录\n生成静态 HTML 文件\n\n\n\n3. 发布脚本 (publish.sh)\n\n备份旧的 docs/ 目录到 backup/\n构建网站\n将构建产物从 site/ 同步到 docs/（GitHub Pages 发布目录）\n自动清理旧备份（默认保留最近 3 个备份）\n\n\n\n4. 渲染后清理脚本 (post-render-clean.sh)\n\n在项目渲染后自动执行\n清理嵌套目录结构\n优化文件组织\n\n\n\n5. 备份清理脚本 (prune-backups.sh)\n\n清理旧的备份文件\n可以手动运行以释放存储空间"
  },
  {
    "objectID": "content/projects/entries/Quarto-Blogs-Template.html#配置文件说明",
    "href": "content/projects/entries/Quarto-Blogs-Template.html#配置文件说明",
    "title": "Quarto-Blogs-Template",
    "section": "配置文件说明",
    "text": "配置文件说明\n\n_quarto.yml\n主要配置文件，包含： - 项目类型和输出目录 - 渲染规则和资源管理 - 网站导航栏和页脚设置 - 主题和格式配置\n\n\n渲染规则\nrender:\n  - pages/index.qmd\n  - pages/home.qmd\n  - content/**/index.qmd\n  - content/**/entries/**/*.qmd\n  - content/**/entries/**/*.md\n\n\n资源管理\nresources:\n  - assets/**\n  - content/assets/**"
  },
  {
    "objectID": "content/projects/entries/Quarto-Blogs-Template.html#部署",
    "href": "content/projects/entries/Quarto-Blogs-Template.html#部署",
    "title": "Quarto-Blogs-Template",
    "section": "部署",
    "text": "部署\n\nGitHub Pages\n\n将项目推送到 GitHub 仓库\n配置 GitHub Pages 从 docs/ 目录部署\n运行 ./scripts/publish.sh 构建并发布网站\n\n\n\n其他静态网站托管\n\n运行 ./scripts/build.sh 构建网站\n将 site/ 目录中的内容部署到你的托管服务"
  },
  {
    "objectID": "content/projects/entries/Quarto-Blogs-Template.html#注意事项",
    "href": "content/projects/entries/Quarto-Blogs-Template.html#注意事项",
    "title": "Quarto-Blogs-Template",
    "section": "注意事项",
    "text": "注意事项\n\ntmp/ 目录用于存放草稿，不会被渲染和提交到 Git\nbackup/ 目录存放发布备份，可随时清理\n确保所有内容文件都有正确的 YAML 头部\n使用相对路径引用图片和其他资源"
  },
  {
    "objectID": "content/projects/entries/Quarto-Blogs-Template.html#许可证",
    "href": "content/projects/entries/Quarto-Blogs-Template.html#许可证",
    "title": "Quarto-Blogs-Template",
    "section": "许可证",
    "text": "许可证\nApache License"
  },
  {
    "objectID": "content/projects/entries/Quarto-Blogs-Template.html#贡献",
    "href": "content/projects/entries/Quarto-Blogs-Template.html#贡献",
    "title": "Quarto-Blogs-Template",
    "section": "贡献",
    "text": "贡献\n欢迎提交 Issues 和 Pull Requests 来改进这个模板！"
  },
  {
    "objectID": "content/projects/entries/GoLink.html",
    "href": "content/projects/entries/GoLink.html",
    "title": "GoLink",
    "section": "",
    "text": "一个简单实用的短链接项目。项目地址"
  },
  {
    "objectID": "content/projects/entries/GoLink.html#短链接简介",
    "href": "content/projects/entries/GoLink.html#短链接简介",
    "title": "GoLink",
    "section": "短链接简介",
    "text": "短链接简介\n\n是什么\n短链接通俗来讲是将一个比较长的 URL 通过程序计算的方式转换成简单的简短的网址链接。\n我平时收到最多的短链接就是京东发的，下面是一个例子\n【京东】北京国补狂欢限时猛料，26年国补正式上线！上京东领补贴立省15％，限时抢，手慢无！抢 3.cn/v/1-FT59nd 拒收请回复R\n我们点击之后得到的 URL 是：\nhttps://pro.m.jd.com/mall/active/4YSZ3d72rtEfxiWiDVcWRBEjCbSd/index.html?babelChannel=ttt58\n正是通过短链接的方式将原本长长的地址换成了一个简短的，并且让人读不懂的链接。\n很多公司也有提供短链接服务：\n\n百度：dwz.cn\n微博：t.cn\n。。。\n\n\n\n为什么\n一般公司内部会有很多需要发送链接的场景，并且业务侧的非常细致，导致链接非常长，在发送短信，IM 工具发送消息以及 push 等场景会会有很多劣势，比如：\n\n短信内容可能超长，截断会花更多的钱，信息也不完整\n社交平台的字数限制\n还有的平台监管机制比较严格，能识别关键字，判定为违规，比如小某书、某红书和小红某\nURL 是可以转换成二维码的，如果太长，转换成的二维码就会非常复杂，短链接转换成的二维码更加清晰\n\n这个时候将长链接转换成短链接就显得非常重要。\n\n\n怎么做\n\n浏览器并不能将短链接转换成长链接，这里涉及到一个重新定向的概念。\n浏览器收到短链接的地址，向公司的短链接服务器发送请求，公司返回数据和 302 重定向的状态码，之后浏览器进行重定向，向真正的业务服务器发送请求。"
  },
  {
    "objectID": "content/projects/entries/GoLink.html#项目设计",
    "href": "content/projects/entries/GoLink.html#项目设计",
    "title": "GoLink",
    "section": "项目设计",
    "text": "项目设计\n\n需求分析\n背景 \n公司内部业务需要大量发送营销短信、通知类的短信，在客服电话推销之后要发送到短信配套营销。\n需要一个短链接服务满足各个业务线的使用，现阶段是提供转链接的接口，后续可以提供点击链接统计的数据报表分析接口\n描述 \n\n输入一个长网址得到一个唯一的短网址\n用户点击短链接能够跳转到对应的网址\n为了保证业务的延续性，短网址长期有效\n\n定位 \n\n只是公司内部业务使用的短链接服务，只接收公司内部的长链接转短链接需求，不提供对外的服务\n基本在国内使用\n后续可能会根据需求提供短链接的访问数据报表接口\n\n规模 \n\n服务于公司内部多少条业务线\n用户的规模是什么量级\nQPS 是多少\n\n注：QPS是指每秒查询率（Queries Per Second），是衡量系统性能的一个重要指标，表示系统每秒能够处理的查询请求数量。在数据库、网络、服务器等领域中，QPS是一个常用的性能指标，通常越高表示系统性能越好。\n\n\n技术指标 \n\n请求延时，多少 ms之内要完成整个过程\n可靠性，保证 99.99% 能正常跳转\n安全性，不能数据泄露，被攻击\n\n功能模块分析 \n根据需求分析，可以将需求拆分成转链模块、存储模块和访问链接模块，以及可以拓展的数据统计模块\n\n转链模块\n\n相同的长链接转成同一个短链接（也可以根据个人信息转成不同的，比如推广机制，精确到人）\n生成的短链接为尽可能短的字符\n需要避免出现一些不合适的词语和有些具有特殊含义的词语\n需要避免循环转链（把已经是短链的再拿出来转短链）\n\n存储模块\n\n保存原始长链接和短链接之间的对应关系\n能够根据短链接查到原始的长链接\n\n查看链接模块\n\n根据链接查询到长链后返回重定向响应\n后续数据报表需求可能需要采集并统计请求头数据\n\n\n\n\n系统设计\n根据实际的业务场景，我们能够发现存入的链接是少的，访问的链接是多的，这是一个典型的读多写少的系统。\n并且还有个特点就是数据写入之后基本不需要改变，这样数据一致性问题其实可以忽略，能够使用缓存系统来提高读的效率。\n\n整体框架\n\n\n长链接转短链接\n\n单独部署为一个微服务（转链服务）\n对其他服务提供转链服务，需要鉴权\n\n通过RESTful API调用我们的转链接口\n通过RPC方式调用我们的转链方法（自己实现一个RPC版本的转链）\n\n\n查看短链接\n\n单独部署为一个服务（查看短链服务）\n通过 nginx 转发查看请求，/[0-9+a-z+A-Z]* –&gt; 转发到我们的查链服务\n通过 access.log 收集（EFK）并统计访问数据\n\n\n\n\n技术方案\n短链接生成方式 \n\nHash\n\n使用hash 函数对长链接进行 hash，得到的 hash 值作为短链接标识符\n这样做的优势比较简单，但是如果数据量大会出现哈希冲突\nMurmurHash 是一种非加密型哈希函数，和其他流行的哈希函数相比，对规律性比较强的 key随机分布特性表现更加优良，这种算法随机分布特性表现好，算法速度快。\n\n发号器/自增序列\n\n每收到一个长链接转短链接请求之后，就使用发号器生成递增，然后将该序列号转成 62 （10+26*2）进制，最后拼接到短域名之后就得到最后的最终短链。\n发号器能生成 id的自增，理论上容量足够满足实现需求。但是高并发的情况下发号器的设计比比较难，因为要实现合理的自增。\n发号器的实现方式\n\n基于 uuid 实现\n\n优势：不会重复、性能好\n劣势：数字太大，有 32 位的 16 进制数\n\n基于 redis 实现发号器\n\n优势：高性能\n劣势：需要搭建高可用架构并考虑持久化\n\n基于雪花算法的分布式 ID生成器\n\n优势：高性能、高可用\n劣势：实现复杂，依赖时钟\n\n基于 MySQL 自增主键的发号器\n\n优势：简单可靠\n劣势：依赖 MySQL，性能会成为瓶颈，但是可以通过分片拓展可用性\n\n\n\n基于 MySQL 自增主键实现发号器\n\n我们的项目采用基于 MySQL 数据库主键作为发号器的方案\n构建一个数据表，这个表的结构比较简单，不能包含其他多余的数据字段\n每有一次转链请求，我们都会在数据表表中插入一个记录，我们可以使用该表自增 ID 作为生成的号码\n使用 MySQL replace，如果表中的旧行和新行在 primary key 或 unique 索引具有相同的值，就在新行之前删除旧行。\n为了避免单点故障，我们将ID 生成器分成奇数和偶数两个部分，分别部署在两个 MySQL 服务器。\n\nserver1:\nauto-increment-increment = 2\nauto-increment-offset = 1\n\nserver2:\nauto-increment-increment = 2\nauto-increment-offset = 2\n\n下面是数据表创建和相关 SQL 语句\n\n/* 序号表的设计 */\n\nCREATE TABLE `sequence` (\n    `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n    `stub` varchar(1) NOT NULL,\n    `timestamp` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    PRIMARY KEY (`id`),\n    UNIQUE KEY `idx_uniq_stub` (`stub`)\n\n) ENGINE=MyISAM DEFAULT CHARSET=utf8;\n\nREPLACE INTO sequence (stub) VALUES ('a');\nSELECT LAST_INSERT_ID();\n\n简单测试\n\n数据表 \n\n数据表设计\n\nlur1和 sur1都唯一，长链和短链都不允许重复\n长链接的数据量大不适合建索引，所以这里使用md5值来做索引\nis_del是软删除标识\n可以采用读写分离的模式，写主库、读从库\n\nCREATE TABLE `short_url_map` (\n    `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键',\n    `create_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    `create_by` VARCHAR(64) NOT NULL DEFAULT '' COMMENT '创建者',\n    `is_del` tinyint UNSIGNED NOT NULL DEFAULT '0' COMMENT '是否删除：0正常 1删除',\n\n    `lurl` varchar(2048) DEFAULT NULL COMMENT '长链接',\n    `md5` char(32) DEFAULT NULL COMMENT '长链接MD5',\n    `surl` varchar(11) DEFAULT NULL COMMENT '短链接',\n    PRIMARY KEY(`id`),\n    INDEX(`is_del`),\n    UNIQUE(`md5`),\n    UNIQUE(`surl`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8mb4;\n数据量\n\nURL 网址的最大长度不同浏览器下不同\n1 条长链+短链需要的存储空间假设为 200bytes/条\n假设每个业务线每秒写入 100 条，10 条线就是 1000 条/秒\n一主两备份共三份数据，索引等冗余系统 1.5\n这样 200*1000*3600*24*365*3*1.5大概等于 20T\n\n数据删除\n\n本项目不涉及链接配置过期时间，所有删除均为软删除，通过手动标记实现删除\n\n\n预防攻击 \n\n对外服务\n\nIP 请求限制\n用户限制转链额度\n记录已转链接的 URL 缓存，防止刷光 ID，适用于相同的 URL 可以转成不同短链接的场景\n\nLRU 缓存 URL\n布隆过滤器\n\n校验链接是否有效\n\n对内服务\n\n权限认证\n账户每日限额\n检验链接是否有效\n\n\n访问短链方式 \n\n使用 Redis 作为缓存+MySQL 进行持久化存储\n短链接请求进来之后先根据标识符查询缓存中的，有就返回，没有就查询，MySQL 数据库，查到就返回重定位响应，也才写入缓存中\n关于缓存设置\n\n采用 LRU 方式\nRedis 集群部署\n根据数据量设计内存的大小，使用 LRU 淘汰策略，移除最近最少使用的 key\n\n环保节缓存击穿的问题\n\n过期时间加大\n加锁\n使用 singleflight 合并请求\n\n解决缓存穿透的问题\n\n通过布隆过滤器，不存储原始数据，如果过滤器找不到一定不在，找到了就查找数据库，可能不存在\n布谷鸟过滤器，支持删除本项目比较适合使用布谷鸟过滤器\n\n\n部署 \n我们的短链服务部署在 Nginx 后。通过这种方式，可以通过 Nginx 的访问日志（access.log）来统计访问数据。（例如通过EFK采集日志，统计报表）\n项目管理 \n使用 git\n\n\n技术栈总结\nGolang Go-Zero MySQL Redis Git Nginx EFK"
  },
  {
    "objectID": "content/projects/entries/GoLink.html#项目实现",
    "href": "content/projects/entries/GoLink.html#项目实现",
    "title": "GoLink",
    "section": "项目实现",
    "text": "项目实现\n\n1、搭建项目骨架\n\n1.1、建库建表\n使用 docker创建的 MySQL 容器，在其中进行建库建表，具体过程如下图：\n\n\n\n1.2、搭建 go-zero框架的骨架\n我们使用 goctl进行框架代码的生成\n\napi 文件 \nsyntax = \"v1\"\n\n// 进行项目的简单说明\ninfo (\n    title:   \"短链接项目\"\n    author:  \"aorangehc\"\n    date:    \"2025年 8 月 5 日\"\n    version: \"v1\"\n)\n\ntype ConvertReq {\n    LongUrl string `json:\"longUrl\"`\n}\n\ntype ConvertResp {\n    ShortUrl string `json:\"shortUrl\"`\n}\n\ntype ShowReq {\n    ShortUrl string `json:\"shortUrl\"`\n}\n\ntype ShowResp {\n    LongUrl string `json:\"longUrl\"`\n}\n\n@server (\n    prefix: \"/api/shortener\"\n)\nservice shortener_api {\n    @handler ConvertHandler\n    post /convert (ConvertReq) returns (ConvertResp)\n\n    @handler ShowHandler\n    get /:shortUrl (ShowReq) returns (ShowResp)\n}\nmodel文件 \nCREATE TABLE `sequence` (\n    `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n    `stub` varchar(1) NOT NULL,\n    `timestamp` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    PRIMARY KEY (`id`),\n    UNIQUE KEY `idx_uniq_stub` (`stub`)\n\n) ENGINE=MyISAM DEFAULT CHARSET=utf8;\n\nCREATE TABLE `short_url_map` (\n    `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键',\n    `create_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    `create_by` VARCHAR(64) NOT NULL DEFAULT '' COMMENT '创建者',\n    `is_del` tinyint UNSIGNED NOT NULL DEFAULT '0' COMMENT '是否删除：0正常 1删除',\n    \n    `lurl` varchar(2048) DEFAULT NULL COMMENT '长链接',\n    `md5` char(32) DEFAULT NULL COMMENT '长链接MD5',\n    `surl` varchar(11) DEFAULT NULL COMMENT '短链接',\n    PRIMARY KEY(`id`),\n    INDEX(`is_del`),\n    UNIQUE(`md5`),\n    UNIQUE(`surl`)\n) ENGINE=INNODB DEFAULT CHARSET=utf8mb4;\n\n\n1.3、下载项目依赖\n# 在根目录下使用\ngo mod tidy\n\n\n1.4、运行项目\n运行正常\n\n\n\n1.5、修改配置文件和配置结构体\n咋yaml 文件中增加数据库配置并在 config 文件中进行相应参数的添加。\nShortUrlDB:\n  DataSource: \"user:password@tcp(127.0.0.1:3307)/golink?charset=utf8mb4&parseTime=True&loc=Local\"\n\nSequenceDB:\n  DataSource: \"user:password@tcp(127.0.0.1:3307)/golink?charset=utf8mb4&parseTime=True&loc=Local\"\n  \n  type Config struct {\n    rest.RestConf\n\n    ShortUrlDB struct {\n        DataSource string\n    }\n\n    SequenceDB struct {\n        DataSource string\n    }\n}\n\n\n\n2、转链\n长链接 -&gt; 短链接\n\n2.1、长链接校验\n数据不能为空 \n使用 validator 库进行参数校验\ngo get github.com/go-playground/validator/v10\n之后在 api文件中参数后面添加 validate 参数和设置\ntype ConvertReq {\n    LongUrl string `json:\"longUrl\" validate:\"required\"`\n}\n\ntype ConvertResp {\n    ShortUrl string `json:\"shortUrl\"`\n}\n\ntype ShowReq {\n    ShortUrl string `json:\"shortUrl\" validate:\"required\"`\n}\n\ntype ShowResp {\n    LongUrl string `json:\"longUrl\"`\n}\n重新生成代码后修改 context 文件并测试，数据校验设置成功，对空数据会直接报错。\n// 参数校验\nif err := validator.New().StructCtx(r.Context(), &req); err != nil {\n    httpx.ErrorCtx(r.Context(), w, err)\n    return\n}\n\n长链接能够进行请求 \n通过 http 标准库创建一个 http 客户端进行探活\n\n\n判断是否已经转链 \n数据库中使用 md5作为主键\n先生成md5\n之后查数据库中的 md5是否存在\nmd5Str := md5.Sum([]byte(req.LongUrl))\nu, err := l.svcCtx.ShortUrlModel.FindOneByMd5(l.ctx, sql.NullString{String: md5Str, Valid: true})\nif err != sqlx.ErrNotFound {\n    if err == nil {\n        return nil, errors.New(\"该长链接已转链，短链接为：\" + u.Surl.String)\n    }\n    logx.Errorw(\"ShortUrlModel.FindOneByMd5 error\", logx.Field(\"err\", err), logx.Field(\"md5\", md5Str))\n    return nil, err\n}\n\n// Sum 计算数据的 MD5 值，返回十六进制字符串表示\nfunc Sum(data []byte) string {\n    h := md5.New()\n    h.Write(data)\n    return hex.EncodeToString(h.Sum(nil))\n}\n    \n避免循环转链接 \n解析出链接的 basepath，然后查询数据库中是否是已经转过的短链\nbasePath, err := urltools.GetBasePath(req.LongUrl)\nif err != nil {\n    logx.Errorw(\"GetBasePath error\", logx.Field(\"err\", err))\n    return nil, err\n}\nu, err = l.svcCtx.ShortUrlModel.FindOneBySurl(l.ctx, sql.NullString{String: basePath, Valid: true})\nif err != sqlx.ErrNotFound {\n    if err == nil {\n        return nil, errors.New(\"该链接已转链，短链接为：\" + u.Surl.String)\n    }\n    logx.Errorw(\"ShortUrlModel.FindOneBySurl error\", logx.Field(\"err\", err), logx.Field(\"basePath\", basePath))\n    return nil, err\n}\n\n// GetBasePath 获取 url 的 base path\nfunc GetBasePath(baseUrl string) (string, error) {\n    myUrl, err := url.Parse(baseUrl)\n\n    if err != nil {\n        return \"\", err\n    }\n\n    basePath := path.Base(myUrl.Path)\n    return basePath, nil\n}\n\n\n2.2、取号器实现\n每来一个转链请求，使用 replace into 语句往 sequence 表中插入一条数据，并取出 id 作为号码。\n我们在 model中增加新的方法，时间 replace 方法并返回最新的 id\n// Replace 实现 repalce into语句，返回最后插入数据的 id\nfunc (m *defaultSequenceModel) Replace(ctx context.Context, newData *Sequence) (int64, error) {\n    query := fmt.Sprintf(\"replace into %s (%s) values (?, ?)\", m.table, sequenceRowsExpectAutoSet)\n    ret, err := m.conn.ExecCtx(ctx, query, newData.Stub, newData.Timestamp)\n    if err != nil {\n        return 0, err\n    }\n    id, err := ret.LastInsertId()\n    if err != nil {\n        return 0, err\n    }\n    return id, nil\n}\n测试结果正常。\n\n\n\n\n2.3、62 进制转链\npackage base62\n\nimport (\n    \"math\"\n    \"strings\"\n)\n\n// 62进制转换\n// 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\n// 0-9：0-9\n// a-z：10-35\n// A-Z：36-61\n\n// 为了避免安全性，打乱顺序\nvar (\n    baseStr    string\n    baseStrLen uint64\n)\n\n// BaseInit 初始化\nfunc BaseInit(bs string) {\n    if len(bs) == 0 {\n        panic(\"baseStr is empty\")\n    }\n    baseStr = bs\n    baseStrLen = uint64(len(bs))\n}\n\n// Base62Encode 将数字转换为62进制\nfunc Base62Encode(num uint64) string {\n    if num == 0 {\n        return string(baseStr[0])\n    }\n    var res []byte\n    for num &gt; 0 {\n        res = append(res, baseStr[num%baseStrLen])\n        num /= baseStrLen\n    }\n\n    return string(reverse(res))\n}\n\n// Base62Decode 将62进制转换为数字\nfunc Base62Decode(str string) (seq uint64) {\n    bl := []byte(str)\n    bl = reverse(bl)\n\n    for idx, b := range bl {\n        base := math.Pow(float64(baseStrLen), float64(idx))\n        seq += uint64(strings.Index(baseStr, string(b))) * uint64(base)\n    }\n\n    return seq\n}\n\nfunc reverse(s []byte) []byte {\n    for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 {\n        s[i], s[j] = s[j], s[i]\n    }\n    return s\n}\n通过打乱全局 62 进制字符串简单保证安全性\n通过设置全局的短链接黑名单实现某些词汇的出现\n\n\n2.4、存储和测试\n结果存储到数据库中\n// 4.存储长链接和短链接的映射关系\n    if _, err := l.svcCtx.ShortUrlModel.Insert(l.ctx, &model.ShortUrlMap{\n        Lurl: sql.NullString{String: req.LongUrl, Valid: true},\n        Surl: sql.NullString{String: short, Valid: true},\n        Md5:  sql.NullString{String: md5Str, Valid: true},\n    }); err != nil {\n        logx.Errorw(\"ShortUrlModel.Insert error\", logx.Field(\"err\", err))\n        return nil, err\n    }\n\n    shortUrl := l.svcCtx.Config.ShortDoamin + \"/\" + short // shortUrl = 'http://localhost:8080/' short\n    resp = &types.ConvertResp{\n        ShortUrl: shortUrl,\n    }\n\n    return resp, nil\n\n\n\n\n\n3、查看短链接\n\n3.1、实现短链接重定向接口\n接收到短链接请求之后，重定向到真实的链接，同时进行测试\nfunc (l *ShowLogic) Show(req *types.ShowReq) (resp *types.ShowResp, err error) {\n    // 根据短链接查询长链接\n    u, err := l.svcCtx.ShortUrlModel.FindOneBySurl(l.ctx, sql.NullString{String: req.ShortUrl, Valid: true})\n    if err != nil {\n        if err == sql.ErrNoRows {\n            return nil, errors.New(\"404 Not Found\")\n        }\n        logx.Errorw(\"ShortUrlModel.FindOneBySurl error\", logx.Field(\"err\", err))\n        return nil, err\n    }\n    resp = &types.ShowResp{\n        LongUrl: u.Lurl.String,\n    }\n\n    // 返回查询到的长链接，在 handler 层进行重定向返回\n\n    return resp, nil\n}\n\n为了提升性能，加入 Redis 缓存，提升速度\n\n\n\n3.2、singleflight\n它提供了重复函数调用抑制机制，使用它可以避免同时进行相同的函数调用。第一个调用未完成时后续的重复调用会等待，当第一个调用完成时则会与它们分享结果，这样一来虽然只执行了一次函数调用但是所有调用都拿到了最终的调用结果。\ngo-zero框架默认使用 singleflight\n\n\n3.3、使用布隆过滤器\n防止出现缓存穿透的情况（短时间内大量不存在数据进行请求）\n\n通过布隆过滤器的机制，当所有对应位置全为 1 的时候表示可能存在，否则一定不存在。"
  },
  {
    "objectID": "content/projects/entries/GoLink.html#参考资料",
    "href": "content/projects/entries/GoLink.html#参考资料",
    "title": "GoLink",
    "section": "参考资料",
    "text": "参考资料\ngo-zero\ngo-zero官方文档\ngo的版本管理工具-g的安装和使用\n短 URL 系统是怎么设计的？\n实现一个短域名系统\nGolang URL Shortener\nshortme\nsingleflight\nTicket Servers: Distributed Unique Primary Keys on the Cheap\nURL Shortner System Design\nSystem Design : Scalable URL shortener service like TinyURL\nHow to Design a URL Shortener Service (System Design Interview Guide)"
  },
  {
    "objectID": "content/projects/entries/Gesture-Fireworks.html",
    "href": "content/projects/entries/Gesture-Fireworks.html",
    "title": "Gesture-Fireworks",
    "section": "",
    "text": "「用手点燃烟花」——Gesture Fireworks ✨"
  },
  {
    "objectID": "content/projects/entries/Gesture-Fireworks.html#项目地址",
    "href": "content/projects/entries/Gesture-Fireworks.html#项目地址",
    "title": "Gesture-Fireworks",
    "section": "项目地址",
    "text": "项目地址\n\n仓库地址：Gesture Fireworks（基于 MediaPipe 的手势烟花互动小工具）(GitHub)"
  },
  {
    "objectID": "content/projects/entries/Gesture-Fireworks.html#一这个小项目想解决什么",
    "href": "content/projects/entries/Gesture-Fireworks.html#一这个小项目想解决什么",
    "title": "Gesture-Fireworks",
    "section": "一、这个小项目想解决什么？",
    "text": "一、这个小项目想解决什么？\n每年跨年、春节、烟花节，我们总会刷到各种烟花视频，但要么太吵，要么不环保，要么……钱包受不了 😅\n于是我做了一个轻量又好玩的实验项目：Gesture Fireworks（手势烟花）。 它的核心目标是——让你只用一台带摄像头的电脑 + 浏览器，就能用手势在空中「放烟花」。\n你对着摄像头比一个 ✊、✌️ 或比心 ❤️，画面中就会在你的手边绽放对应的烟花效果。 不需要安装客户端，不需要复杂硬件，打开网页、授权摄像头，就能玩。"
  },
  {
    "objectID": "content/projects/entries/Gesture-Fireworks.html#二项目功能一览它到底能干嘛",
    "href": "content/projects/entries/Gesture-Fireworks.html#二项目功能一览它到底能干嘛",
    "title": "Gesture-Fireworks",
    "section": "二、项目功能一览：它到底能干嘛？",
    "text": "二、项目功能一览：它到底能干嘛？\n在目前的版本中，Gesture Fireworks 实现了这几类能力：\n\nAI 手势识别：基于 MediaPipe 的手势识别方案，支持多种不同手势\n绚丽烟花特效：精心设计了多种烟花，包括：\n\n爆炸烟花（FireworkBurst）\n圆环烟花（FireworkCircle）\n心形烟花（FireworkHeart）\n星形烟花（FireworkStar）\n螺旋烟花（FireworkSpiral）\n伞形烟花（FireworkUmbrella）\n等等\n\n多手同时触发：双手可以同时做不同手势，各自单独触发烟花，带有独立冷却机制\n高性能渲染：使用优化过的 Canvas 2D 粒子系统，可以同时渲染数千粒子而保持顺畅\n智能识别算法：多帧平滑、稳定帧判定、动态阈值、冷却机制，尽量减少误判抖动\n响应式页面：同时兼容桌面端 & 移动端"
  },
  {
    "objectID": "content/projects/entries/Gesture-Fireworks.html#三手势和烟花的绑定关系",
    "href": "content/projects/entries/Gesture-Fireworks.html#三手势和烟花的绑定关系",
    "title": "Gesture-Fireworks",
    "section": "三、手势和烟花的「绑定关系」",
    "text": "三、手势和烟花的「绑定关系」\n为了让体验更「直觉」，我为常见手势设计了不同的烟花风格：\n\n\n\n\n\n\n\n\n\n手势\n识别名\n对应烟花\n视觉风格\n\n\n\n\n✊ 拳头\nFIST\nFireworkBurst\n金黄色多层圆形爆炸，冲击感强\n\n\n👌 OK 手势\nOK\nFireworkCircle\n红橙系双环高密度爆裂\n\n\n❤️ 比心\nHEART\nFireworkHeart\n粉色系心形烟花，氛围感拉满\n\n\n👍 竖拇指\nTHUMBS_UP\nFireworkStar\n金白色五角星爆炸，闪烁明显\n\n\n✌️ 剪刀手\nPEACE\nFireworkSpiral\n紫色螺旋扩散，有旋转轨迹\n\n\n👉 指向\nPOINTING\nFireworkUmbrella\n蓝色伞形烟花，拖尾柔和\n\n\n✋ 张开手掌\nOPEN_PALM\nFireworkA\n随机色环形爆裂 + 拖尾，基础通用款\n\n\n\n技术上，在入口逻辑里会根据识别到的手势类型，映射到不同的触发器函数，并传入不同的参数（粒子数量、配色、持续时间等），让每种手势都有明显区别的手感和视觉反馈。"
  },
  {
    "objectID": "content/projects/entries/Gesture-Fireworks.html#四手势识别怎么尽量识别得准一点",
    "href": "content/projects/entries/Gesture-Fireworks.html#四手势识别怎么尽量识别得准一点",
    "title": "Gesture-Fireworks",
    "section": "四、手势识别：怎么尽量识别得「准一点」？",
    "text": "四、手势识别：怎么尽量识别得「准一点」？\n单纯做一个「能识别」的 Demo 很简单，但要做到「好玩、不烦人」，就必须控制误识别率和抖动。为此我做了几层处理逻辑：\n\n1. 多帧平滑 + 稳定帧判定\n\n使用固定长度的历史帧（例如 smoothingFrames = 10）做平滑\n只有连续若干帧（例如 stableFrames = 6）都稳定识别为同一手势时，才视为「真正识别到」\n\n这样可以过滤掉短暂的抖动或过渡帧，让触发更可控。\n\n\n2. 动态置信度阈值\n不同手势本身的易混淆程度不一样，所以采用了区分度更高的阈值设计：\n\n对于容易混的手势（拳头、OK、点赞、剪刀手、指向等），阈值设为 0.85\n对于张开手掌（OPEN_PALM），阈值略低一点 0.8\n\n同时，还会要求第一名和第二名手势的置信度差值 ≥ 0.12，避免「半斤八两」的两种手势乱跳。\n\n\n3. 冷却机制 + 上升沿触发\n\n每个识别器有一个默认冷却时间 cooldownMs = 350ms\n只有当「稳定手势从 A 变为 B」且不在冷却期内，才会触发一次烟花\n\n这意味着你可以保持一个手势不动，烟花不会无限制连发，更像是「一次明确的动作 → 一次清晰的反馈」。"
  },
  {
    "objectID": "content/projects/entries/Gesture-Fireworks.html#五渲染层canvas-粒子系统的设计思路",
    "href": "content/projects/entries/Gesture-Fireworks.html#五渲染层canvas-粒子系统的设计思路",
    "title": "Gesture-Fireworks",
    "section": "五、渲染层：Canvas 粒子系统的设计思路",
    "text": "五、渲染层：Canvas 粒子系统的设计思路\n视觉部分基于 Canvas 2D 实现了一个轻量的粒子系统：\n\n每个烟花本质上是大量粒子（位置、速度、加速度、颜色、透明度等属性）的集合\n每一帧进行：\n\n粒子位置更新（重力、阻尼、初速度方向等）\n透明度 & 尺寸衰减\n组合出光晕、拖尾、闪烁等效果\n\n\n为了保证性能，我做了几件事：\n\n批量更新 & 绘制，减少多余的状态切换\n针对不同烟花类型，限制最大粒子数量，避免堆爆内存\n在多发烟花场景下优先清理已经「看不见」的粒子\n\n在普通笔记本 + 现代浏览器环境下，同时存在数千个粒子仍可以保持比较流畅的体验。"
  },
  {
    "objectID": "content/projects/entries/Gesture-Fireworks.html#六项目结构-技术栈简述",
    "href": "content/projects/entries/Gesture-Fireworks.html#六项目结构-技术栈简述",
    "title": "Gesture-Fireworks",
    "section": "六、项目结构 & 技术栈简述",
    "text": "六、项目结构 & 技术栈简述\n项目整体是一个很标准的前端小应用形态：\n\n技术栈\n\nJavaScript 为主（约 97.7%）\n少量 HTML 结构\nMediaPipe 手势检测（通过 vendor 依赖引入）\n\n主要目录\n\nsrc/hand：手势识别与高级逻辑（置信度、稳定性、冷却等）\nsrc/main.js：应用主入口，负责：\n\n摄像头采集与视频流\n调用识别模块\n根据手势触发不同烟花\n\nsrc/fireworks/*：不同烟花特效的实现\n\n\n目的就是：保持结构清晰，方便以后扩展新的手势 & 新的烟花类型。"
  },
  {
    "objectID": "content/projects/entries/Gesture-Fireworks.html#七如何本地跑起来",
    "href": "content/projects/entries/Gesture-Fireworks.html#七如何本地跑起来",
    "title": "Gesture-Fireworks",
    "section": "七、如何本地跑起来？",
    "text": "七、如何本地跑起来？\n只要你对前端略有了解，就可以很快跑起来。\n\n1. 环境准备\n\n现代浏览器（Chrome 88+、Firefox 85+、Safari 14+、Edge 88+）\n一台带摄像头的设备\n本地 HTTP 服务器（用于获取摄像头权限）\n网络连接（首次加载 MediaPipe 模型）\n\n\n\n2. 启动步骤（示例）\n# 1. 克隆项目\ngit clone https://github.com/your-username/Gesture-fireworks.git\ncd Gesture-fireworks\n\n# 2. 启动本地服务器（Python 3 示例）\npython -m http.server 8000\n# 或者使用 Node.js\nnpx http-server -p 8000 -a localhost\n然后在浏览器中访问：\nhttp://localhost:8000"
  },
  {
    "objectID": "content/projects/entries/Gesture-Fireworks.html#浏览器会弹出摄像头授权请求点击允许即可开始体验",
    "href": "content/projects/entries/Gesture-Fireworks.html#浏览器会弹出摄像头授权请求点击允许即可开始体验",
    "title": "Gesture-Fireworks",
    "section": "浏览器会弹出摄像头授权请求，点击「允许」即可开始体验。",
    "text": "浏览器会弹出摄像头授权请求，点击「允许」即可开始体验。"
  },
  {
    "objectID": "content/projects/entries/Gesture-Fireworks.html#八实际体验怎么玩得更爽",
    "href": "content/projects/entries/Gesture-Fireworks.html#八实际体验怎么玩得更爽",
    "title": "Gesture-Fireworks",
    "section": "八、实际体验：怎么玩得更爽？",
    "text": "八、实际体验：怎么玩得更爽？\n结合调试过程，总结了一些实用的小技巧：\n\n光线充足：正面光最好，避免背光和强阴影\n距离合适：人与摄像头保持 1–2 米，手部占画面约 1/4 效果最佳\n手势清晰稳定：\n\n比完手势后保持 1–2 秒\n手指要伸直 / 收紧到位，避免半吊子动作\n\n居中一点：手尽量在画面中央区域，边缘区域容易畸变、识别不准\n多手玩法：双手分别做不同手势，可以点亮「组合烟花」，非常适合多人一起玩\n\n\n如果你对这个项目有兴趣，欢迎来仓库看看源码、提 Issue 或一起玩"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/微服务框架(golang).html",
    "href": "content/learning-notes/microservices/entries/微服务框架(golang).html",
    "title": "微服务框架(golang)",
    "section": "",
    "text": "框架，英文名称framework，可以看作一种脚手架或者是一种标准化模版\n框架中该有的组件都已经设定好，方便干活，减少重复工作，同时项目的风格和目录一致，看起来也更加方便\n在公司中使用统一的框架，接手起来更加方便，维护起来也更加方便，如果使用同一个框架，发现了漏洞，更新一个框架即可。同时很多业务中存在重复代码，像是日志、监控系统，使用统一框架，负责开发的程序员不需要考虑其他，只管自己业务代码的开发，这样自己写的代码量减少，不容易出现问题。\n在开发的主流语言中，Java应用是最广泛的，它有一个统一的框架Spring，全世界都在用，很多问题前辈可能都遇到过，相应的技术博客也比较完善，这是它独特的优势。"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/微服务框架(golang).html#框架是什么",
    "href": "content/learning-notes/microservices/entries/微服务框架(golang).html#框架是什么",
    "title": "微服务框架(golang)",
    "section": "",
    "text": "框架，英文名称framework，可以看作一种脚手架或者是一种标准化模版\n框架中该有的组件都已经设定好，方便干活，减少重复工作，同时项目的风格和目录一致，看起来也更加方便\n在公司中使用统一的框架，接手起来更加方便，维护起来也更加方便，如果使用同一个框架，发现了漏洞，更新一个框架即可。同时很多业务中存在重复代码，像是日志、监控系统，使用统一框架，负责开发的程序员不需要考虑其他，只管自己业务代码的开发，这样自己写的代码量减少，不容易出现问题。\n在开发的主流语言中，Java应用是最广泛的，它有一个统一的框架Spring，全世界都在用，很多问题前辈可能都遇到过，相应的技术博客也比较完善，这是它独特的优势。"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/微服务框架(golang).html#golang开发常用的框架",
    "href": "content/learning-notes/microservices/entries/微服务框架(golang).html#golang开发常用的框架",
    "title": "微服务框架(golang)",
    "section": "golang开发常用的框架",
    "text": "golang开发常用的框架\ngolang是一门比较新的语言，2009年正式发布，作为一门新兴的语言，没有像Java一样形成一个大一统的框架，很多大厂都有自己的框架，还有一些开源团队维护自己的框架。\n这样在大厂中会有一些岗位是做基础架构的，专门为公司开发新的适用于公司业务的框架，开发框架也并不简单，需要根据自己公司的业务需求进行开发，还要考虑跟公司其他业务的连通性，公司内部私有协议的适配性，还有框架的使用友好性、稳定性、安全性等等。\n我们在学习的时候更多的是要学习框架实现的思想，不要只单纯学怎么使用，要学会自己造轮子-&gt;造汽车。"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/微服务框架(golang).html#微服务框架基本组件",
    "href": "content/learning-notes/microservices/entries/微服务框架(golang).html#微服务框架基本组件",
    "title": "微服务框架(golang)",
    "section": "微服务框架基本组件",
    "text": "微服务框架基本组件\n\n日志（一个框架能支持不同的日志配置）\n配置中心（在配置中心进行微服务配置的设定，不用一个个单独设置）\n数据库（支持数据库的交互）\n消息队列（各种消息队列，Kafka、RabbitMQ等）\nmetrics（指标监控）\ntracing（链路追踪，单个请求完整的生命周期，找出性能瓶颈之类的）\n服务注册发现\n依赖注入\nRPC框架（远程过程调用，微服务之间数据的交互处理）\n熔断和限流（维持微服务的运行，防止崩溃）\n……"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/微服务框架(golang).html#开源社区常用的框架",
    "href": "content/learning-notes/microservices/entries/微服务框架(golang).html#开源社区常用的框架",
    "title": "微服务框架(golang)",
    "section": "开源社区常用的框架",
    "text": "开源社区常用的框架\n\nGo-kit\n\ngo微服务套件库，简单的组件库，能用来实现微服务项目\n\nGo-micro\n\n比较早的go微服务框架，可能不兼容新的更新\n\nGo-kratos\n\nB站开源的框架，可以自己选择组件，也可以使用自己的\n\nKitex\n\n字节开源，自定义netpoll，对使用者要求比较高，性能高\n\nGo-zero\n\n好未来开源的，一站式微服务框架（之前吃饭路过好未来，下班好像挺早的）"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/微服务框架(golang).html#参考资料",
    "href": "content/learning-notes/microservices/entries/微服务框架(golang).html#参考资料",
    "title": "微服务框架(golang)",
    "section": "参考资料",
    "text": "参考资料\n\nGo-kit\nGo-micro\nGo-kratos\nKitex\nGo-zero"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-zero.html#简介",
    "href": "content/learning-notes/microservices/entries/go-zero.html#简介",
    "title": "Go-Zero 微服务框架",
    "section": "简介",
    "text": "简介\ngo-zero是一个集成了各种工程实践的 web 和 rpc 框架。通过弹性设计保障了大并发服务端的稳定性，经受了充分的实战检验。\ngo-zero 包含极简的 API 定义和生成工具 goctl，可以根据定义的 api 文件一键生成 Go, iOS, Android, Kotlin, Dart, TypeScript, JavaScript 代码，并可直接运行。\ngo-zero框架能轻松获得支撑千万日活服务的稳定性，内建级联超时控制、限流、自适应熔断、自适应降载等微服务治理能力，无需配置和额外代码，微服务治理中间件可无缝集成到其它现有框架使用，极简的 API 描述，一键生成各端代码，自动校验客户端请求参数合法性，大量微服务治理和并发工具包。\ngo-zero框架具有强大的工具支持，尽可能少的代码编写，极简的接口，完全兼容 net/http，支持中间件，方便扩展，高性能，面向故障编程，弹性设计，内建服务发现、负载均衡，内建限流、熔断、降载，且自动触发，自动恢复，API 参数自动校验，超时级联控制，自动缓存控制，链路跟踪、统计报警等，高并发支撑，稳定保障了疫情期间每天的流量洪峰。\n下面是官方给的架构图"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-zero.html#安装和快速使用",
    "href": "content/learning-notes/microservices/entries/go-zero.html#安装和快速使用",
    "title": "Go-Zero 微服务框架",
    "section": "安装和快速使用",
    "text": "安装和快速使用\n\n安装\n这里主要是go-zero、goctl和go-zero的安装指令，可以参照官方的文档：快速开始\n注意先安装go，关于go的安装和配置可以见博客：g的安装和使用\n# go-zero安装\ngo get -u github.com/zeromicro/go-zero@latest\n# goctl安装\ngo install github.com/zeromicro/go-zero/tools/goctl@latest\n# protoc安装\ngoctl env check --install --verbose --force\n\n\n\n快速使用\n\nApi demo\n在这里我创建了一个文件夹GoZeroDemo存放go-zero微服务框架学习期间的相关代码，之后初始化项目，并使用gpctl自动生成简单API相关文件\n# 创建并进入项目\nmkdir GoZeroDemo && cd GoZeroDemo\n# 初始化项目并命名\ngo mod init gozerodemo\n# 使用goctl创建API服务\ngoctl api new greet\n# 安装缺失的依赖\ngo mod tidy\n下面是生成的代码框架，包括配置文件、main文件、配置定义文件、网络路由相关文件、请求逻辑文件、业务逻辑相关文件以及业务相关结构体文件等等。\n\n之后我们根据官方说明，在greetlogic.go中实现Greet，做简单的 Say Hello，测试效果如下，一个简单的单体服务就构建完成了。\n\n通过简单的使用go-zero我们可以发现，框架的作用就是帮你生成配套代码，你只需要完成相应的业务逻辑。\n\n\ngRPC demo\n继续在GoZeroDemo目录下创建gRPC服务aorange\n# 使用goctl创建RPC服务\ngoctl rpc new aorange\n# 安装缺失的依赖\ngo mod tidy\n\n之后按照文档进行简单修改测试：gRPC-demo\n\n\n\nMySQL\n创建sql文件，之后通过goctl生成对应的golang文件和操作方法，具体参考：mysql代码生成\ngoctl model mysql ddl --src user.sql --dir .\n\n\n\nMongo\nmongo 不像 mysql 一样有建表语句，索引等集中有规律的约束信息，因此 mongo 代码的生成无需类似 sql 或者数据库链接一样的信息。，具体参考：mongo代码生成\ngoctl model mongo --type user --dir .\n\n\n\nformat\n还可以通过goctl进行格式化，具体见：api文件格式化\ngoctl api format --dir demo.api"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-zero.html#goctl",
    "href": "content/learning-notes/microservices/entries/go-zero.html#goctl",
    "title": "Go-Zero 微服务框架",
    "section": "Goctl",
    "text": "Goctl\n下面是goctl相关的指令和说明，我们常用的就是api和rpc\n\n\nApi\n\n参考官方给的api示例，我们使用goctl通过api文件创建服务\n首先创建项目文件夹添加user.api\n之后在终端输入指令\ngoctl api go -api user.api -dir . -style goZero\nsyntax = \"v1\"\n\ntype (\n        // 定义登录接口的 json 请求体\n        LoginReq {\n                Username string `json:\"username\"`\n                Password string `json:\"password\"`\n        }\n        // 定义登录接口的 json 响应体\n        LoginResp {\n                Id       int64  `json:\"id\"`\n                Name     string `json:\"name\"`\n                Token    string `json:\"token\"`\n                ExpireAt string `json:\"expireAt\"`\n        }\n)\n\ntype (\n        // 定义获取用户信息的 json 请求体\n        GetUserInfoReq {\n                Id int64 `json:\"id\"`\n        }\n        // 定义获取用户信息的 json 响应体\n        GetUserInfoResp {\n                Id   int64  `json:\"id\"`\n                Name string `json:\"name\"`\n                Desc string `json:\"desc\"`\n        }\n        // 定义更新用户信息的 json 请求体\n        UpdateUserInfoReq {\n                Id   int64  `json:\"id\"`\n                Name string `json:\"name\"`\n                Desc string `json:\"desc\"`\n        }\n)\n\n// 定义 HTTP 服务\n// @server 语法块主要用于控制对 HTTP 服务生成时 meta 信息，目前支持功能有：\n// 1. 路由分组\n// 2. 中间件声明\n// 3. 路由前缀\n// 4. 超时配置\n// 5. jwt 鉴权开关\n// 所有声明仅对当前 service 中的路由有效\n@server (\n        // 代表当前 service 代码块下的路由生成代码时都会被放到 login 目录下\n        group: login\n        // 定义路由前缀为 \"/v1\"\n        prefix: /v1\n)\n// 微服务名称为 user，生成的代码目录和配置文件将和 user 值相关\nservice user {\n        // 定义 http.HandleFunc 转换的 go 文件名称及方法，每个接口都会跟一个 handler\n        @handler login\n        // 定义接口\n        // 请求方法为 post\n        // 路由为 /user/login\n        // 请求体为 LoginReq\n        // 响应体为 LoginResp，响应体必须有 returns 关键字修饰\n        post /user/login (LoginReq) returns (LoginResp)\n}\n\n// @server 语法块主要用于控制对 HTTP 服务生成时 meta 信息，目前支持功能有：\n// 1. 路由分组\n// 2. 中间件声明\n// 3. 路由前缀\n// 4. 超时配置\n// 5. jwt 鉴权开关\n// 所有声明仅对当前 service 中的路由有效\n@server (\n        // 代表当前 service 代码块下的所有路由均需要 jwt 鉴权\n        // goctl 生成代码时会将当前 service 代码块下的接口\n        // 信息添加上 jwt 相关代码，Auth 值为 jwt 密钥，过期\n        // 等信息配置的 golang 结构体名称\n        jwt: Auth\n        // 代表当前 service 代码块下的路由生成代码时都会被放到 user 目录下\n        group: user\n        // 定义路由前缀为 \"/v1\"\n        prefix: /v1\n)\n// 注意，定义多个 service 代码块时，服务名称必须一致，因此这里的服务名称必须\n// 和上文的 service 名称一样，为 user 服务。\nservice user {\n        // 定义 http.HandleFunc 转换的 go 文件名称及方法，每个接口都会跟一个 handler\n        @handler getUserInfo\n        // 定义接口\n        // 请求方法为 post\n        // 路由为 /user/info\n        // 请求体为 GetUserInfoReq\n        // 响应体为 GetUserInfoResp，响应体必须有 returns 关键字修饰\n        post /user/info (GetUserInfoReq) returns (GetUserInfoResp)\n\n        // 定义 http.HandleFunc 转换的 go 文件名称及方法，每个接口都会跟一个 handler\n        @handler updateUserInfo\n        // 定义接口\n        // 请求方法为 post\n        // 路由为 /user/info/update\n        // 请求体为 UpdateUserInfoReq\n        // 由于不需要响应体，因此可以忽略不写\n        post /user/info/update (UpdateUserInfoReq)\n}\n\n\n\nRPC\n\nrpc采用同样的方式\n相关指令和代码如下：\ngoctl rpc protoc user.proto --go_out=. --go-grpc_out=. --zrpc_out=.\n// 声明 proto 语法版本，固定值\nsyntax = \"proto3\";\n\n// proto 包名\npackage greet;\n\n// 生成 golang 代码后的包名\noption go_package = \"example/proto/greet\";\n\n// 定义枚举\n\nenum Status{\n  UNSPECIFIED = 0;\n  SUCCESS = 1;\n  FAILED = 2;\n}\n\n// 定义结构体\n\nmessage Base{\n  int32 code = 1;\n  string msg = 2;\n}\n\nmessage SendMessageReq{\n  string message = 1;\n}\n\nmessage SendMessage{\n  // 使用枚举\n  Status status = 1;\n  // 数组\n  repeated string array = 2;\n  // map\n  map&lt;string,int32&gt; map = 3;\n  // 布尔类型\n  bool boolean = 4;\n  // 序列号保留\n  reserved 5;\n}\n\nmessage SendMessageResp{\n  Base base = 1;\n  SendMessage data = 2;\n}\n\n// 定义 Greet 服务\nservice Greet {\n  // 定义客户端流式 rpc\n  rpc SendMessage(stream SendMessageReq) returns (SendMessageResp);\n}\n\n\n\nModel\n\n以SQL为例，创建sql文件，通过下面指令生成相关代码\ngoctl model mysql ddl -src\"./user.sql\" -dir=\"./sql/model\" -c"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-zero.html#参考资料",
    "href": "content/learning-notes/microservices/entries/go-zero.html#参考资料",
    "title": "Go-Zero 微服务框架",
    "section": "参考资料",
    "text": "参考资料\ngo-zero\ngo-zero官方文档\ngo的版本管理工具-g的安装和使用"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/api语言.html",
    "href": "content/learning-notes/microservices/entries/api语言.html",
    "title": "go-zero的API语言",
    "section": "",
    "text": "api 是 go-zero 自研的领域特性语言，旨在实现人性化的基础描述原因，作为生成 HTTP 服务最基本的描述语言。可以通过官方提供的 goctl 工具实现 api 向结构化项目的转换。"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/api语言.html#概述",
    "href": "content/learning-notes/microservices/entries/api语言.html#概述",
    "title": "go-zero的API语言",
    "section": "概述",
    "text": "概述\napi 领域特性语言包含语法版本，info 块，结构体声明，服务描述等几大块语法组成，其中结构体和 Golang 结构体语法几乎一样，只是移除了 struct 关键字。"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/api语言.html#syntax-语句",
    "href": "content/learning-notes/microservices/entries/api语言.html#syntax-语句",
    "title": "go-zero的API语言",
    "section": "syntax 语句",
    "text": "syntax 语句\nsyntax 语句用于标记 api 语言的版本，不同的版本可能语法结构有所不同，随着版本的提升会做不断的优化，当前版本为 v1。\nsyntax = \"v1\""
  },
  {
    "objectID": "content/learning-notes/microservices/entries/api语言.html#info-语句",
    "href": "content/learning-notes/microservices/entries/api语言.html#info-语句",
    "title": "go-zero的API语言",
    "section": "info 语句",
    "text": "info 语句\ninfo 语句是 api 语言的 meta 信息，其仅用于对当前 api 文件进行描述，暂不参与代码生成，其和注释还是有一些区别，注释一般是依附某个 syntax 语句存在，而 info 语句是用于描述整个 api 信息的。\n// 不包含 key-value 的 info 块\ninfo ()\n\n// 包含 key-value 的 info 块\ninfo (\n    foo: \"bar\"\n    bar:\n)"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/api语言.html#import语句",
    "href": "content/learning-notes/microservices/entries/api语言.html#import语句",
    "title": "go-zero的API语言",
    "section": "import语句",
    "text": "import语句\nimport 语句是在 api 中引入其他 api 文件的语法块，其支持相对路径和绝对路径，不支持 package 设计。\n// 单行 import\nimport \"foo\"\nimport \"/path/to/file\"\n\n// import 组\nimport ()\nimport (\n    \"bar\"\n    \"relative/to/file\"\n)"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/api语言.html#数据类型",
    "href": "content/learning-notes/microservices/entries/api语言.html#数据类型",
    "title": "go-zero的API语言",
    "section": "数据类型",
    "text": "数据类型\napi 中的数据类型基本沿用了 Golang 的数据类型，用于对 rest 服务的请求/响应体结构的描述，不支持 package 如 time.Time。\n// 空结构体\ntype Foo {}\n\n// 单个结构体\ntype Bar {\n    Foo int               `json:\"foo\"`\n    Bar bool              `json:\"bar\"`\n    Baz []string          `json:\"baz\"`\n    Qux map[string]string `json:\"qux\"`\n}\n\ntype Baz {\n    Bar    `json:\"baz\"`\n    Array [3]int `json:\"array\"`\n    // 结构体内嵌 goctl 1.6.8 版本支持\n    Qux {\n        Foo string `json:\"foo\"`\n        Bar bool   `json:\"bar\"`\n    } `json:\"baz\"`\n}\n\n// 空结构体组\ntype ()\n\n// 结构体组\ntype (\n    Int int\n    Integer = int\n    Bar {\n        Foo int               `json:\"foo\"`\n        Bar bool              `json:\"bar\"`\n        Baz []string          `json:\"baz\"`\n        Qux map[string]string `json:\"qux\"`\n    }\n)"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/api语言.html#service语句-service",
    "href": "content/learning-notes/microservices/entries/api语言.html#service语句-service",
    "title": "go-zero的API语言",
    "section": "service语句-@service",
    "text": "service语句-@service\nservice 语句是对 HTTP 服务的直观描述，包含请求 handler，请求方法，请求路由，请求体，响应体，jwt 开关，中间件声明等定义。\n// 空内容\n@server()\n\n// 有内容\n@server (\n    // jwt 声明\n    // 如果 key 固定为 “jwt:”，则代表开启 jwt 鉴权声明\n    // value 则为配置文件的结构体名称\n    jwt: Auth\n\n    // 路由前缀\n    // 如果 key 固定为 “prefix:”\n    // 则代表路由前缀声明，value 则为具体的路由前缀值，字符串中没让必须以 / 开头\n    prefix: /v1\n\n    // 路由分组\n    // 如果 key 固定为 “group:”，则代表路由分组声明\n    // value 则为具体分组名称，在 goctl生成代码后会根据此值进行文件夹分组\n    group: Foo\n\n    // 中间件\n    // 如果 key 固定为 middleware:”，则代表中间件声明\n    // value 则为具体中间件函数名称，在 goctl生成代码后会根据此值进生成对应的中间件函数\n    middleware: AuthInterceptor\n\n    // 超时控制\n    // 如果 key 固定为  timeout:”，则代表超时配置\n    // value 则为具体中duration，在 goctl生成代码后会根据此值进生成对应的超时配置\n    timeout: 3s\n\n    // 其他 key-value，除上述几个内置 key 外，其他 key-value\n    // 也可以在作为 annotation 信息传递给 goctl 及其插件，但就\n    // 目前来看，goctl 并未使用。\n    foo: bar\n)"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/api语言.html#服务条目",
    "href": "content/learning-notes/microservices/entries/api语言.html#服务条目",
    "title": "go-zero的API语言",
    "section": "服务条目",
    "text": "服务条目\n服务条目（ServiceItemStmt）是对单个 HTTP 请求的描述，包括 @doc 语句，@handler 语句，路由语句信息。\n\n@doc 语句\n@doc 语句是对单个路由的 meta 信息描述，一般为 key-value 值，可以传递给 goctl 及其插件来进行扩展生成。\n// 单行 @doc\n@doc \"foo\"\n\n// 空 @doc 组\n@doc ()\n\n// 有内容的 @doc 组\n@doc (\n    foo: \"bar\"\n    bar: \"baz\"\n)\n\n\n@handler 语句\n@handler 语句是对单个路由的 handler 信息控制，主要用于生成 golang http.HandleFunc 的实现转换方法。\n@handler foo\n\n\n路由语句\n路由语句是对单此 HTTP 请求的具体描述，包括请求方法，请求路径，请求体，响应体信息。\n// 没有请求体和响应体的写法\nget /ping\n\n// 只有请求体的写法\nget /foo (foo)\n\n// 只有响应体的写法\npost /foo returns (foo)\n\n// 有请求体和响应体的写法\npost /foo (foo) returns (bar)\n\n\n一个完整service\n// 带 @server 的写法\n@server (\n    prefix: /v1\n    group: Login\n)\nservice user {\n    @doc \"登录\"\n    @handler login\n    post /user/login (LoginReq) returns (LoginResp)\n\n    @handler getUserInfo\n    get /user/info/:id (GetUserInfoReq) returns (GetUserInfoResp)\n}\n@server (\n    prefix: /v1\n    middleware: AuthInterceptor\n)\nservice user {\n    @doc \"登录\"\n    @handler login\n    post /user/login (LoginReq) returns (LoginResp)\n\n    @handler getUserInfo\n    get /user/info/:id (GetUserInfoReq) returns (GetUserInfoResp)\n}\n\n\n// 不带 @server 的写法\nservice user {\n    @doc \"登录\"\n    @handler login\n    post /user/login (LoginReq) returns (LoginResp)\n\n    @handler getUserInfo\n    get /user/info/:id (GetUserInfoReq) returns (GetUserInfoResp)\n}"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/api语言.html#完整示例",
    "href": "content/learning-notes/microservices/entries/api语言.html#完整示例",
    "title": "go-zero的API语言",
    "section": "完整示例",
    "text": "完整示例\nsyntax = \"v1\"\n\ninfo (\n    title:   \"api 文件完整示例写法\"\n    desc:    \"演示如何编写 api 文件\"\n    author:  \"keson.an\"\n    date:    \"2022 年 12 月 26 日\"\n    version: \"v1\"\n)\n\ntype UpdateReq {\n    Arg1 string `json:\"arg1\"`\n}\n\ntype ListItem {\n    Value1 string `json:\"value1\"`\n}\n\ntype LoginReq {\n    Username string `json:\"username\"`\n    Password string `json:\"password\"`\n}\n\ntype LoginResp {\n    Name string `json:\"name\"`\n}\n\ntype FormExampleReq {\n    Name string `form:\"name\"`\n}\n\ntype PathExampleReq {\n    // path 标签修饰的 id 必须与请求路由中的片段对应，如\n    // id 在 service 语法块的请求路径上一定会有 :id 对应，见下文。\n    ID string `path:\"id\"`\n}\n\ntype PathExampleResp {\n    Name string `json:\"name\"`\n}\n\n@server (\n    jwt:        Auth // 对当前 Foo 语法块下的所有路由，开启 jwt 认证，不需要则请删除此行\n    prefix:     /v1 // 对当前 Foo 语法块下的所有路由，新增 /v1 路由前缀，不需要则请删除此行\n    group:      g1 // 对当前 Foo 语法块下的所有路由，路由归并到 g1 目录下，不需要则请删除此行\n    timeout:    3s // 对当前 Foo 语法块下的所有路由进行超时配置，不需要则请删除此行\n    middleware: AuthInterceptor // 对当前 Foo 语法块下的所有路由添加中间件，不需要则请删除此行\n    maxBytes:   1048576 // 对当前 Foo 语法块下的所有路由添加请求体大小控制，单位为 byte,goctl 版本 &gt;= 1.5.0 才支持\n)\nservice Foo {\n    // 定义没有请求体和响应体的接口，如 ping\n    @handler ping\n    get /ping\n\n    // 定义只有请求体的接口，如更新信息\n    @handler update\n    post /update (UpdateReq)\n\n    // 定义只有响应体的结构，如获取全部信息列表\n    @handler list\n    get /list returns ([]ListItem)\n\n    // 定义有结构体和响应体的接口，如登录\n    @handler login\n    post /login (LoginReq) returns (LoginResp)\n\n    // 定义表单请求\n    @handler formExample\n    post /form/example (FormExampleReq)\n\n    // 定义 path 参数\n    @handler pathExample\n    get /path/example/:id (PathExampleReq) returns (PathExampleResp)\n}"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/api语言.html#参考资料",
    "href": "content/learning-notes/microservices/entries/api语言.html#参考资料",
    "title": "go-zero的API语言",
    "section": "参考资料",
    "text": "参考资料\nAPI 规范\nAPI 定义完整示例"
  },
  {
    "objectID": "content/learning-notes/golang/entries/go的版本管理工具-g的安装和使用.html",
    "href": "content/learning-notes/golang/entries/go的版本管理工具-g的安装和使用.html",
    "title": "go的版本管理工具-g的安装和使用",
    "section": "",
    "text": "最近在进行go的实践，要做go的项目，运行一些项目的时候可能要用到不同的go环境，想到go有没有和python一样的环境管理工具（做实验还是用python比较多），然后查了一下，还是有的，比如gvm、g等等，最终选择了g，感觉找到的博客不够“保姆”就自己写一遍，进行记录，供小白参考。\n\n\n\n\n\n我是用的操作系统是Windows11，安装的话使用的已经编译好的版本\ng的下载地址–&gt;点击跳转\n我选择得是当前最新的1.7.0版本，也可以选择其他版本–&gt;点击跳转\n因为是用的64位Windows操作系统，选择g1.7.0.windows-amd64,然后解压\n\n下载完成后可以解压这个压缩包，里面已有一个名字叫g的应用程序，这个就是我们要用的版本管理工具，已经编译好了\n\n\n\n\ng的使用过程中，最难的一步就是环境变量的配置\n如果在使用g之前已经安装过go，配置过环境变量，需要删相关的环境变量，不然可能会有冲突\n然后，我们开始自己的环境变量的配置 |环境变量名称 |路径 |说明| |——-|——-|——-| |G_HOME | C:.g | 这个是用于下载go安装包个安装go的目录| |GOPATH | %G_HOME%| 这个是g中配置的要使用的go版本的目录| |Path | D:-env | 这个是g.exe所在的目录| |Path | %GOROOT%| 这个是go.exe所在的目录|\n\n\n大家可以根据自己的需要进行修改：\n\n将lier改成自己的用户名 将g.exe放到自己设置的目录下\n\n\n\n\n\n\n\n可以在cmd或者power shell中使用\n打开一个新的cmd，输入g –version，查看结果\n\n\n\n\n\n\n\n查询当前可供安装的stable状态的 go 版本\n\n\n\n\n\n查询可供安装的所有 go 版本\n\n\n\n\n\n安装目标 go 版本\n\n\n\n\n\n查询已安装的 go 版本\n\n\n\n\n\n切换到另一个已安装的 go 版本\n\n\n\n\n\n卸载一个已安装的 go 版本\n\n\n\n\n\n清空 go 安装包文件缓存\n\n\n\n\n\n查看 g 版本信息\n\n\n\n\n\n更新 g 软件本身，要1.5.0及以上版本才能更新\n\n\n\n\n\n卸载 g 软件本身\n\n\n\n\n\n\n\n通过上面的步骤基本就可以顺利安装并使用g进行go的版本管理\n\n\n谢谢阅读！！！"
  },
  {
    "objectID": "content/learning-notes/golang/entries/go的版本管理工具-g的安装和使用.html#step1-g的下载和安装",
    "href": "content/learning-notes/golang/entries/go的版本管理工具-g的安装和使用.html#step1-g的下载和安装",
    "title": "go的版本管理工具-g的安装和使用",
    "section": "",
    "text": "我是用的操作系统是Windows11，安装的话使用的已经编译好的版本\ng的下载地址–&gt;点击跳转\n我选择得是当前最新的1.7.0版本，也可以选择其他版本–&gt;点击跳转\n因为是用的64位Windows操作系统，选择g1.7.0.windows-amd64,然后解压\n\n下载完成后可以解压这个压缩包，里面已有一个名字叫g的应用程序，这个就是我们要用的版本管理工具，已经编译好了\n\n\n\n\ng的使用过程中，最难的一步就是环境变量的配置\n如果在使用g之前已经安装过go，配置过环境变量，需要删相关的环境变量，不然可能会有冲突\n然后，我们开始自己的环境变量的配置 |环境变量名称 |路径 |说明| |——-|——-|——-| |G_HOME | C:.g | 这个是用于下载go安装包个安装go的目录| |GOPATH | %G_HOME%| 这个是g中配置的要使用的go版本的目录| |Path | D:-env | 这个是g.exe所在的目录| |Path | %GOROOT%| 这个是go.exe所在的目录|\n\n\n大家可以根据自己的需要进行修改：\n\n将lier改成自己的用户名 将g.exe放到自己设置的目录下"
  },
  {
    "objectID": "content/learning-notes/golang/entries/go的版本管理工具-g的安装和使用.html#step2-g的使用",
    "href": "content/learning-notes/golang/entries/go的版本管理工具-g的安装和使用.html#step2-g的使用",
    "title": "go的版本管理工具-g的安装和使用",
    "section": "",
    "text": "可以在cmd或者power shell中使用\n打开一个新的cmd，输入g –version，查看结果\n\n\n\n\n\n\n\n查询当前可供安装的stable状态的 go 版本\n\n\n\n\n\n查询可供安装的所有 go 版本\n\n\n\n\n\n安装目标 go 版本\n\n\n\n\n\n查询已安装的 go 版本\n\n\n\n\n\n切换到另一个已安装的 go 版本\n\n\n\n\n\n卸载一个已安装的 go 版本\n\n\n\n\n\n清空 go 安装包文件缓存\n\n\n\n\n\n查看 g 版本信息\n\n\n\n\n\n更新 g 软件本身，要1.5.0及以上版本才能更新\n\n\n\n\n\n卸载 g 软件本身"
  },
  {
    "objectID": "content/learning-notes/golang/entries/go的版本管理工具-g的安装和使用.html#总结",
    "href": "content/learning-notes/golang/entries/go的版本管理工具-g的安装和使用.html#总结",
    "title": "go的版本管理工具-g的安装和使用",
    "section": "",
    "text": "通过上面的步骤基本就可以顺利安装并使用g进行go的版本管理\n\n\n谢谢阅读！！！"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（8）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（8）.html",
    "title": "golang学习记录（8）",
    "section": "",
    "text": "go语言中的函数支持普通函数、匿名函数、闭包函数、方法等\n在go语言中函数是一等公民，函数可以作为参数、函数可以作为返回值、函数可以赋值给变量、函数可以作为闭包函数等\n函数可以满足接口\n\n\n\n函数的基本定义方式如下：\nfunc 函数名(参数列表) (返回值列表) {\n    函数体\n}\n\n参数列表：参数列表可以为空，也可以有多个参数，多个参数之间用逗号分隔\n返回值列表：返回值列表可以为空，也可以有多个返回值，多个返回值之间用逗号分隔，返回值列表不为空时，函数中必须有return\n\n举个简单的例子：\nfunc add(a, b int, c float32) (int, error) {\n    return a + b, nil\n}\n\n在go语言中参数的传递时值传递，即传递的是值的副本，而不是值的引用，因此在函数中修改参数的值不会影响到原变量的值\n但是关于切片的传递，由于切片的底层原理，在函数中修改切片的值会影响到原切片的值，因此在go语言中切片的传递需要注意。\n当且切片发生扩容时，会返回一个新的切片，此时在函数中修改切片的值不会影响到原切片的值\n\n除了上面讲到的函数定义的方法，还可以在返回列表中执行返回参数的名称（相当于定义一个参数名称），这个参数在函数体中不需要再进行定义\n下面是一个例子\nfunc add(a, b int) (sum int, err error) {\n    sum = a + b\n    return sum, err\n    //也可以直接写return\n}\n\n\n\n\n函数在进行参数传递的时候没可能不知道要传多少个值，因此go语言中函数的参数列表中可以使用可变参数\n\n可变参数的基本定义方式如下：\nfunc 函数名(参数列表...类型) (返回值列表) {\n    函数体\n}\n举一个简单的例子：\nfunc add(a ...int)(sum int, err error) {\n    for _, value := range a {\n        sum += value\n    }\n}\nc := 1\nd := 2\nsum, _ := add(a, b, 3, 4)\nfmt.Println(sum)\n\n其中a是一个int类型的切片，在函数中可以使用a[0]、a[1]等方式访问切片中的元，也可以通过for循环进行访问\n\n\n\n\n\n函数的一等公民特性，能够当作参数进行传递、作为返回值进行返回、赋值给变量等操作\n大大提升了函数的灵活性和复用性\n\n\n\n举个例子：\nfunc add(a ...int)(sum int, err error) {\n    for _, value := range a {\n        sum += value\n    }\n}\n\nfunc main(){\n    //这里将add函数作为参数赋值给变量funcVar\n    funcVar := add\n    c := 1\n    d := 2\n    sum, _ := funcVar(a, b, 3, 4)\n    fmt.Println(sum)\n}\n\n\n\n举个例子：\nfunc cal(op string) func(){\n    switch op {\n    case \"+\":\n        return func(){\n            fmt.Println(\"这是加法\")\n        }\n\n    case \"-\":\n        return func(){\n            fmt.Println(\"这是减法\")\n        }\n    default:\n        return func(){\n            fmt.Println(\"这不是加法也不是减法\")\n        }\n    }\n}\n\n//因为返回的是函数，所以在调用的时候需要加上()\ncal(\"+\")()\n\n\n\n举个例子（没啥意义，只是说明用法）：\nfunc add(a, b int) int{\n    fmt.Printf(\"sum is %d\\n\", a + b)\n}\nfunc cal(y int, myfunc func(int, int)) {\n    myfunc(y, 2)\n}\n\ncal(1, add)\n\n//输出结果为sum is 3\n//调用cal函数传递add函数成为myfunc， 然后1+2\n\n\n\n\n匿名函数就是没有函数名的函数，匿名函数可以作为参数进行传递，也可以作为返回值进行返回\n匿名函数是在传递或者返回的时候进行定义\n\n//匿名函数作为参数进行传递\nfunc add(a, b int) int{\n    fmt.Printf(\"sum is %d\\n\", a + b)\n}\nfunc cal(y int, myfunc func(int, int)) {\n    myfunc(y, 2)\n}\n\ncal(1, func(a, b int){\n    fmt.Printf(\"total is %d\\n\", a + b)\n})\n\n//输出结果为total is 3\n//调用cal函数传递临时定义的匿名函数函数成为myfunc， 然后1+2\n\n\n//匿名函数作为变量进行赋值\nfunc cal(y int, myfunc func(int, int)) {\n    myfunc(y, 2)\n}\nlocalFunc := func(a, b int){\n    fmt.Printf(\"local is %d\\n\", a + b)\n}\n\ncal(1, localFunc)\n\n//输出结果为local is 3\n//调用cal函数传递localFunc成为myfunc， 然后1+2，跟上边的效果是一样的\n\n\n\n\n\n有一个需求，希望有一个函数每次调用返回的结果值都是增加一次之后的值\n实现这个需求通常的方法是设置一个全局变量，每次调用函数的时候，将全局变量的值加1，然后返回全局变量的值\n\n全局变量方式实现：\nvar local int\nfunc add() int{\n    local += 1\n    return local\n}\n\nfor i := 0; i &lt; 5; i++ {\n    fmt.Println(add())\n}\n但是这种情况下会出现一个问题，想让local归零很难实现，而且被迫声明了一个全集变量\n因此go中设计了闭包的特性，下面是一个例子：\nfunc auotoAdd() func() int {\n    local := 0\n    return func() int {\n        return local\n    }\n}\n\nnextFunc := auotoAdd()\nfor i := 0; i &lt; 5; i++ {\n    fmt.Println(nextFunc())\n}\n//输出结果为0 1 2 3 4\n//想要归零的话，只需要重新调用auotoAdd()函数即可\n根据上面的例子可以得出闭包的定义：是指一个函数能够访问其外部作用域中的变量，即使外部函数已经结束执行。\n比如：在一个函数中的匿名函数能够访问这个函数中的局部变量，这个匿名函数称为闭包。\n\n\n\n\ndefer可以理解为其它语言中的finally，在函数执行完毕之后执行，通常用于释放资源、关闭文件、关闭数据库连接等操作\n连接数据库、打开文件、开始锁等场景下，无论执行是否成功都要记得进行关闭操作，否则会造成资源泄漏等问题\n\n// 一个在Java中的例子\ntry {\n    // 可能会发生异常的代码\n} catch (Exception e) {\n    // 异常处理代码\n} finally {\n    // 无论是否发生异常，都会执行的代码\n}\n在Java中try和finally之间的距离可能很远，容易忘记关闭资源，而在go中可以使用defer来解决这个问题\n在go中defer的使用方式如下：\nvar mu sync.Mutex\n\nmu.lock()\ndefer mu.unlock() //defer后面的代码会在return之前执行\ndefer语句成对出现，可以防止忘记关闭资源，机制更好用，代码更简洁\ndefer fmt.Println(\"1\")\ndefer fmt.Println(\"2\")\ndefer fmt.Println(\"3\")\nfmt.Println(\"4\")\n//输出结果为4 3 2 1\ndefer的执行顺序是先进后出的，类似于栈的概念\ndefer的应用可以修改返回值\n// 在这个例子中，defer 推迟执行的是一个匿名函数\n// deferReturn 函数被调用，准备返回值 10。\n// 在返回之前，defer 推迟执行的匿名函数被执行。\n// 匿名函数中，result 被增加 1，因此 result 的值从 10 变为 11。\n// deferReturn 函数返回修改后的 result 值，即 11。\n// 因此，尽管 deferReturn 函数的返回语句是 return 10，但由于 defer 推迟执行的函数在返回之前修改了 result 的值，所以最终的输出结果是 11。这也展示了在 Go 语言中，defer 可以修改函数的返回值。\n\n// 搞不懂就看源码\n\nfunc deferReturn() (result int){\n    defer func(){\n        result++\n    }()\n    return 10\n}\n\nret := deferReturn()\nfmt.Println(ret) //输出结果为11\n\n\n\n\n在go语言中关于出错处理最重要的概念有三个：\n1、error\n2、panic\n3、recover\n\n\ngo中关于语言错误处理的理念：不应该使用异常处理控制流程，而应该使用错误值。\n其他语言在使用异常处理控制流程时，通常会使用try catch来捕获异常，类似于包住函数 {: .prompt-tip }\n\n\n在go语言中开发函数的人需要有一个返回值告诉调用者是否成功，go的设计者要求我们必须处理这个err，在go的代码中，会大量出现”if err != nil”这样的语句\ngo的设计者认为必须处理这个err，继续防御性编程\n所以go中使用panic来处理错误，panic会中断当前的函数执行，然后在调用函数中查找是否有recover，如果有recover则会执行recover，否则会一直向上查找，直到找到recover或者程序崩溃\n\n\n\n在go中error有专门的包，下面举个例子：\nimport (\n    \"fmt\"\n    \"errors\"\n)\n\nfunc A() (int, error) {\n    return 1, errors.New(\"这是一个错误\")\n}\n\nfunc main() {\n    if _, err := A(); err!= nil {\n        fmt.Println(err)\n    }\n}\n\n\n\n\npanic是go中的内置函数，这个函数会导致程序退出，使用的场景不是很多\n\n再举个例子：\nimport (\n    \"fmt\"\n    \"errors\"\n)\n\nfunc A() (int, error) {\n    panic(\"this is a panic\")\n    fmt.Println(\"能执行到这吗？\")\n    return 1, errors.New(\"这是一个错误\")\n}\n\nfunc main() {\n    if _, err := A(); err!= nil {\n        fmt.Println(err)\n    }\n}\n\n// 在上面的例子中，panic会导致程序退出，所以fmt.Println(\"能执行到这吗？\")不会被执行，只会打印错误栈\n\npanic会导致程序的退出，注意平时开发中不能随便使用，下面是它的一些应用场景：\n在一个服务启动的过程中，开始必须要准备好一些依赖服务，日志文件是否存在、数据库是否能连接、配置文件有没有问题等等，准备好后才能启动服务\n如果在进行服务启动检查的过程中，发现任何一项需求不能被满足，就主动调用panic，让程序退出\n一旦服务器启动了，某行代码中不小心调用了panic，程序挂了就是非常严重的事故\n在go中一些地方也会被动触发panic：\n1、数组越界\n2、空指针\n……\n\n为了能够应对被动触发panic的情况，go中提供了recover函数，recover函数可以捕获panic，并且让程序继续执行，下一节介绍recover函数\npanic后会返回一个interface{}类型的值，这个值就是panic的值\n\n\n\n下面是一个recover使用的例子：\n// 在go中map的使用需要进行初始化，否则会报错，这是一个会被动触发panic的场景\n\nfunc A() {\n    defer func(){\n        if err := recover(); err!= nil {\n            fmt.Println(\"recoverd is A(): \", err)\n        }\n    }()\n    var names map[string]string\n    names[\"xiaoming\"] = \"go工程师\"\n    return 0, errors.New(\"这是一个错误\")\n}\n// 上面的代码会输出recoverd is A(): assignment to entry nil map\n\n还有一些使用的注意事项：\n1、recover只能在defer函数中使用才能生效\n2、defer需要在panic之前进行定义\n3、recover处理异常后，逻辑并不会恢复到panic的点继续执行\n4、多个defer会形成栈，后定义的defer会先执行"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（8）.html#函数的定义",
    "href": "content/learning-notes/golang/entries/golang学习记录（8）.html#函数的定义",
    "title": "golang学习记录（8）",
    "section": "",
    "text": "函数的基本定义方式如下：\nfunc 函数名(参数列表) (返回值列表) {\n    函数体\n}\n\n参数列表：参数列表可以为空，也可以有多个参数，多个参数之间用逗号分隔\n返回值列表：返回值列表可以为空，也可以有多个返回值，多个返回值之间用逗号分隔，返回值列表不为空时，函数中必须有return\n\n举个简单的例子：\nfunc add(a, b int, c float32) (int, error) {\n    return a + b, nil\n}\n\n在go语言中参数的传递时值传递，即传递的是值的副本，而不是值的引用，因此在函数中修改参数的值不会影响到原变量的值\n但是关于切片的传递，由于切片的底层原理，在函数中修改切片的值会影响到原切片的值，因此在go语言中切片的传递需要注意。\n当且切片发生扩容时，会返回一个新的切片，此时在函数中修改切片的值不会影响到原切片的值\n\n除了上面讲到的函数定义的方法，还可以在返回列表中执行返回参数的名称（相当于定义一个参数名称），这个参数在函数体中不需要再进行定义\n下面是一个例子\nfunc add(a, b int) (sum int, err error) {\n    sum = a + b\n    return sum, err\n    //也可以直接写return\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（8）.html#函数的可变参数",
    "href": "content/learning-notes/golang/entries/golang学习记录（8）.html#函数的可变参数",
    "title": "golang学习记录（8）",
    "section": "",
    "text": "函数在进行参数传递的时候没可能不知道要传多少个值，因此go语言中函数的参数列表中可以使用可变参数\n\n可变参数的基本定义方式如下：\nfunc 函数名(参数列表...类型) (返回值列表) {\n    函数体\n}\n举一个简单的例子：\nfunc add(a ...int)(sum int, err error) {\n    for _, value := range a {\n        sum += value\n    }\n}\nc := 1\nd := 2\nsum, _ := add(a, b, 3, 4)\nfmt.Println(sum)\n\n其中a是一个int类型的切片，在函数中可以使用a[0]、a[1]等方式访问切片中的元，也可以通过for循环进行访问"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（8）.html#函数一等公民特性",
    "href": "content/learning-notes/golang/entries/golang学习记录（8）.html#函数一等公民特性",
    "title": "golang学习记录（8）",
    "section": "",
    "text": "函数的一等公民特性，能够当作参数进行传递、作为返回值进行返回、赋值给变量等操作\n大大提升了函数的灵活性和复用性\n\n\n\n举个例子：\nfunc add(a ...int)(sum int, err error) {\n    for _, value := range a {\n        sum += value\n    }\n}\n\nfunc main(){\n    //这里将add函数作为参数赋值给变量funcVar\n    funcVar := add\n    c := 1\n    d := 2\n    sum, _ := funcVar(a, b, 3, 4)\n    fmt.Println(sum)\n}\n\n\n\n举个例子：\nfunc cal(op string) func(){\n    switch op {\n    case \"+\":\n        return func(){\n            fmt.Println(\"这是加法\")\n        }\n\n    case \"-\":\n        return func(){\n            fmt.Println(\"这是减法\")\n        }\n    default:\n        return func(){\n            fmt.Println(\"这不是加法也不是减法\")\n        }\n    }\n}\n\n//因为返回的是函数，所以在调用的时候需要加上()\ncal(\"+\")()\n\n\n\n举个例子（没啥意义，只是说明用法）：\nfunc add(a, b int) int{\n    fmt.Printf(\"sum is %d\\n\", a + b)\n}\nfunc cal(y int, myfunc func(int, int)) {\n    myfunc(y, 2)\n}\n\ncal(1, add)\n\n//输出结果为sum is 3\n//调用cal函数传递add函数成为myfunc， 然后1+2\n\n\n\n\n匿名函数就是没有函数名的函数，匿名函数可以作为参数进行传递，也可以作为返回值进行返回\n匿名函数是在传递或者返回的时候进行定义\n\n//匿名函数作为参数进行传递\nfunc add(a, b int) int{\n    fmt.Printf(\"sum is %d\\n\", a + b)\n}\nfunc cal(y int, myfunc func(int, int)) {\n    myfunc(y, 2)\n}\n\ncal(1, func(a, b int){\n    fmt.Printf(\"total is %d\\n\", a + b)\n})\n\n//输出结果为total is 3\n//调用cal函数传递临时定义的匿名函数函数成为myfunc， 然后1+2\n\n\n//匿名函数作为变量进行赋值\nfunc cal(y int, myfunc func(int, int)) {\n    myfunc(y, 2)\n}\nlocalFunc := func(a, b int){\n    fmt.Printf(\"local is %d\\n\", a + b)\n}\n\ncal(1, localFunc)\n\n//输出结果为local is 3\n//调用cal函数传递localFunc成为myfunc， 然后1+2，跟上边的效果是一样的"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（8）.html#go中函数的闭包特性",
    "href": "content/learning-notes/golang/entries/golang学习记录（8）.html#go中函数的闭包特性",
    "title": "golang学习记录（8）",
    "section": "",
    "text": "有一个需求，希望有一个函数每次调用返回的结果值都是增加一次之后的值\n实现这个需求通常的方法是设置一个全局变量，每次调用函数的时候，将全局变量的值加1，然后返回全局变量的值\n\n全局变量方式实现：\nvar local int\nfunc add() int{\n    local += 1\n    return local\n}\n\nfor i := 0; i &lt; 5; i++ {\n    fmt.Println(add())\n}\n但是这种情况下会出现一个问题，想让local归零很难实现，而且被迫声明了一个全集变量\n因此go中设计了闭包的特性，下面是一个例子：\nfunc auotoAdd() func() int {\n    local := 0\n    return func() int {\n        return local\n    }\n}\n\nnextFunc := auotoAdd()\nfor i := 0; i &lt; 5; i++ {\n    fmt.Println(nextFunc())\n}\n//输出结果为0 1 2 3 4\n//想要归零的话，只需要重新调用auotoAdd()函数即可\n根据上面的例子可以得出闭包的定义：是指一个函数能够访问其外部作用域中的变量，即使外部函数已经结束执行。\n比如：在一个函数中的匿名函数能够访问这个函数中的局部变量，这个匿名函数称为闭包。"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（8）.html#defer的应用场景",
    "href": "content/learning-notes/golang/entries/golang学习记录（8）.html#defer的应用场景",
    "title": "golang学习记录（8）",
    "section": "",
    "text": "defer可以理解为其它语言中的finally，在函数执行完毕之后执行，通常用于释放资源、关闭文件、关闭数据库连接等操作\n连接数据库、打开文件、开始锁等场景下，无论执行是否成功都要记得进行关闭操作，否则会造成资源泄漏等问题\n\n// 一个在Java中的例子\ntry {\n    // 可能会发生异常的代码\n} catch (Exception e) {\n    // 异常处理代码\n} finally {\n    // 无论是否发生异常，都会执行的代码\n}\n在Java中try和finally之间的距离可能很远，容易忘记关闭资源，而在go中可以使用defer来解决这个问题\n在go中defer的使用方式如下：\nvar mu sync.Mutex\n\nmu.lock()\ndefer mu.unlock() //defer后面的代码会在return之前执行\ndefer语句成对出现，可以防止忘记关闭资源，机制更好用，代码更简洁\ndefer fmt.Println(\"1\")\ndefer fmt.Println(\"2\")\ndefer fmt.Println(\"3\")\nfmt.Println(\"4\")\n//输出结果为4 3 2 1\ndefer的执行顺序是先进后出的，类似于栈的概念\ndefer的应用可以修改返回值\n// 在这个例子中，defer 推迟执行的是一个匿名函数\n// deferReturn 函数被调用，准备返回值 10。\n// 在返回之前，defer 推迟执行的匿名函数被执行。\n// 匿名函数中，result 被增加 1，因此 result 的值从 10 变为 11。\n// deferReturn 函数返回修改后的 result 值，即 11。\n// 因此，尽管 deferReturn 函数的返回语句是 return 10，但由于 defer 推迟执行的函数在返回之前修改了 result 的值，所以最终的输出结果是 11。这也展示了在 Go 语言中，defer 可以修改函数的返回值。\n\n// 搞不懂就看源码\n\nfunc deferReturn() (result int){\n    defer func(){\n        result++\n    }()\n    return 10\n}\n\nret := deferReturn()\nfmt.Println(ret) //输出结果为11"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（8）.html#go的errorrecover和panic",
    "href": "content/learning-notes/golang/entries/golang学习记录（8）.html#go的errorrecover和panic",
    "title": "golang学习记录（8）",
    "section": "",
    "text": "在go语言中关于出错处理最重要的概念有三个：\n1、error\n2、panic\n3、recover\n\n\ngo中关于语言错误处理的理念：不应该使用异常处理控制流程，而应该使用错误值。\n其他语言在使用异常处理控制流程时，通常会使用try catch来捕获异常，类似于包住函数 {: .prompt-tip }\n\n\n在go语言中开发函数的人需要有一个返回值告诉调用者是否成功，go的设计者要求我们必须处理这个err，在go的代码中，会大量出现”if err != nil”这样的语句\ngo的设计者认为必须处理这个err，继续防御性编程\n所以go中使用panic来处理错误，panic会中断当前的函数执行，然后在调用函数中查找是否有recover，如果有recover则会执行recover，否则会一直向上查找，直到找到recover或者程序崩溃\n\n\n\n在go中error有专门的包，下面举个例子：\nimport (\n    \"fmt\"\n    \"errors\"\n)\n\nfunc A() (int, error) {\n    return 1, errors.New(\"这是一个错误\")\n}\n\nfunc main() {\n    if _, err := A(); err!= nil {\n        fmt.Println(err)\n    }\n}\n\n\n\n\npanic是go中的内置函数，这个函数会导致程序退出，使用的场景不是很多\n\n再举个例子：\nimport (\n    \"fmt\"\n    \"errors\"\n)\n\nfunc A() (int, error) {\n    panic(\"this is a panic\")\n    fmt.Println(\"能执行到这吗？\")\n    return 1, errors.New(\"这是一个错误\")\n}\n\nfunc main() {\n    if _, err := A(); err!= nil {\n        fmt.Println(err)\n    }\n}\n\n// 在上面的例子中，panic会导致程序退出，所以fmt.Println(\"能执行到这吗？\")不会被执行，只会打印错误栈\n\npanic会导致程序的退出，注意平时开发中不能随便使用，下面是它的一些应用场景：\n在一个服务启动的过程中，开始必须要准备好一些依赖服务，日志文件是否存在、数据库是否能连接、配置文件有没有问题等等，准备好后才能启动服务\n如果在进行服务启动检查的过程中，发现任何一项需求不能被满足，就主动调用panic，让程序退出\n一旦服务器启动了，某行代码中不小心调用了panic，程序挂了就是非常严重的事故\n在go中一些地方也会被动触发panic：\n1、数组越界\n2、空指针\n……\n\n为了能够应对被动触发panic的情况，go中提供了recover函数，recover函数可以捕获panic，并且让程序继续执行，下一节介绍recover函数\npanic后会返回一个interface{}类型的值，这个值就是panic的值\n\n\n\n下面是一个recover使用的例子：\n// 在go中map的使用需要进行初始化，否则会报错，这是一个会被动触发panic的场景\n\nfunc A() {\n    defer func(){\n        if err := recover(); err!= nil {\n            fmt.Println(\"recoverd is A(): \", err)\n        }\n    }()\n    var names map[string]string\n    names[\"xiaoming\"] = \"go工程师\"\n    return 0, errors.New(\"这是一个错误\")\n}\n// 上面的代码会输出recoverd is A(): assignment to entry nil map\n\n还有一些使用的注意事项：\n1、recover只能在defer函数中使用才能生效\n2、defer需要在panic之前进行定义\n3、recover处理异常后，逻辑并不会恢复到panic的点继续执行\n4、多个defer会形成栈，后定义的defer会先执行"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（6）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（6）.html",
    "title": "golang学习记录（6）",
    "section": "",
    "text": "个其他语言差不多，go中if语句后面的条件判断可以加括号，也可以不加，通常不写括号，但是如果条件比较复杂，建议加上括号。\nage := 10\n//1、加括号\nif age &gt; 18 {\n    fmt.Println(\"你已经成年了\")\n}\n//2、不加括号\nif (age &gt; 18){\n    fmt.Println(\"你已经成年了\")\n}\n\n\n\nage := 10\nif age &gt; 18 {\n    fmt.Println(\"你已经成年了\")\n} else {\n    fmt.Println(\"你还没有成年\")\n}\n\n// else if\nif age &gt; 20 {\n    fmt.Println(\"你已经成年了\")\n} else if a18 &gt; 16 {\n    fmt.Println(\"你已经成年了\")\n} else {\n    fmt.Println(\"你还没有成年\")\n}\n\n\n\n\n\ngo中没有while循环，只有for循环\n\n\n\n//基础写法\nfor i := 0; i &lt; 10; i++ {\n    fmt.Println(i)\n}\n//注意不能加括号\n\n//for循环代替while循环\nvar i int = 0\nfor {\n    if i &gt; 10 {\n        break\n    }\n    fmt.Println(i)\n    i++\n}\n\n\n\n\n\nfor i := 1; i &lt;= 1--; i++{\n    if i % 2 == 0{\n        fmt.Println(i)\n    }\n}\n\n\n\nfor i := 1; i &lt;= 9; i++{\n    for j := 1; j &lt;= i; j++{\n        fmt.Printf(\"%d * %d = %d\\t\", j, i, i * j)\n    }\n    fmt.Println()\n}\n\n\n\n\n\nfor range 主要对于数组、切片、字符串、map、通道等进行迭代循环，返回的是索引和值。\n\nname := \"hello go, hello world\"\n\nfor index, value := range name {\n    fmt.Printf(\"index = %d, value = %c\\n\", index, value)\n}\n\nfor _, value := range name {\n    fmt.Printf(\"value = %c\\n\", value)\n}\n\nfor index := range name {\n    fmt.Printf(\"index = %d\\n\", index)\n    fmt.Printf(\"value = %c\\n\", name[index])\n}\n\n注意： \n\n\n\n\n使用break和continue来退出循环。\ncontinue 用于跳过当前循环的剩余语句，然后继续执行下一次循环。\nbreak 用于跳出当前循环，执行循环之后的语句。\n\n\n\n\n\ngoto语句可以让我们的代码跳转到指定的代码块中运行，但是不建议使用goto语句，因为goto语句会让代码的可读性变差，而且也会让代码的维护变得困难。\ngo语言中的goto语句可以实现程序的跳转，goto语句使用最多的是程序的错误处理，当程序处理错误时，跳转到相应的标签处统一处理。\n\nfor i := 0; i &lt; 10; i++ {\n    for j := 0; j &lt; 10; j++ {\n        if j == 5 {\n            goto over\n        }\n        fmt.Println(i, j)\n    }\n}\n\n//任意代码块\nover:\n    fmt.Println(\"over\")\n//代码直接跳转到over代码块中运行\n\n\n\n\nswitch语句用于根据不同的条件执行不同的代码块，它可以替代多个if else语句。\n提升代码的可读性\n\n//基础写法\nswitch var1{\n    case val1:\n       ...\n    case val2:\n       ...\n    default:\n       ...\n}\n\n//举例--中文的星期几，输出对应的英文\nday := \"星期一\"\n\nswitch dat{\n    case \"星期一\":\n        fmt.Println(\"Monday\")\n    case \"星期二\":\n        fmt.Println(\"Tuesday\")\n    case \"星期三\":\n        fmt.Println(\"Wednesday\")\n    case \"星期四\":\n        fmt.Println(\"Thursday\")\n    case \"星期五\":\n        fmt.Println(\"Friday\")\n    case \"星期六\":\n        fmt.Println(\"Saturday\")\n    case \"星期日\":\n        fmt.Println(\"Sunday\")\n    default:\n        fmt.Println(\"Unknown\")\n}\n\nsiwtch {\n    case day == \"星期一\":\n        fmt.Println(\"Monday\")\n    case day == \"星期二\":\n        fmt.Println(\"Tuesday\")\n    case day == \"星期三\":\n        fmt.Println(\"Wednesday\")\n    case day == \"星期四\":\n        fmt.Println(\"Thursday\")\n    case day == \"星期五\":\n        fmt.Println(\"Friday\")\n    case day == \"星期六\":\n        fmt.Println(\"Saturday\")\n    case day == \"星期日\":\n        fmt.Println(\"Sunday\")\n    default:\n        fmt.Println(\"Unknown\")\n}\n\nscore := 90\n\nswitch {\n    case score &gt;= 90:\n        fmt.Println(\"A\")\n    case score &gt;= 80:\n        fmt.Println(\"B\")\n    case score &gt;= 70:\n        fmt.Println(\"C\")\n    case score &gt;= 60:\n        fmt.Println(\"D\")\n    default:\n        fmt.Println(\"E\")\n}\n\n注意：Go语言的switch语句不需要break关键字来终止每个case。如果不使用break，执行完一个case后，程序会自动退出switch语句。"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（6）.html#if条件判断",
    "href": "content/learning-notes/golang/entries/golang学习记录（6）.html#if条件判断",
    "title": "golang学习记录（6）",
    "section": "",
    "text": "个其他语言差不多，go中if语句后面的条件判断可以加括号，也可以不加，通常不写括号，但是如果条件比较复杂，建议加上括号。\nage := 10\n//1、加括号\nif age &gt; 18 {\n    fmt.Println(\"你已经成年了\")\n}\n//2、不加括号\nif (age &gt; 18){\n    fmt.Println(\"你已经成年了\")\n}\n\n\n\nage := 10\nif age &gt; 18 {\n    fmt.Println(\"你已经成年了\")\n} else {\n    fmt.Println(\"你还没有成年\")\n}\n\n// else if\nif age &gt; 20 {\n    fmt.Println(\"你已经成年了\")\n} else if a18 &gt; 16 {\n    fmt.Println(\"你已经成年了\")\n} else {\n    fmt.Println(\"你还没有成年\")\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（6）.html#for循环",
    "href": "content/learning-notes/golang/entries/golang学习记录（6）.html#for循环",
    "title": "golang学习记录（6）",
    "section": "",
    "text": "go中没有while循环，只有for循环\n\n\n\n//基础写法\nfor i := 0; i &lt; 10; i++ {\n    fmt.Println(i)\n}\n//注意不能加括号\n\n//for循环代替while循环\nvar i int = 0\nfor {\n    if i &gt; 10 {\n        break\n    }\n    fmt.Println(i)\n    i++\n}\n\n\n\n\n\nfor i := 1; i &lt;= 1--; i++{\n    if i % 2 == 0{\n        fmt.Println(i)\n    }\n}\n\n\n\nfor i := 1; i &lt;= 9; i++{\n    for j := 1; j &lt;= i; j++{\n        fmt.Printf(\"%d * %d = %d\\t\", j, i, i * j)\n    }\n    fmt.Println()\n}\n\n\n\n\n\nfor range 主要对于数组、切片、字符串、map、通道等进行迭代循环，返回的是索引和值。\n\nname := \"hello go, hello world\"\n\nfor index, value := range name {\n    fmt.Printf(\"index = %d, value = %c\\n\", index, value)\n}\n\nfor _, value := range name {\n    fmt.Printf(\"value = %c\\n\", value)\n}\n\nfor index := range name {\n    fmt.Printf(\"index = %d\\n\", index)\n    fmt.Printf(\"value = %c\\n\", name[index])\n}\n\n注意： \n\n\n\n\n使用break和continue来退出循环。\ncontinue 用于跳过当前循环的剩余语句，然后继续执行下一次循环。\nbreak 用于跳出当前循环，执行循环之后的语句。"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（6）.html#goto语句",
    "href": "content/learning-notes/golang/entries/golang学习记录（6）.html#goto语句",
    "title": "golang学习记录（6）",
    "section": "",
    "text": "goto语句可以让我们的代码跳转到指定的代码块中运行，但是不建议使用goto语句，因为goto语句会让代码的可读性变差，而且也会让代码的维护变得困难。\ngo语言中的goto语句可以实现程序的跳转，goto语句使用最多的是程序的错误处理，当程序处理错误时，跳转到相应的标签处统一处理。\n\nfor i := 0; i &lt; 10; i++ {\n    for j := 0; j &lt; 10; j++ {\n        if j == 5 {\n            goto over\n        }\n        fmt.Println(i, j)\n    }\n}\n\n//任意代码块\nover:\n    fmt.Println(\"over\")\n//代码直接跳转到over代码块中运行"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（6）.html#switch语句",
    "href": "content/learning-notes/golang/entries/golang学习记录（6）.html#switch语句",
    "title": "golang学习记录（6）",
    "section": "",
    "text": "switch语句用于根据不同的条件执行不同的代码块，它可以替代多个if else语句。\n提升代码的可读性\n\n//基础写法\nswitch var1{\n    case val1:\n       ...\n    case val2:\n       ...\n    default:\n       ...\n}\n\n//举例--中文的星期几，输出对应的英文\nday := \"星期一\"\n\nswitch dat{\n    case \"星期一\":\n        fmt.Println(\"Monday\")\n    case \"星期二\":\n        fmt.Println(\"Tuesday\")\n    case \"星期三\":\n        fmt.Println(\"Wednesday\")\n    case \"星期四\":\n        fmt.Println(\"Thursday\")\n    case \"星期五\":\n        fmt.Println(\"Friday\")\n    case \"星期六\":\n        fmt.Println(\"Saturday\")\n    case \"星期日\":\n        fmt.Println(\"Sunday\")\n    default:\n        fmt.Println(\"Unknown\")\n}\n\nsiwtch {\n    case day == \"星期一\":\n        fmt.Println(\"Monday\")\n    case day == \"星期二\":\n        fmt.Println(\"Tuesday\")\n    case day == \"星期三\":\n        fmt.Println(\"Wednesday\")\n    case day == \"星期四\":\n        fmt.Println(\"Thursday\")\n    case day == \"星期五\":\n        fmt.Println(\"Friday\")\n    case day == \"星期六\":\n        fmt.Println(\"Saturday\")\n    case day == \"星期日\":\n        fmt.Println(\"Sunday\")\n    default:\n        fmt.Println(\"Unknown\")\n}\n\nscore := 90\n\nswitch {\n    case score &gt;= 90:\n        fmt.Println(\"A\")\n    case score &gt;= 80:\n        fmt.Println(\"B\")\n    case score &gt;= 70:\n        fmt.Println(\"C\")\n    case score &gt;= 60:\n        fmt.Println(\"D\")\n    default:\n        fmt.Println(\"E\")\n}\n\n注意：Go语言的switch语句不需要break关键字来终止每个case。如果不使用break，执行完一个case后，程序会自动退出switch语句。"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（4）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（4）.html",
    "title": "golang学习记录（4）",
    "section": "",
    "text": "go的基础数据类型有bool、string、int、float、byte、rune、uint、int8、int16、int32、int64、uint8、uint16、uint32、uint64、float32、float64等\n具体可以分成以下几种：\n\n\n\n\n\n\n\ntrue 和 false\n\n\n\n\n\n\n多种数值考虑到了空间要求高的情况\n\nint8\nint16\nint32\nint64\nuint8\nuint16\nuint32\nuint64\nint\nuint\n\nint和uint的大小取决于操作系统架构，操作系统时32位就是32位，操作系统是64位就是64位\n其他类型具体介绍如下： \n\n\n\n\nfloat32\nfloat64\n\n分别表示32位浮点数和64位浮点数\n\n\n\n在go中没有复数类型，但是可以使用complex64和complex128类型来表示复数。\ngo中也有专门的包处理复数\nimport \"math/cmplx\"\n\n\n\ngo中没有char类型，只有byte类型，byte是uint8的别名，byte类型用于表示一个字节（8bit），通常用于处理二进制数据和文本数据。\nvar b byte = 'A'\n\n\n\nrune是int32的别名，rune类型用于表示一个Unicode字符，通常用于处理Unicode文本数据。\nvar r rune = '中'\n\n\n\n\n单个字符一般用byte进行存储\n字符串就是string\nvar name string\nname = \"aorange\"\n\n\n\n\n在go中定义了byte，他是uint8的别名，通过这种别名的方式确定byte用于字符，而不是将uint8既用于字符又用于整数。\nvar a int8 = 12\nvar b = uint8(a)\n\nvar f float32 = 12.3\nvar g = int(f)\n\n// 字符转换为数字，这种情况可能会出错，有err返回\nvar isrt = \"12\"\nvar i, err = strconv.Atoi(isrt)\nif err!= nil {\n    fmt.Println(\"转换失败\")\n}\n\n//数字转字符串类型，理论上不会出错，没有err返回\nvar i = 12\nvar s = strconv.Itoa(i)\n\n\n\n将字符串转成folat32，或者bool类型 将其他类型转成字符串类型\nvar s = \"12.3\"\nvar f, err = strconv.ParseFloat(s, 32) // 32表示32位浮点数\n\n//ParseInt进行进制转换\nparseInt , err := strconv.ParseInt(s: \"12\", 8, 64)//8表示8进制，64表示64位\n//此时输出结果为10进制的10\n\n//有关bool类型的转换\nparseBool, err := strconv.ParseBool(s: \"true\")\n//转换失败parseBool结果为零值，即false，err不为空\n//true，t，T，y，Y，1，\n//false，f，F，n，N，0\n//其他结果转换可能失败\n\n//基本类型转字符串\nstrconv.FmoatBool(b: true)\nfmt.Println(b)\n//其他的转换可以找源码看看，都差不多，都是用的strconv.FormatXXX\n转换失败测试如下： \n\n\n\n\n这玩意需要到了就直接查，常用的跟C++差不多\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n对性能要求高的情况下考虑与运算，与运算比加减乘除运算快很多\n\n\n\n\n\n\n\n具体优先级如下： \n\n\n基础还是要多使用，熟悉就好了，各种语言关于数据的类型和转换都有相似之处"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（4）.html#数值浮点数和字符类型",
    "href": "content/learning-notes/golang/entries/golang学习记录（4）.html#数值浮点数和字符类型",
    "title": "golang学习记录（4）",
    "section": "",
    "text": "true 和 false\n\n\n\n\n\n\n多种数值考虑到了空间要求高的情况\n\nint8\nint16\nint32\nint64\nuint8\nuint16\nuint32\nuint64\nint\nuint\n\nint和uint的大小取决于操作系统架构，操作系统时32位就是32位，操作系统是64位就是64位\n其他类型具体介绍如下： \n\n\n\n\nfloat32\nfloat64\n\n分别表示32位浮点数和64位浮点数\n\n\n\n在go中没有复数类型，但是可以使用complex64和complex128类型来表示复数。\ngo中也有专门的包处理复数\nimport \"math/cmplx\"\n\n\n\ngo中没有char类型，只有byte类型，byte是uint8的别名，byte类型用于表示一个字节（8bit），通常用于处理二进制数据和文本数据。\nvar b byte = 'A'\n\n\n\nrune是int32的别名，rune类型用于表示一个Unicode字符，通常用于处理Unicode文本数据。\nvar r rune = '中'\n\n\n\n\n单个字符一般用byte进行存储\n字符串就是string\nvar name string\nname = \"aorange\""
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（4）.html#基本类型的转换",
    "href": "content/learning-notes/golang/entries/golang学习记录（4）.html#基本类型的转换",
    "title": "golang学习记录（4）",
    "section": "",
    "text": "在go中定义了byte，他是uint8的别名，通过这种别名的方式确定byte用于字符，而不是将uint8既用于字符又用于整数。\nvar a int8 = 12\nvar b = uint8(a)\n\nvar f float32 = 12.3\nvar g = int(f)\n\n// 字符转换为数字，这种情况可能会出错，有err返回\nvar isrt = \"12\"\nvar i, err = strconv.Atoi(isrt)\nif err!= nil {\n    fmt.Println(\"转换失败\")\n}\n\n//数字转字符串类型，理论上不会出错，没有err返回\nvar i = 12\nvar s = strconv.Itoa(i)"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（4）.html#format进行格式转换",
    "href": "content/learning-notes/golang/entries/golang学习记录（4）.html#format进行格式转换",
    "title": "golang学习记录（4）",
    "section": "",
    "text": "将字符串转成folat32，或者bool类型 将其他类型转成字符串类型\nvar s = \"12.3\"\nvar f, err = strconv.ParseFloat(s, 32) // 32表示32位浮点数\n\n//ParseInt进行进制转换\nparseInt , err := strconv.ParseInt(s: \"12\", 8, 64)//8表示8进制，64表示64位\n//此时输出结果为10进制的10\n\n//有关bool类型的转换\nparseBool, err := strconv.ParseBool(s: \"true\")\n//转换失败parseBool结果为零值，即false，err不为空\n//true，t，T，y，Y，1，\n//false，f，F，n，N，0\n//其他结果转换可能失败\n\n//基本类型转字符串\nstrconv.FmoatBool(b: true)\nfmt.Println(b)\n//其他的转换可以找源码看看，都差不多，都是用的strconv.FormatXXX\n转换失败测试如下："
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（4）.html#运算符和表达式",
    "href": "content/learning-notes/golang/entries/golang学习记录（4）.html#运算符和表达式",
    "title": "golang学习记录（4）",
    "section": "",
    "text": "这玩意需要到了就直接查，常用的跟C++差不多\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n对性能要求高的情况下考虑与运算，与运算比加减乘除运算快很多\n\n\n\n\n\n\n\n具体优先级如下： \n\n\n基础还是要多使用，熟悉就好了，各种语言关于数据的类型和转换都有相似之处"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（2）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（2）.html",
    "title": "golang学习记录（2）",
    "section": "",
    "text": "首先要创建golang开发的目录，可以创建成下面的形式 &gt; go_project &gt; - src &gt; * go_code &gt; * project01 &gt; * main &gt; * hello.go &gt; * package &gt; * project02 &gt; * main &gt; * package\n其中hello.go就是一个简单的go程序，代码如下：\npackage main\nimport \"fmt\"\nfunc main(){\n    fmt.Println(\"hello world!\")\n}\n说明： （1）go的文件后缀就是“.go”，在go中，一个文件就是一个包，一个包可以包含多个文件，但是一个文件只能包含一个包。 （2）package main 表示当前文件所在的包名，必须是main包，否则无法执行。 （3）在go中，每个文件都必须归属于一个包 （4）import “fmt” 表示引入fmt包，fmt包是go语言标准库中的一个包，提供了格式化输入输出的功能。引入后，就可以使用fmt包的函数，比如fmt.Println()。 （5）func main() 表示main函数，是程序的入口函数，程序从main函数开始执行。其中func是关键字，表示一个函数，main是函数名，是一个主函数，是程序的入口。 （6）fmt.Println(“hello world!”)表示调用fmt包中的Println函数，打印输出hello world!。\n\n\n\n\n\n首先，我们要写完一个go程序\n然后，要对写完的程序进行编译，生成一个可执行文件，使用“go build”命令\ngo build hello.go\n最后，执行可执行文件，得到运行结果。\n同时，也可以直接使用“go run”命令，直接运行go程序，不需要编译，也不需要生成可执行文件。但是，每次运行都会重新编译，效率较低，并且执行时间较长。\ngo run hello.go\n总的来说，go语言的执行流程是：编写代码 -&gt; 编译生成可执行文件 -&gt; 运行可执行文件。\n\n前者运行时间短 后者运行时间长 实际开发中用到的是前者，后者一般用于测试。\n\n\n\n（1）go语言是编译型语言，需要先编译成可执行文件，然后才能运行。\n（2）如果先编译生成了可执行文件，可以将可执行文件拷贝到其他机器上，直接运行。\n（3）如果使用 go run 命令运行源码，想要在另一台机器上运行，需要先安装go环境，否则无法执行\n（4） 在编译时，编译器会将程序运行依赖的库文件包含在可执行文件中，所以可执行文件会变得很大，且能够独立运行。\n\n\n\n\n\n\n通过编译器将go源码编译成二进制文件\n在编译时指定生成的文件名：go build -o test.exe hello.go，其中在Windows下生成文件的后缀必须是exe，在Linux下生成文件的后缀可以是exe或者没有后缀。\n如果源码中没有错误，能够正常运行编译，如果源码中有错，会在错误的那行报错，并且编译失败。\n\n\n\n1、生成可执行文件，然后运行。\n2、直接使用go run命令运行，不需要编译，不需要生成可执行文件。\n\n\n\n\ngolang源文件以go为扩展名，编译后生成的可执行文件以exe为扩展名。\ngo程序的执行入口是main函数\ngo语言严格区分大小写\ngo方法由一条条语句构成，语句后面不需要分号\n在go语言中，一行代表一条语句结束。一行就写一条语句，go编译器是一行行进行编译的，一行中不能写多条语句。\ngo语言中定义的变量或者import的包如果没有使用到，代码就不能通过编译（提升代码的性能）\n括号是成对出现的，缺少会编译错误。\n\n\n\n\n\n个制表位，实现对齐功能\n换行符与\n\\ 一个反斜杠字符\n\" 一个双引号字符\n个回车符\n\n\n\n\n\n1、单行注释：//\n2、多行注释（块注释）：/* */\n\n\n\n1、 尽量使用行注释，注释方法和语句\n2、要有正确的缩进和空行（空白），shift+tab向左缩进，tab向右缩进，或者使用gofmt命令进行格式化，例如：gofmt -w main.go(可以将格式化后的内容重新写入文件)，gofmt main.go(可以将格式化后的内容输出到终端，不能写入文件)\n3、 运算符两边加空格\n4、函数的大括号 \n5、 关键字和操作符之间加空格\n6、 函数名、变量名、常量名、结构体字段名使用驼峰式命名法\n7、一行不要超过80个字符，超过80个字符需要换行\n\n\n\n\n官方网站：运行和学习\n中文编程指南：中文指南，也有其它语言的\n官方的包：关于包的使用和说明\n\n在官网可以查看代码的运行结果 tour run 可以运行代码\n\n\n\n\n什么是API？\n应用程序编程接口（Application Programming Interface），就是一个函数\n\nGolang提供了大量的标准库\nGolang中文网 : 中文关于包的介绍和使用说明\n在Go中：包-&gt;源文件-&gt;函数 \n要使用函数就直接import导入 ### Golang开发常见错误和解决方法\n注释的目的是提升可阅读性，让代码更容易理解\n1、显示找不到文件 源文件名写错、不存在或者当前的路径错误。\n2、语法错误 违反语法规则，括号，引号匹配失败海诺这拼错单词。 通过查看错误提示信息，找到错误的位置，然后修改。\n注意：“1”和”l”在编程的时候比较难区分"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（2）.html#golang开发基础",
    "href": "content/learning-notes/golang/entries/golang学习记录（2）.html#golang开发基础",
    "title": "golang学习记录（2）",
    "section": "",
    "text": "首先要创建golang开发的目录，可以创建成下面的形式 &gt; go_project &gt; - src &gt; * go_code &gt; * project01 &gt; * main &gt; * hello.go &gt; * package &gt; * project02 &gt; * main &gt; * package\n其中hello.go就是一个简单的go程序，代码如下：\npackage main\nimport \"fmt\"\nfunc main(){\n    fmt.Println(\"hello world!\")\n}\n说明： （1）go的文件后缀就是“.go”，在go中，一个文件就是一个包，一个包可以包含多个文件，但是一个文件只能包含一个包。 （2）package main 表示当前文件所在的包名，必须是main包，否则无法执行。 （3）在go中，每个文件都必须归属于一个包 （4）import “fmt” 表示引入fmt包，fmt包是go语言标准库中的一个包，提供了格式化输入输出的功能。引入后，就可以使用fmt包的函数，比如fmt.Println()。 （5）func main() 表示main函数，是程序的入口函数，程序从main函数开始执行。其中func是关键字，表示一个函数，main是函数名，是一个主函数，是程序的入口。 （6）fmt.Println(“hello world!”)表示调用fmt包中的Println函数，打印输出hello world!。\n\n\n\n\n\n首先，我们要写完一个go程序\n然后，要对写完的程序进行编译，生成一个可执行文件，使用“go build”命令\ngo build hello.go\n最后，执行可执行文件，得到运行结果。\n同时，也可以直接使用“go run”命令，直接运行go程序，不需要编译，也不需要生成可执行文件。但是，每次运行都会重新编译，效率较低，并且执行时间较长。\ngo run hello.go\n总的来说，go语言的执行流程是：编写代码 -&gt; 编译生成可执行文件 -&gt; 运行可执行文件。\n\n前者运行时间短 后者运行时间长 实际开发中用到的是前者，后者一般用于测试。\n\n\n\n（1）go语言是编译型语言，需要先编译成可执行文件，然后才能运行。\n（2）如果先编译生成了可执行文件，可以将可执行文件拷贝到其他机器上，直接运行。\n（3）如果使用 go run 命令运行源码，想要在另一台机器上运行，需要先安装go环境，否则无法执行\n（4） 在编译时，编译器会将程序运行依赖的库文件包含在可执行文件中，所以可执行文件会变得很大，且能够独立运行。\n\n\n\n\n\n\n通过编译器将go源码编译成二进制文件\n在编译时指定生成的文件名：go build -o test.exe hello.go，其中在Windows下生成文件的后缀必须是exe，在Linux下生成文件的后缀可以是exe或者没有后缀。\n如果源码中没有错误，能够正常运行编译，如果源码中有错，会在错误的那行报错，并且编译失败。\n\n\n\n1、生成可执行文件，然后运行。\n2、直接使用go run命令运行，不需要编译，不需要生成可执行文件。\n\n\n\n\ngolang源文件以go为扩展名，编译后生成的可执行文件以exe为扩展名。\ngo程序的执行入口是main函数\ngo语言严格区分大小写\ngo方法由一条条语句构成，语句后面不需要分号\n在go语言中，一行代表一条语句结束。一行就写一条语句，go编译器是一行行进行编译的，一行中不能写多条语句。\ngo语言中定义的变量或者import的包如果没有使用到，代码就不能通过编译（提升代码的性能）\n括号是成对出现的，缺少会编译错误。\n\n\n\n\n\n个制表位，实现对齐功能\n换行符与\n\\ 一个反斜杠字符\n\" 一个双引号字符\n个回车符\n\n\n\n\n\n1、单行注释：//\n2、多行注释（块注释）：/* */\n\n\n\n1、 尽量使用行注释，注释方法和语句\n2、要有正确的缩进和空行（空白），shift+tab向左缩进，tab向右缩进，或者使用gofmt命令进行格式化，例如：gofmt -w main.go(可以将格式化后的内容重新写入文件)，gofmt main.go(可以将格式化后的内容输出到终端，不能写入文件)\n3、 运算符两边加空格\n4、函数的大括号 \n5、 关键字和操作符之间加空格\n6、 函数名、变量名、常量名、结构体字段名使用驼峰式命名法\n7、一行不要超过80个字符，超过80个字符需要换行\n\n\n\n\n官方网站：运行和学习\n中文编程指南：中文指南，也有其它语言的\n官方的包：关于包的使用和说明\n\n在官网可以查看代码的运行结果 tour run 可以运行代码\n\n\n\n\n什么是API？\n应用程序编程接口（Application Programming Interface），就是一个函数\n\nGolang提供了大量的标准库\nGolang中文网 : 中文关于包的介绍和使用说明\n在Go中：包-&gt;源文件-&gt;函数 \n要使用函数就直接import导入 ### Golang开发常见错误和解决方法\n注释的目的是提升可阅读性，让代码更容易理解\n1、显示找不到文件 源文件名写错、不存在或者当前的路径错误。\n2、语法错误 违反语法规则，括号，引号匹配失败海诺这拼错单词。 通过查看错误提示信息，找到错误的位置，然后修改。\n注意：“1”和”l”在编程的时候比较难区分"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（13）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（13）.html",
    "title": "golang学习记录（13）",
    "section": "",
    "text": "go test命令是一个按照一定约定和组织的测试代码驱动程序\n在包目录中，所有以_test.go结尾的源码文件都会被go test运行到\n我们写的 _test.go源码文件不用担心内容过多，因为go test命令不会将这些测试文件打包到最后的可执行文件\n\n\n在实际应用中，test文件有四类：\n1、Test开头的：功能测试\n2、Benchmark开头的：性能测试\n3、Example开头的：模糊测试\n4、TestMain开头的：单元测试\n\n\n\n下面举一个单元测试的例子：\n在包目录中有三个go文件，分别是：\n1、add.go\n2、add_test.go\n3、main.go\n\n在add.go中定义了一个Add函数，用来实现两个整数的相加：\n在add_test.go中首先导入”testing”包，然后定义了一个TestAdd函数，用来测试Add函数的正确性，并作出相应的出错处理：\nimport \"testing\"\n\nfunc TestAdd(t *testing.T){\n    re := add(1,2)\n    if re!= 3{\n        t.Errorf(\"add(1,2) = %d; want 3\", re)\n    }\n}\n之后对add_test.go文件执行go test命令，即可进行单元测试，查看测试结果\n\n\n\n\n在实际应用中，我们可能会遇到一些耗时的单元测试用例，我们可以使用t.Skip()函数来跳过这些耗时的单元测试用例\n在执行测试文件的过程中，使用 go test -short命令可以查看测试结果，其中 -short命令会跳过所有耗时的单元测试用例\n耗时的单元测试用例是有自己定义的\n\n下面是一个使用跳过单元测试的例子：\nfunc TestAdd(t *testing.T){\n    if testing.Short(){\n        t.Skip(\"skip this test\")\n    }\n    // 下面是执行不到的\n    re := add(1,2)\n    if re!= 3{\n        t.Errorf(\"add(1,2) = %d; want 3\", re)\n    }\n}\ntesting中的short相当于采用了两种模式，供用户选择。\n\n\n\n\n\n在实际测试的的时候，测试用例可能不止一组，一个一个测试非常耗时，go中提供了一种基于表格驱动测试的方式，它可以一次性测试多组数据，提高测试效率\n\n下面是一个基于表格驱动测试的例子：\nimport \"testing\"\n\nfunc TestAdd(t *testing.T){\n    var tests = []struct{\n        a int\n        b int\n        want int\n    }{\n        {1,2,3},\n        {2,3,5},\n        {3,4,7},\n    }\n\n    for _, tt := range tests{\n        re := add(tt.a, tt.b)\n        if re!= tt.want{\n            t.Errorf(\"add(%d, %d) = %d; want %d\", tt.a, tt.b, re, tt.want)\n        }\n    }\n}\n\n\n\n\n在一些核心函数中对性能有要求，我们可以使用benchmark性能测试来测试函数的性能\n同样，性能测试函数也在”testing”包中\n在应用过程中，性能测试函数的命名必须以Benchmark开头，后面跟上要测试的函数名\n性能测试函数的参数必须是*testing.B类型的指针\n在执行测试文件的过程中，使用 go test -bench命令可以查看测试结果，其中 -bench命令会执行所有的性能测试用例\n\n下面是一个关于单元性能测试的例子：\nimport \"testing\"\n\nfunc BenchmarkAdd(b *testing.B){\n    a := 123\n    b := 456\n    c := 579\n\n\n    for i:=0; i&lt;b.N; i++{\n        if actual := add(a,b); actual!= c{\n            fmt.Printf(\"add(%d, %d) = %d; want %d\", a, b, actual, c)\n    }\n}\n在进行性能测试过沉重还有一个常用的函数：b.ResetTimer()，它可以重置计时器，使得测试结果更加准确"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（13）.html#单元测试用例",
    "href": "content/learning-notes/golang/entries/golang学习记录（13）.html#单元测试用例",
    "title": "golang学习记录（13）",
    "section": "",
    "text": "go test命令是一个按照一定约定和组织的测试代码驱动程序\n在包目录中，所有以_test.go结尾的源码文件都会被go test运行到\n我们写的 _test.go源码文件不用担心内容过多，因为go test命令不会将这些测试文件打包到最后的可执行文件\n\n\n在实际应用中，test文件有四类：\n1、Test开头的：功能测试\n2、Benchmark开头的：性能测试\n3、Example开头的：模糊测试\n4、TestMain开头的：单元测试\n\n\n\n下面举一个单元测试的例子：\n在包目录中有三个go文件，分别是：\n1、add.go\n2、add_test.go\n3、main.go\n\n在add.go中定义了一个Add函数，用来实现两个整数的相加：\n在add_test.go中首先导入”testing”包，然后定义了一个TestAdd函数，用来测试Add函数的正确性，并作出相应的出错处理：\nimport \"testing\"\n\nfunc TestAdd(t *testing.T){\n    re := add(1,2)\n    if re!= 3{\n        t.Errorf(\"add(1,2) = %d; want 3\", re)\n    }\n}\n之后对add_test.go文件执行go test命令，即可进行单元测试，查看测试结果\n\n\n\n\n在实际应用中，我们可能会遇到一些耗时的单元测试用例，我们可以使用t.Skip()函数来跳过这些耗时的单元测试用例\n在执行测试文件的过程中，使用 go test -short命令可以查看测试结果，其中 -short命令会跳过所有耗时的单元测试用例\n耗时的单元测试用例是有自己定义的\n\n下面是一个使用跳过单元测试的例子：\nfunc TestAdd(t *testing.T){\n    if testing.Short(){\n        t.Skip(\"skip this test\")\n    }\n    // 下面是执行不到的\n    re := add(1,2)\n    if re!= 3{\n        t.Errorf(\"add(1,2) = %d; want 3\", re)\n    }\n}\ntesting中的short相当于采用了两种模式，供用户选择。"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（13）.html#基于表格驱动测试",
    "href": "content/learning-notes/golang/entries/golang学习记录（13）.html#基于表格驱动测试",
    "title": "golang学习记录（13）",
    "section": "",
    "text": "在实际测试的的时候，测试用例可能不止一组，一个一个测试非常耗时，go中提供了一种基于表格驱动测试的方式，它可以一次性测试多组数据，提高测试效率\n\n下面是一个基于表格驱动测试的例子：\nimport \"testing\"\n\nfunc TestAdd(t *testing.T){\n    var tests = []struct{\n        a int\n        b int\n        want int\n    }{\n        {1,2,3},\n        {2,3,5},\n        {3,4,7},\n    }\n\n    for _, tt := range tests{\n        re := add(tt.a, tt.b)\n        if re!= tt.want{\n            t.Errorf(\"add(%d, %d) = %d; want %d\", tt.a, tt.b, re, tt.want)\n        }\n    }\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（13）.html#benchmark性能测试",
    "href": "content/learning-notes/golang/entries/golang学习记录（13）.html#benchmark性能测试",
    "title": "golang学习记录（13）",
    "section": "",
    "text": "在一些核心函数中对性能有要求，我们可以使用benchmark性能测试来测试函数的性能\n同样，性能测试函数也在”testing”包中\n在应用过程中，性能测试函数的命名必须以Benchmark开头，后面跟上要测试的函数名\n性能测试函数的参数必须是*testing.B类型的指针\n在执行测试文件的过程中，使用 go test -bench命令可以查看测试结果，其中 -bench命令会执行所有的性能测试用例\n\n下面是一个关于单元性能测试的例子：\nimport \"testing\"\n\nfunc BenchmarkAdd(b *testing.B){\n    a := 123\n    b := 456\n    c := 579\n\n\n    for i:=0; i&lt;b.N; i++{\n        if actual := add(a,b); actual!= c{\n            fmt.Printf(\"add(%d, %d) = %d; want %d\", a, b, actual, c)\n    }\n}\n在进行性能测试过沉重还有一个常用的函数：b.ResetTimer()，它可以重置计时器，使得测试结果更加准确"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（11）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（11）.html",
    "title": "golang学习记录（11）",
    "section": "",
    "text": "go语言中interface是一种非常重要的类型，是非常重要的组成部分\n\n\n\n\n鸭子类型\n当一只鸟走起来像鸭子，游泳起来像鸭子，叫起来也想鸭子，那这只鸟就是鸭子\n鸭子类型强调的是事物的方法，而不是内部的结构\n也就是说，只要一个对象实现了接口的所有方法，那么这个对象就可以被认为是实现了这个接口，就能将这个对象作为这个接口的实例\n\n\n\n\n\n接口的定义需要用到type和interface关键字，具体的定义格式如下：\n\ntype 接口名 interface{\n    方法名1(参数列表) 返回值列表\n    方法名2(参数列表) 返回值列表\n   ...\n}\n下面是一个例子：\ntype Duck interface{\n    Gaga()\n    Walk()\n    Swimming()\n}\n\ntype pskDuck struct{\n    legs int\n}\n\nfunc (pd *pskDuck) Gaga(){\n    fmt.Println(\"嘎嘎嘎\")\n}\n\nfunc (pd *pskDuck) Walk(){\n    fmt.Println(\"走\")\n}\n\nfunc (pd *pskDuck) Swimming(){\n    fmt.Println(\"游泳\")\n}\n\nfunc main(){\n    var duck Duck = &pskDuck{}\n    duck.Gaga()\n    duck.Walk()\n    duck.Swimming()\n}\n\n\n\n\n在实际的应用场景中，接口不应该写的太大，一般一个接口只实现一个方法\n\ntype Duck interface{\n    Gaga()\n}\n\ntype Duck2 interface{\n    Walk()\n}\n\ntype Duck3 interface{\n    Swimming()\n}\n\ntype pskDuck struct{}\n、\nfunc (pd *pskDuck) Gaga(){\n    fmt.Println(\"嘎嘎嘎\")\n}\n\nfunc (pd *pskDuck) Walk(){\n    fmt.Println(\"走\")\n}\n\nfunc (pd *pskDuck) Swimming(){\n    fmt.Println(\"游泳\")\n}\n\nfunc main(){\n    var duck Duck = &pskDuck{}\n    var duck2 Duck2 = &pskDuck{}\n}\n\n在上面的例子中，pskDuck实现了Duck、Duck2、Duck3三个接口，但是在main函数中，只声明了Duck接口，但是却可以将pskDuck的实例赋值给Duck接口，这是因为pskDuck实现了Duck接口的所有方法，所以可以将pskDuck的实例赋值给Duck接口\n接口也可以作为结构体的参数\n接口的使用非常灵活\n代码的解耦\n一个类型实现多个接口。一个接口实现多个类型\n……\n\n\n\n\n\n断言\n\n举个例子，做一个加法计算器：\nfunc add(a, b interface{}) interface{}{\n    switch a.(type){\n    case int:\n        ai, _ := a.(int)\n        bi, _ := b.(int)\n        return ai + bi\n\n    case int32:\n        ai, _ := a.(int32)\n        bi, _ := b.(int32)\n        return ai + bi\n    \n\n    case float32:\n        ai, _ := a.(float32)\n        bi, _ := b.(float32)\n        return ai + bi\n    \n    //……\n\n    default:\n        return 0\n    }\n}\n\n\nfunc main(){\n    fmt.Println(add(1, 2))\n    fmt.Println(add(1, 3))\n    fmt.Println(add(1.0, 2.0))\n}\n\n\n\n\n接口嵌套达到代码复用的目的\n\ntype MyWriter interface{\n    Write(string)\n}\n\ntype MyReader interface{\n    Reader() string\n}\n\ntype MyReaderWriter interface{\n    MyReader\n    MyWriter\n    ReadWriter()\n}\n\ntype SreadWriter struct{}\n\nfunc (srw *SreadWriter) Read(){\n    fmt.Println(\"read\")\n}\n\nfunc (srw *SreadWriter) Write(){\n    fmt.Println(\"write\")\n}\n\nfunc (srw *SreadWriter) ReadWriter(){\n    fmt.Println(\"readWriter\")\n}\n\nfunc main(){\n    var mrw MyReaderWriter = &SreadWriter{}\n    mrw.Read()\n\n}\n\n\n\n\nslice不能作为接口的参数，因为slice是一个引用类型，但是接口是一个值类型，所以不能将slice作为接口的参数，但是可以将slice的指针作为接口的参数\n\nfunc mPrint(data ... interface{}){\n    for _, value := range data{\n        fmt.Println(value)\n    }\n}\n\nfunc main(){\n    //这样是支持的\n    var data = []interface{}{\n        \"aaaaa\",\n        19,\n        1800.00,\n    }\n    mPrint(data...)\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（11）.html#鸭子类型",
    "href": "content/learning-notes/golang/entries/golang学习记录（11）.html#鸭子类型",
    "title": "golang学习记录（11）",
    "section": "",
    "text": "鸭子类型\n当一只鸟走起来像鸭子，游泳起来像鸭子，叫起来也想鸭子，那这只鸟就是鸭子\n鸭子类型强调的是事物的方法，而不是内部的结构\n也就是说，只要一个对象实现了接口的所有方法，那么这个对象就可以被认为是实现了这个接口，就能将这个对象作为这个接口的实例"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（11）.html#接口的定义",
    "href": "content/learning-notes/golang/entries/golang学习记录（11）.html#接口的定义",
    "title": "golang学习记录（11）",
    "section": "",
    "text": "接口的定义需要用到type和interface关键字，具体的定义格式如下：\n\ntype 接口名 interface{\n    方法名1(参数列表) 返回值列表\n    方法名2(参数列表) 返回值列表\n   ...\n}\n下面是一个例子：\ntype Duck interface{\n    Gaga()\n    Walk()\n    Swimming()\n}\n\ntype pskDuck struct{\n    legs int\n}\n\nfunc (pd *pskDuck) Gaga(){\n    fmt.Println(\"嘎嘎嘎\")\n}\n\nfunc (pd *pskDuck) Walk(){\n    fmt.Println(\"走\")\n}\n\nfunc (pd *pskDuck) Swimming(){\n    fmt.Println(\"游泳\")\n}\n\nfunc main(){\n    var duck Duck = &pskDuck{}\n    duck.Gaga()\n    duck.Walk()\n    duck.Swimming()\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（11）.html#多接口实现",
    "href": "content/learning-notes/golang/entries/golang学习记录（11）.html#多接口实现",
    "title": "golang学习记录（11）",
    "section": "",
    "text": "在实际的应用场景中，接口不应该写的太大，一般一个接口只实现一个方法\n\ntype Duck interface{\n    Gaga()\n}\n\ntype Duck2 interface{\n    Walk()\n}\n\ntype Duck3 interface{\n    Swimming()\n}\n\ntype pskDuck struct{}\n、\nfunc (pd *pskDuck) Gaga(){\n    fmt.Println(\"嘎嘎嘎\")\n}\n\nfunc (pd *pskDuck) Walk(){\n    fmt.Println(\"走\")\n}\n\nfunc (pd *pskDuck) Swimming(){\n    fmt.Println(\"游泳\")\n}\n\nfunc main(){\n    var duck Duck = &pskDuck{}\n    var duck2 Duck2 = &pskDuck{}\n}\n\n在上面的例子中，pskDuck实现了Duck、Duck2、Duck3三个接口，但是在main函数中，只声明了Duck接口，但是却可以将pskDuck的实例赋值给Duck接口，这是因为pskDuck实现了Duck接口的所有方法，所以可以将pskDuck的实例赋值给Duck接口\n接口也可以作为结构体的参数\n接口的使用非常灵活\n代码的解耦\n一个类型实现多个接口。一个接口实现多个类型\n……"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（11）.html#接口与动态类型传参",
    "href": "content/learning-notes/golang/entries/golang学习记录（11）.html#接口与动态类型传参",
    "title": "golang学习记录（11）",
    "section": "",
    "text": "断言\n\n举个例子，做一个加法计算器：\nfunc add(a, b interface{}) interface{}{\n    switch a.(type){\n    case int:\n        ai, _ := a.(int)\n        bi, _ := b.(int)\n        return ai + bi\n\n    case int32:\n        ai, _ := a.(int32)\n        bi, _ := b.(int32)\n        return ai + bi\n    \n\n    case float32:\n        ai, _ := a.(float32)\n        bi, _ := b.(float32)\n        return ai + bi\n    \n    //……\n\n    default:\n        return 0\n    }\n}\n\n\nfunc main(){\n    fmt.Println(add(1, 2))\n    fmt.Println(add(1, 3))\n    fmt.Println(add(1.0, 2.0))\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（11）.html#接口嵌套",
    "href": "content/learning-notes/golang/entries/golang学习记录（11）.html#接口嵌套",
    "title": "golang学习记录（11）",
    "section": "",
    "text": "接口嵌套达到代码复用的目的\n\ntype MyWriter interface{\n    Write(string)\n}\n\ntype MyReader interface{\n    Reader() string\n}\n\ntype MyReaderWriter interface{\n    MyReader\n    MyWriter\n    ReadWriter()\n}\n\ntype SreadWriter struct{}\n\nfunc (srw *SreadWriter) Read(){\n    fmt.Println(\"read\")\n}\n\nfunc (srw *SreadWriter) Write(){\n    fmt.Println(\"write\")\n}\n\nfunc (srw *SreadWriter) ReadWriter(){\n    fmt.Println(\"readWriter\")\n}\n\nfunc main(){\n    var mrw MyReaderWriter = &SreadWriter{}\n    mrw.Read()\n\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（11）.html#接口与slice常见的错误",
    "href": "content/learning-notes/golang/entries/golang学习记录（11）.html#接口与slice常见的错误",
    "title": "golang学习记录（11）",
    "section": "",
    "text": "slice不能作为接口的参数，因为slice是一个引用类型，但是接口是一个值类型，所以不能将slice作为接口的参数，但是可以将slice的指针作为接口的参数\n\nfunc mPrint(data ... interface{}){\n    for _, value := range data{\n        fmt.Println(value)\n    }\n}\n\nfunc main(){\n    //这样是支持的\n    var data = []interface{}{\n        \"aaaaa\",\n        19,\n        1800.00,\n    }\n    mPrint(data...)\n}"
  },
  {
    "objectID": "content/learning-notes/deepL/entries/通过案例了解机器学习.html",
    "href": "content/learning-notes/deepL/entries/通过案例了解机器学习.html",
    "title": "通过案例了解机器学习",
    "section": "",
    "text": "A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E.\n\n基础概念\n近些年，人工智能飞速发展，我们经常听到人工智能、机器学习、深度学习和强化学习等名词。事实上，它们之间存在着密切的联系。\n\n人工智能\n人工智能（Artificial Intelligence, AI）是一个广泛的领域，可以从“能力”和“学科”两个方面对人工智能进行定义。从能力的角度看，人工智能是指用人工的方法在机器上实现的智能；从学科角度看，人工智能是一门研究如何构造智能机器或智能系统，使其能模拟、延伸和扩展人类智能的学科。\n\n\n机器学习\n机器学习（Machine Learning, ML）是AI的一个子集，它专注于开发算法和统计模型。机器学习是指在不需要明确编程的情况下，让计算机能够利用数据提高在某个任务上表现的算法。机器学习又可以分为监督学习、无监督学习、半监督学习和强化学习等。\n\n\n深度学习\n深度学习（Deep Learning, DL）是机器学习的一个子领域，它使用类似于人脑的神经网络结构，特别是具有多个层的深层神经网络，来学习复杂的模式和表示。\n\n\n强化学习\n强化学习（Reinforcement Learning, RL）是机器学习的一个分支，它专注于如何让智能体（agent）通过与环境的交互来学习最佳行为或策略，以最大化某种累积奖励。\n\n\n深度强化学习\n深度强化学习（Deep Reinforcement Learning, DRL）是深度学习和强化学习的结合，它使用深度神经网络作为智能体的大脑，以处理高维度的输入数据并学习复杂的策略。\n它们的关系可以大致总结为下图： \n\n\n\n课程基础\n\n机器学习\n机器学习最重要的是寻找到一个函数，让机器具备找到一个函数的能力。\n通常情况下，函数是非常复杂的，人难以自己写出，若是通过机器的力量自己找出有很多优势。\n机器学习寻找的函数通常是不同的，根据实际需求可以分成回归、分类和结构化学习等。\n\n\n回归（regression）\n假设要找的函数输出的是一个数值，或者称为一个标量（scalar），这种机器学习的任务称为回归。（根据历史数据和指标预测未来的一个数值）\n回归问题中，比较经典的是房价预测问题，这个问题在很多教程中都被作为例子，在Kaggle中可以进行实践。\n\n\n分类（classification）\n分类任务是让机器做选择题，函数的输出是从设定好的选项中选出一个选项当作输出。通常，在确定选项的过程中会牵扯到概率的计算，根据概率判断最可能的选项，常见的分类算法中都有概率的影子，个人感觉人工智能技术的发展确实离不开数学的支持。\n在分类问题中，比较常见的就是垃圾邮件判断的例子，判断邮件是否为垃圾邮件，这是一个二分类问题，除此之外还有多分类，AlphaGo下围棋就是从棋盘中找到最正确的选项，还有动物识别（猫、狗、鸟……）。\n\n\n结构化学习（structed learning）\n在这种情况下，机器学习并不只是要做出选择或者输出一个数字，而是要产生一个有结构的物体，比如画一张图、写一篇文章……近些年也逐渐得到更多应用。 在其他学习群里看到过一张有意思的图： \n结构化学习仍需要我们去探索。\n\n\n\n案例学习\n\n已有的数据是youtube后以往的信息，想要得到的明天可能观看的次数是多少 通过一个函数来实现这个过程\n\n机器学习找函数的过程\n1、写出一个带有未知参数的函数（这个函数基于我们的知识积累设置，这只是一个猜测），这个函数能够预测未来观看的次数\n\\[\ny=b+wx_1\n\\]\n\n其中\\(y\\)表示要预测的观看次数，\\(x_1\\) 表示前一天的观看人数\n\\(w\\)和\\(b\\)都表示未知的参数，都需要让机器从数据中学习\n\n2、定义损失函数（loss function）\n损失函数就是：在当前参数组合下，所有数据误差和的平均值（个人理解），公式如下：\n\\[  L= \\frac{1}{N} \\sum_n^{i=1} e_n \\]\n\n其中\\(e\\)表示误差\n可以采用预测值与目标值之间差的绝对值：\\(e = \\vert y - \\hat{y} \\vert\\)\n也可以采用差的平方: \\(e=(y-\\hat{y})^2\\)\n\n\n当采用绝对值，称为MAE（Mean Absolute Error）\n当采用平方，称为MSE（Mean Squared Error）\n\n除了上述的两种方式，还有一种计算loss的方式称为“交叉熵”\n计算的损失函数可以通过可视化方式呈现，如：热力图、等高线图……。下面是课程中采用的示例： \n3、优化（Optimization）\n优化的目的是让损失函数的值最小，如下公式：\n\\[\nw^*,b^*=min_{w,b}L\n\\]\n\n我们要找到让损失函数值最小的未知参数组合。\n\n常用的方式是梯度下降（gradient descent），通过梯度下降进行参数优化的过程如图： \n其中有几个非常重要的概念：\n斜率：斜率大于0表示loss在上升，斜率小于0表示loss在下降，等于0表示到达了一个极值点。\n学习率（learning rate)：\\(\\eta\\)可以理解为跨一步的大小，\\(\\eta\\)越高，跨一步越大，反之越小。\\(\\eta\\)可以经验决定。\n超参数（hyperparameter)：在机器学习过程中需要人为预先设定的参数。\n还有一个重要的点是关于\\(w\\)的更新： \\[\nw^1 \\leftarrow w^0 - \\eta \\frac{\\partial{l}}{\\partial{w}}\\vert_{w=w^0}\n\\]\n随着\\(w\\)的不断更新，理想状态下loss的斜率会成为0，如下图所示 \n当\\(w=w^T\\)时，斜率为0，当时此时loss并不是最低的\nlocal minima：局部最小\nglobal minima：全局最小\n\n在上图中，一个有意的现象，loss有负值，为什么loss可以是负的？\n因为loss是可以自己定义的，用上边的绝对值和平方计算肯定是正值，但是如果自己定义不同的方式可以是负值。\n\n4、最后\n找到合适的模型要观察数据、理解数据并进行试验，根据结果更新模型。"
  },
  {
    "objectID": "content/learning-notes/algorithm/entries/不定长滑动窗口-越长越合法+求最短+最小.html",
    "href": "content/learning-notes/algorithm/entries/不定长滑动窗口-越长越合法+求最短+最小.html",
    "title": "leetcode-灵神跟练-滑动窗口与双指针-不定长滑动窗口-越长越合法+求最短+最小",
    "section": "",
    "text": "定长滑动窗口-越长越合法/求最短/最小\n\n209. 长度最小的子数组\n\n题面\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n示例 1：\n输入：target = 7, nums = [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n示例 2：\n输入：target = 4, nums = [1,4,4]\n输出：1\n示例 3：\n输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n输出：0\n提示：\n1 &lt;= target &lt;= 10^9\n1 &lt;= nums.length &lt;= 10^5\n1 &lt;= nums[i] &lt;= 10^4\n\n\n思路说明\n采用双指针变长滑动窗口的思路\n设定左指针，控制窗口大小，遍历数组的index作为右指针\n设置变量统计窗口内的数字和\n当数字和达到要求的时候 - 采用while循环 - 更新字数组的最小值 - 将左边的值排除窗口，更新数字和，同时将左指针向右移动 - 直到数字和不满足要求结束循环\n\n\n题解\n\n// 209.长度最小的子数组\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc minSubArrayLen(target int, nums []int) int {\n    ans, left := math.MaxInt, 0\n    cnt := 0\n\n    for i, num := range nums {\n        cnt += num\n        for cnt &gt;= target {\n            ans = min(ans, i-left+1)\n            cnt -= nums[left]\n            left += 1\n        }\n    }\n\n    if ans &gt; len(nums) {\n        return 0\n    } else {\n        return ans\n    }\n}\n\nfunc main() {\n    testCases := []struct {\n        nums   []int\n        target int\n    }{\n        {[]int{2, 3, 1, 2, 4, 3}, 7},\n        {[]int{1, 4, 4}, 4},\n        {[]int{1, 1, 1, 1, 1, 1, 1, 1}, 11},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(minSubArrayLen(testCase.target, testCase.nums))\n    }\n}\n\n\n\n\n2904. 最短且字典序最小的美丽子字符串\n\n题面\n给你一个二进制字符串 s 和一个正整数 k 。\n如果 s 的某个子字符串中 1 的个数恰好等于 k ，则称这个子字符串是一个 美丽子字符串 。\n令 len 等于 最短 美丽子字符串的长度。\n返回长度等于 len 且字典序 最小 的美丽子字符串。如果 s 中不含美丽子字符串，则返回一个 空 字符串。\n对于相同长度的两个字符串 a 和 b ，如果在 a 和 b 出现不同的第一个位置上，a 中该位置上的字符严格大于 b 中的对应字符，则认为字符串 a 字典序 大于 字符串 b 。\n例如，“abcd” 的字典序大于 “abcc” ，因为两个字符串出现不同的第一个位置对应第四个字符，而 d 大于 c 。\n示例 1：\n输入：s = “100011001”, k = 3\n输出：“11001”\n解释：示例中共有 7 个美丽子字符串：\n\n子字符串 “100011001” 。\n子字符串 “100011001” 。\n子字符串 “100011001” 。\n子字符串 “100011001” 。\n子字符串 “100011001” 。\n子字符串 “100011001” 。\n子字符串 “100011001” 。\n\n最短美丽子字符串的长度是 5 。\n长度为 5 且字典序最小的美丽子字符串是子字符串 “11001” 。\n示例 2：\n输入：s = “1011”, k = 2\n输出：“11”\n解释：示例中共有 3 个美丽子字符串： 1. 子字符串 “1011” 。 2. 子字符串 “1011” 。 3. 子字符串 “1011” 。\n最短美丽子字符串的长度是 2 。\n长度为 2 且字典序最小的美丽子字符串是子字符串 “11” 。\n示例 3：\n输入：s = “000”, k = 1\n输出：“”\n解释：示例中不存在美丽子字符串。\n提示：\n1 &lt;= s.length &lt;= 100\n1 &lt;= k &lt;= s.length\n\n\n思路说明\n我们要做的是找到一个子字符串，子字符串中1的数量为看，如果有多个答案，返回字典序最小的那个\n首先根据题目，当字符串中1的数量小于k的时候，会返回空字符串，直接返回\n然后初始化结果ans为输入字符串s，因为最差的结果就是s，所以设置为s\n之后设置cnt表示窗口内1的数量，left表示窗口的左边界，用循环的index表示右边界\n每次移动右边界之后 - 判断窗口内1的数量是不是达到要求 - 如果达到了，开始移动左边界，直到把最左边的1排出 - 这个过程中，左边可能有很多0，排出之后会减小子字符串的长度，所以不断更新子字符串以及左边界，这是还要注意子字符串长度相同选最小字典序的情况 - 这个过程通过while循环实现\n\n\n题解\n\n// 2904.最短且字典序最小的美丽子字符串\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc shortestBeautifulSubstring(s string, k int) string {\n    if strings.Count(s, \"1\") &lt; k {\n        return \"\"\n    }\n    ans := s\n    cnt, left := 0, 0\n\n    for i, ch := range s {\n        if ch == '1' {\n            cnt += 1\n        }\n\n        for cnt &gt;= k {\n            tmp := s[left : i+1]\n            if s[left] == '1' {\n                cnt -= 1\n            }\n            left += 1\n            if len(tmp) == len(ans) {\n                if tmp &lt; ans {\n                    ans = tmp\n                }\n            }\n            if len(tmp) &lt; len(ans) {\n                ans = tmp\n            }\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        s string\n        k int\n    }{\n        {\"100011001\", 3},\n        {\"1011\", 2},\n        {\"000\", 1},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(shortestBeautifulSubstring(testCase.s, testCase.k))\n    }\n}\n\n\n\n\n1234. 替换子串得到平衡字符串\n\n题面\n有一个只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符，且长度为 n 的字符串。\n假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。\n给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。\n你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。\n请返回待替换子串的最小可能长度。\n如果原字符串自身就是一个平衡字符串，则返回 0。\n示例 1：\n输入：s = “QWER”\n输出：0\n解释：s 已经是平衡的了。\n示例 2：\n输入：s = “QQWE”\n输出：1\n解释：我们需要把一个 ‘Q’ 替换成 ‘R’，这样得到的 “RQWE” (或 “QRWE”) 是平衡的。\n示例 3：\n输入：s = “QQQW”\n输出：2\n解释：我们可以把前面的 “QQ” 替换成 “ER”。\n示例 4：\n输入：s = “QQQQ”\n输出：3\n解释：我们可以替换后 3 个 ‘Q’，使 s = “QWER”。\n提示：\n1 &lt;= s.length &lt;= 10^5\ns.length 是 4 的倍数\ns 中只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符\n\n\n思路说明\n构建一个最小窗口，让窗口外的每种字符数量尽量接近n，这个最小窗口就是需要替换的字符串\n通过哈希表统计每种字符的数量\n\n\n题解\n\n// 1234.替换子串得到平衡字符串\npackage main\n\nimport \"fmt\"\n\nfunc balancedString(s string) int {\n    // 构建哈希表，统计各自的数量\n    // 构建一个最小窗口，让窗口外的每种字符数量尽量接近n，这个最小窗口就是需要替换的字符串\n    mp := make(map[byte]int, 4)\n    n := len(s) / 4\n\n    for i := 0; i &lt; len(s); i++ {\n        mp[s[i]] += 1\n    }\n\n    // 已经平衡，返回0\n    if mp['Q'] == n && mp['W'] == n && mp['E'] == n && mp['R'] == n {\n        return 0\n    }\n\n    ans, left := len(s), 0\n\n    for i := 0; i &lt; len(s); i++ {\n        mp[s[i]] -= 1 // 放进窗口\n        for mp['Q'] &lt;= n && mp['W'] &lt;= n && mp['E'] &lt;= n && mp['R'] &lt;= n {\n            // 满足条件，记录并收缩\n            ans = min(ans, i-left+1)\n            mp[s[left]] += 1\n            left += 1\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []string{\n        \"QWER\",\n        \"QQWE\",\n        \"QQQW\",\n        \"QQQQ\",\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(balancedString(testCase))\n    }\n}\n\n\n\n\n2875. 无限数组的最短子数组\n\n题面\n给你一个下标从 0 开始的数组 nums 和一个整数 target 。\n下标从 0 开始的数组 infinite_nums 是通过无限地将 nums 的元素追加到自己之后生成的。\n请你从 infinite_nums 中找出满足 元素和 等于 target 的 最短 子数组，并返回该子数组的长度。如果不存在满足条件的子数组，返回 -1 。\n示例 1：\n输入：nums = [1,2,3], target = 5\n输出：2\n解释：在这个例子中 infinite_nums = [1,2,3,1,2,3,1,2,…] 。\n区间 [1,2] 内的子数组的元素和等于 target = 5 ，且长度 length = 2 。\n可以证明，当元素和等于目标值 target = 5 时，2 是子数组的最短长度。\n示例 2：\n输入：nums = [1,1,1,2,3], target = 4\n输出：2\n解释：在这个例子中 infinite_nums = [1,1,1,2,3,1,1,1,2,3,1,1,…].\n区间 [4,5] 内的子数组的元素和等于 target = 4 ，且长度 length = 2 。\n可以证明，当元素和等于目标值 target = 4 时，2 是子数组的最短长度。\n示例 3：\n输入：nums = [2,4,6,8], target = 3\n输出：-1\n解释：在这个例子中 infinite_nums = [2,4,6,8,2,4,6,8,…] 。\n可以证明，不存在元素和等于目标值 target = 3 的子数组。\n提示：\n1 &lt;= nums.length &lt;= 10^5\n1 &lt;= nums[i] &lt;= 10^5\n1 &lt;= target &lt;= 10^9\n\n\n思路说明\n使用的nuns的数量是不不定的，可能是1-n个，但是可以观察到，如果使用n个，中间n-2个是完整的，左边nums和右边nums，分别取右边和左边连续的数据\n设 nums的数据和事total\ntarget = total*m + res\nres = nums*2[i:j]\n我们要做的就是找到res的长度\nres = target & total\n其他的按照固定步骤做即可\n\n\n题解\n\n// 2875.无限数组的最短子数组\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc minSizeSubarray(nums []int, target int) int {\n    total := 0\n    for _, x := range nums {\n        total += x\n    }\n\n    ans := math.MaxInt\n    left, sum, n := 0, 0, len(nums)\n    for right := 0; right &lt; n*2; right++ {\n        sum += nums[right%n]\n        for sum &gt; target%total {\n            sum -= nums[left%n]\n            left++\n        }\n        if sum == target%total {\n            ans = min(ans, right-left+1)\n        }\n    }\n    if ans == math.MaxInt {\n        return -1\n    }\n    return ans + target/total*n\n}\n\nfunc main() {\n    testCases := []struct {\n        nums   []int\n        target int\n    }{\n        {[]int{1, 2, 3}, 5},\n        {[]int{1, 1, 1, 2, 3}, 4},\n        {[]int{2, 4, 6, 8}, 3},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(minSizeSubarray(testCase.nums, testCase.target))\n    }\n}\n\n\n\n\n76. 最小覆盖子串\n\n题面\n给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。\n注意：\n对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。\n如果 s 中存在这样的子串，我们保证它是唯一的答案。\n示例 1：\n输入：s = “ADOBECODEBANC”, t = “ABC”\n输出：“BANC”\n解释：最小覆盖子串 “BANC” 包含来自字符串 t 的 ‘A’、‘B’ 和 ‘C’。\n示例 2：\n输入：s = “a”, t = “a”\n输出：“a”\n解释：整个字符串 s 是最小覆盖子串。\n示例 3:\n输入: s = “a”, t = “aa”\n输出: “”\n解释: t 中两个字符 ‘a’ 均应包含在 s 的子串中，\n因此没有符合条件的子字符串，返回空字符串。\n提示：\nm == s.length\nn == t.length\n1 &lt;= m, n &lt;= 10^5\ns 和 t 由英文字母组成\n\n\n思路说明\n先说一下题目的要求，找到s的子串，子串包含t中所有字符（种类和数量）\n首先，我们要知道t中有哪些字符\n然后，在s中找到子串，子串中包含t中所有种类字符，这个子串尽可能小\n所以使用哈希表统计t中所有字符种类和数量\n然后在s中找子串，如果子串中字符在哈希表中，就减去，如果哈希表全部变成0，表示子串中已经包含t中全部字符，然后缩小窗口，直到不满足要求\n\n\n题解\n\n// 76.最小覆盖子串\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc minWindow(s string, t string) string {\n    // 先统计一下t中各个字符的数量,统计一下字符的种类\n    mp := make(map[byte]int)\n\n    for i := 0; i &lt; len(t); i++ {\n        mp[t[i]] += 1\n    }\n    left := 0\n    cnt := len(mp) // 字符的种类\n    ans := \"\"\n    tmp := math.MaxInt\n\n    for i := 0; i &lt; len(s); i++ {\n        if _, ok := mp[s[i]]; ok { // 字符有效\n            mp[s[i]] -= 1\n            if mp[s[i]] == 0 { // 符合要求\n                cnt -= 1\n            }\n        }\n\n        for cnt == 0 { // 子串中已经满足要求，缩小子串范围\n            if tmp &gt; i-left+1 {\n                tmp = i - left + 1\n                ans = s[left : i+1]\n            }\n            if _, ok := mp[s[left]]; ok { // 字符有效\n                mp[s[left]] += 1\n                if mp[s[left]] == 1 { // 符合要求\n                    cnt += 1\n                }\n            }\n            left += 1\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        s string\n        t string\n    }{\n        {\"ADOBECODEBANC\", \"ABC\"},\n        {\"a\", \"a\"},\n        {\"a\", \"aa\"},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(minWindow(testCase.s, testCase.t))\n    }\n}\n\n\n\n\n632. 最小区间\n\n题面\n你有 k 个 非递减排列 的整数列表。找到一个 最小 区间，使得 k 个列表中的每个列表至少有一个数包含在其中。\n我们定义如果 b-a &lt; d-c 或者在 b-a == d-c 时 a &lt; c，则区间 [a,b] 比 [c,d] 小。\n示例 1：\n输入：nums = [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]\n输出：[20,24]\n解释：\n列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。\n列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。\n列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。\n示例 2：\n输入：nums = [[1,2,3],[1,2,3],[1,2,3]]\n输出：[1,1]\n提示：\nnums.length == k\n1 &lt;= k &lt;= 3500\n1 &lt;= nums[i].length &lt;= 50\n-105 &lt;= nums[i][j] &lt;= 10^5\nnums[i] 按非递减顺序排列\n\n\n思路说明\n构建pair，包含数字和位置，然后排序，构建一个滑动窗口，窗口包含所有index并且窗口最小\n\n\n题解\n\n// 632.最小区间\npackage main\n\nimport (\n    \"fmt\"\n    \"slices\"\n)\n\nfunc smallestRange(nums [][]int) []int {\n    type pair struct{ x, i int } // 数字和他们所在的位置\n    pairs := []pair{}\n\n    for i, arr := range nums {\n        for _, num := range arr {\n            pairs = append(pairs, pair{num, i})\n        }\n    }\n\n    slices.SortFunc(pairs, func(a, b pair) int { return a.x - b.x })\n\n    ansL, ansR := pairs[0].x, pairs[len(pairs)-1].x\n    mp := make(map[int]int)\n    left := 0\n\n    for _, p := range pairs {\n        r, i := p.x, p.i\n        mp[i] += 1\n\n        for len(mp) == len(nums) { // 每个列表都至少包含一个数\n            l, i := pairs[left].x, pairs[left].i\n            if r-l &lt; ansR-ansL {\n                ansL, ansR = l, r\n            }\n            mp[i] -= 1\n            if mp[i] == 0 {\n                delete(mp, i)\n            }\n            left += 1\n        }\n    }\n    return []int{ansL, ansR}\n}\n\nfunc main() {\n    testCases := [][][]int{\n        [][]int{\n            []int{4, 10, 15, 24, 26},\n            []int{0, 9, 12, 20},\n            []int{5, 18, 22, 30},\n        },\n        [][]int{\n            []int{1, 2, 3},\n            []int{1, 2, 3},\n            []int{1, 2, 3},\n        },\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(smallestRange(testCase))\n    }\n}"
  },
  {
    "objectID": "content/blogs/entries/本地服务器低速传输解决方案.html",
    "href": "content/blogs/entries/本地服务器低速传输解决方案.html",
    "title": "本地服务器低速传输解决方案",
    "section": "",
    "text": "最近在给一台远程 Linux 服务器部署项目，遇到在一个极其离谱的网络环境：\n\n文件很大：代码加数据包足足有 6.7GB。\n网络极差：本地 Mac 与服务器之间的 Ping 值高达 700ms+，且伴随严重丢包。\n速度感人：尝试使用 scp 或 rsync 直传，速度稳定在 40KB/s…… 传完预计需要 40 个小时，而且随时会断开。\n\n但在排查过程中发现，服务器本身的下行带宽其实并不差（Speedtest 实测有 70Mbps），瓶颈在于“我与服务器之间”那条拥堵的链路，导致 TCP 协议的滑动窗口崩溃，速度上不去。\n解决思路： 既然直连不行，那就找个“中转站”。利用百度网盘（配合 SVIP）作为高速桥梁，并在 Linux 服务器上通过命令行工具跑满带宽下载。\n本文将介绍一套 bypy + aria2 多线程下载 的终极解决方案。\n\n\n\n\n\n速度快：利用百度网盘的 CDN 和服务器自身的带宽，避开点对点拥堵。但是要有百度网盘的会员才能享受高速下载。\n稳定：aria2 支持多线程并发和断点续传，搞定大文件。\n\n\n\n\n\n\n\n压缩： 先将项目文件夹压缩成 zip 包。可以在终端执行：\nzip -r project.zip project_folder\n上传： 打开百度网盘客户端，将 project.zip 上传到网盘 /apps/bypy/ 目录下，方便后续操作。\n\n\n\n\n登录你的远程 Linux 服务器。我们需要安装两个工具：\n\nbypy：百度网盘的 Python 客户端。\naria2：多线程下载神器（关键！没有它大文件会卡死）。\n\n如果你有 conda 环境（终端显示 (base)），安装非常简单：\n# 1. 安装 bypy\npip install bypy\n\n# 2. 安装 aria2\nconda install -c conda-forge aria2\n# 或者\napt-get install aria2  # 如果你有 root 权限\n验证安装： 输入 aria2c -v，如果能看到版本号说明安装成功。\n\n\n\n\n在服务器终端输入：\nbypy info\n\n终端会显示一个长链接。\n复制这个链接，在本地浏览器打开。\n登录百度账号，复制网页上显示的授权码。\n回到服务器终端，粘贴授权码并回车。\n\n显示容量信息即表示绑定成功。\n\n\n\n\nbypy 默认使用的是 Python 单线程下载，遇到几个 G 的大文件经常会**“起步快，然后迅速掉速直到卡死（0%不动）”**。\n必须挂载 aria2 进行多线程拉取。\n请执行以下命令：\n# --downloader aria2: 指定使用 aria2 下载器\n# --processes 4: 开启 4 线程并发（跑满带宽）\n# --timeout 600: 增加超时容忍度，防止网络波动中断\n\nbypy --downloader aria2 --processes 4 --timeout 600 download project.enc\n效果对比：\n\n普通下载：200KB/s -&gt; 0KB/s (卡死)。\nAria2 下载：[#20a9c1 1.2GiB/6.2GiB(19%) CN:4 DL:5.2MiB] -&gt; 5.2MB/s 稳定跑满！\n\n\n\n\n\n下载完成后，你得到了 project.zip。现在用同样的密码把它变回 zip 包。\n# 解压\nunzip project.zip\n\n\n\n\n\n当 SSH 链路质量极差时，不要死磕 SCP 或 Rsync。\n“本地压缩 -&gt; 网盘中转 -&gt; Aria2 多线程拉取” 是一条虽然步骤稍多，但绝对可行、安全且高速的路径。特别是对于几个 G 的代码或模型权重文件，这是最节省时间的选择。\n\n小贴士： 如果你的文件不在 /apps/bypy/ 目录下，记得在网盘网页端把文件移动进去，否则 bypy 可能找不到文件(apps文件夹名称可能是中文，注意识别)。"
  },
  {
    "objectID": "content/blogs/entries/本地服务器低速传输解决方案.html#前言绝望的-50kbs",
    "href": "content/blogs/entries/本地服务器低速传输解决方案.html#前言绝望的-50kbs",
    "title": "本地服务器低速传输解决方案",
    "section": "",
    "text": "最近在给一台远程 Linux 服务器部署项目，遇到在一个极其离谱的网络环境：\n\n文件很大：代码加数据包足足有 6.7GB。\n网络极差：本地 Mac 与服务器之间的 Ping 值高达 700ms+，且伴随严重丢包。\n速度感人：尝试使用 scp 或 rsync 直传，速度稳定在 40KB/s…… 传完预计需要 40 个小时，而且随时会断开。\n\n但在排查过程中发现，服务器本身的下行带宽其实并不差（Speedtest 实测有 70Mbps），瓶颈在于“我与服务器之间”那条拥堵的链路，导致 TCP 协议的滑动窗口崩溃，速度上不去。\n解决思路： 既然直连不行，那就找个“中转站”。利用百度网盘（配合 SVIP）作为高速桥梁，并在 Linux 服务器上通过命令行工具跑满带宽下载。\n本文将介绍一套 bypy + aria2 多线程下载 的终极解决方案。"
  },
  {
    "objectID": "content/blogs/entries/本地服务器低速传输解决方案.html#方案优势",
    "href": "content/blogs/entries/本地服务器低速传输解决方案.html#方案优势",
    "title": "本地服务器低速传输解决方案",
    "section": "",
    "text": "速度快：利用百度网盘的 CDN 和服务器自身的带宽，避开点对点拥堵。但是要有百度网盘的会员才能享受高速下载。\n稳定：aria2 支持多线程并发和断点续传，搞定大文件。"
  },
  {
    "objectID": "content/blogs/entries/本地服务器低速传输解决方案.html#操作全流程",
    "href": "content/blogs/entries/本地服务器低速传输解决方案.html#操作全流程",
    "title": "本地服务器低速传输解决方案",
    "section": "",
    "text": "压缩： 先将项目文件夹压缩成 zip 包。可以在终端执行：\nzip -r project.zip project_folder\n上传： 打开百度网盘客户端，将 project.zip 上传到网盘 /apps/bypy/ 目录下，方便后续操作。\n\n\n\n\n登录你的远程 Linux 服务器。我们需要安装两个工具：\n\nbypy：百度网盘的 Python 客户端。\naria2：多线程下载神器（关键！没有它大文件会卡死）。\n\n如果你有 conda 环境（终端显示 (base)），安装非常简单：\n# 1. 安装 bypy\npip install bypy\n\n# 2. 安装 aria2\nconda install -c conda-forge aria2\n# 或者\napt-get install aria2  # 如果你有 root 权限\n验证安装： 输入 aria2c -v，如果能看到版本号说明安装成功。\n\n\n\n\n在服务器终端输入：\nbypy info\n\n终端会显示一个长链接。\n复制这个链接，在本地浏览器打开。\n登录百度账号，复制网页上显示的授权码。\n回到服务器终端，粘贴授权码并回车。\n\n显示容量信息即表示绑定成功。\n\n\n\n\nbypy 默认使用的是 Python 单线程下载，遇到几个 G 的大文件经常会**“起步快，然后迅速掉速直到卡死（0%不动）”**。\n必须挂载 aria2 进行多线程拉取。\n请执行以下命令：\n# --downloader aria2: 指定使用 aria2 下载器\n# --processes 4: 开启 4 线程并发（跑满带宽）\n# --timeout 600: 增加超时容忍度，防止网络波动中断\n\nbypy --downloader aria2 --processes 4 --timeout 600 download project.enc\n效果对比：\n\n普通下载：200KB/s -&gt; 0KB/s (卡死)。\nAria2 下载：[#20a9c1 1.2GiB/6.2GiB(19%) CN:4 DL:5.2MiB] -&gt; 5.2MB/s 稳定跑满！\n\n\n\n\n\n下载完成后，你得到了 project.zip。现在用同样的密码把它变回 zip 包。\n# 解压\nunzip project.zip"
  },
  {
    "objectID": "content/blogs/entries/本地服务器低速传输解决方案.html#总结",
    "href": "content/blogs/entries/本地服务器低速传输解决方案.html#总结",
    "title": "本地服务器低速传输解决方案",
    "section": "",
    "text": "当 SSH 链路质量极差时，不要死磕 SCP 或 Rsync。\n“本地压缩 -&gt; 网盘中转 -&gt; Aria2 多线程拉取” 是一条虽然步骤稍多，但绝对可行、安全且高速的路径。特别是对于几个 G 的代码或模型权重文件，这是最节省时间的选择。\n\n小贴士： 如果你的文件不在 /apps/bypy/ 目录下，记得在网盘网页端把文件移动进去，否则 bypy 可能找不到文件(apps文件夹名称可能是中文，注意识别)。"
  },
  {
    "objectID": "content/blogs/entries/如何使用git.html",
    "href": "content/blogs/entries/如何使用git.html",
    "title": "如何使用git",
    "section": "",
    "text": "记录一下自己使用git容易忘记的指令和要学习遵守提交规范"
  },
  {
    "objectID": "content/blogs/entries/如何使用git.html#git提交规范",
    "href": "content/blogs/entries/如何使用git.html#git提交规范",
    "title": "如何使用git",
    "section": "git提交规范",
    "text": "git提交规范\n\n\n提交信息格式\n每次提交应遵循以下格式：\n&lt;类型&gt;(&lt;范围&gt;): &lt;简短描述&gt;\n\n&lt;更详细的描述&gt;\n\n类型：提交的类型，表示本次提交的目的或类别，常见的类型包括：\n\nfeat：新特性（feature）\nfix：修复 bug\ndocs：文档相关更新\nstyle：代码风格的调整（空格、格式化等，不影响代码功能）\nrefactor：重构（既不修复 bug 也不添加新特性）\ntest：增加或修改测试代码\nci：持续集成相关的修改\nbuild：构建系统（如打包工具等）\nrevert：回退提交\n\n范围：提交影响的模块或功能范围，对项目的哪个模块或者功能进行了修改，用圆括号括起来。例如：feat(api), fix(login)。\n简短描述：简洁明了地描述本次提交的目的，首字母小写，不超过 50 个字符。\n详细描述：对提交的详细描述，包括原因、解决方案、关键点等。详细描述与简短描述之间空一行，内容可选但推荐提供，最大长度可以是 72 字符。\n\n\n\n提交信息示例\n\nfeat(user-auth): add login API\nfix(api): fix invalid username validation\ndocs(readme): update setup instructions\nrefactor(auth): improve password hashing algorithm\ntest(user): add unit tests for login functionality\nchore(deps): update dependency versions\n\n\n\n提交时的注意事项\n\n避免：\n\n使用模糊不清的提交信息，如 fix, update, change 等。\n提交过大的改动，建议将大改动拆分成多个小的提交。\n直接修改代码逻辑的提交没有详细描述。\n\n务必：\n\n保持提交信息简洁且有意义，能清晰地告诉他人此次修改的意图。\n每次提交前，请确保代码能够成功编译并通过测试，避免提交未通过测试的代码。\n\n\n\n\ndemo\ngit add . # 添加修改的文件到暂存区\ngit commit -m \"feat(user-auth): add login API\" # 提交代码并写简短描述\ngit push origin main # 推送到远程仓库\n# 新特性\ngit commit -m \"feat(auth): 添加用户api\"\n\n# 修复 bug\ngit commit -m \"fix(validation): ...\"\n\n# 代码重构\ngit commit -m \"refactor(user): ....\"\n\n# 添加测试\ngit commit -m \"test(user): 为登录添加单元测试\"\n\n# 文档更新\ngit commit -m \"docs(readme): 更新安装指南\""
  },
  {
    "objectID": "content/blogs/entries/如何使用git.html#git常用指令",
    "href": "content/blogs/entries/如何使用git.html#git常用指令",
    "title": "如何使用git",
    "section": "git常用指令",
    "text": "git常用指令\n\n修改远程仓库地址\ngit remote set-url origin &lt;new-url&gt;\n\n\n\n同步远程仓库分支\n# 同步远程仓库到main分支\ngit fetch origin main"
  },
  {
    "objectID": "content/blogs/entries/如何使用git.html#参考资料",
    "href": "content/blogs/entries/如何使用git.html#参考资料",
    "title": "如何使用git",
    "section": "参考资料",
    "text": "参考资料\nGit 提交规范"
  },
  {
    "objectID": "content/blogs/entries/保姆教程如何创建自己的“个人网站”.html",
    "href": "content/blogs/entries/保姆教程如何创建自己的“个人网站”.html",
    "title": "保姆教程如何创建自己的“个人网站”",
    "section": "",
    "text": "如何创建自己的个人网站\n\n文章主要介绍如何使用 Jekyll 和 GitHub 创建一个属于自己的个人网站，通过网站可以记录自己的学习笔记，技术收获，同时也可以更好地展示自己，养成笔记的好习惯（21天轻松养成好习惯，哈哈哈）。\n\n\n0、放在开头的一些东西\nRuby安装教程 因为文章是后补的，文章中没有介绍Ruby的安装，安装教程可以参考前面的链接。\n安装Ruby的目的是在本地运行代码，查看网站的效果，如果不需要本地运行可以不配置Ruby环境。\nJekyll模板网站 http://jekyllthemes.org/ 网站中包含了很多静态网的模板，大家可以自由选择，在本中文使用的是chirpy主题，所有模板的配置过程也都大差不差。 ### 1、使用GitHub创建自己的仓库 #### step 1 在GitHub中键入chirpy查找本教程使用的模板，上面的模板可以自行改动，大佬可以阅读源码创建自己的个人主页，下面的仓库操作比较简单，本文选择使用下面的模板，不进行修改，直接进行基础配置后可以进行使用。 \n\nstep 2\n首先找到模板所在的GitHub仓库，在左上角找到“use this template”，然后选择其中的“Create a new repository”，用模板构建自己的仓库。 \n\n\nstep 3\n进行仓库配置，首先需要创建自己仓库的名称，为了后续能够形成自己的个人主页，仓库名称需要设置为 “你的用户名”+“.github.io” ，这样可以通过https://username.github.io直接访问。然后需要将仓库的可见方式设置为Public（默认就是Public，不需要改动）。 \n\n\nstep 4\n点击 “Create repository” 创建属于自己的仓库。 \n\n\nstep 5\n等待仓库创建完成。 \n\n\nstep 6\n仓库创建完成。这时候可以检查仓库的名称是否正确，防止后续不能正常显示网页。 \n\n\nstep 7\n等待一段时间，GitHub配置完成后，在浏览器中输入 “username.github.io” 可以初步看到网页显示的效果，此时只有一个界面，很多配置还没有完成，能够正常显示就是初步成功。 \n\n\n\n2、将仓库内容git到本地\n\n为了能够更好配置网页，测试效果，后续配置和上传帖子，可以将项目git到本地进行配置\n在本地运行Jekyll模板需要配置Ruby环境，配置流程可以参考上面的链接\n当然，在GitHub直接进行修改也是可以的\n\n\n获取git链接\n在创建的仓库界面右上角点击 “code” ，选择HTTPS复制git链接。 \n\n\ngit到本地\n进入想要下载的文件夹，右击选择 “Git Bash Here” 。 \n在其中输入“git clone” + 刚在复制的git链接，将仓库git到本地吗，如果失败就多尝试几次，如果需要配置git可以找篇帖子看一下，都大差不差很好配置。 \n\n\nIDE打开项目\n文章选择使用pycharm打开项目。 \n打开项目后可以右击查看到项目中有git选项，这是因为Pycharm识别到我们git的项目了，通过点选就能完成项目的添加、提交和推送。 \n\n\n\n3、本地配置网站\n\n安装配置\n执行下方命令可以自动进行运行环境配置\nbundle\n\n在配置的过程中可能会出现错误，文章在配置过程中显示缺少wdm插件。 \n安装wdm\ngem install wdm\n\n根据图片中显示安装的是0.2.0版本，而需要的是0.1.1版本，检查Gemfile文件修改其中wdm需要的版本即可。 \n\n\n添加头像\n项目中资源文件一般放在assets中，在assets中创建文件夹防止头像即可，头像的显示需要在配置文件中添加路径，记得本步骤的路径即可。 \n\n\n配置文件修改\n项目的基本配置都在 “_config.yml” 文件中，阅读文件根据需要配置即可。 其中有几个配置比较关键 &gt; lang: 设置显示的语言，语言配置可以看这里，添加文件名就行。 &gt; &gt; description:网站的描述。 &gt; &gt; url: 改成你的网站地址”https://username.github.io” &gt; &gt; github:username: 改成自己的username &gt; &gt; social: 社交平台链接，根据需要修改 &gt; &gt; avatar：头像地址，改成上一步的地址即可 &gt; &gt; comments:评论系统配置，后面详细介绍\n\n\n\n本地运行项目\n配置完成后，执行下面命令运行项目，在 127.0.0.1:4000 查看运行结果。\nbundle exec jekyll server\n 在运行的过程中可能也会出现错误，基本都是缺少插件或者插件的版本问题，哪里报错改哪里，缺啥补啥，直接复制报错信息，直接搜基本都能找到解决方法。\n运行效果如下： \n结束运行： 首先ctrl+c，然后两次确定即可。 \n\n\n添加文章\n文章的添加在 “_post” 文件夹中即可，文件的命名格式和标头都有要求。 \n\n文章命名格式为：YYYY-MM-DD-TITLE.md（注意是markdown文件）\n\n\n标头格式为：\ntitle: 题目名称\nauthor: 作者名称\ndate: 项目创建时间\ncategories: 项目分类，如：[Jekyll, GitHub]\ntags: 项目标签，如：[Jekyll, Github]\nmath: 是否显示latex公式\n……\n其他根据需要添加，可以阅读源码查看相应配置\n\n\n\n\n\n4、提交修改\n提交项目使用git进行控制，主要有三个过程：添加，提交和推送。由于使用了pycharm作为IDE，能直接通过点选完成。\n右击项目，选择 “Git”，先点 “添加” ，然后点 “Commit目录” ，最后推送即可更新GitHub仓库中的内容。待内容更新完成可以在 “https://username.github.io” 查看更新效果。 \n提交更新后效果如下： \n\n\n5、添加评论系统\n在模板中配置了多种评论系统，文章中选择使用 “giscus”。\n在添加前需要完成一个配置，在 “Pages” 中将source改成 “GitHub Actions”。 \n\n安装giscus\n在giscus中点击安装即可，可能需要GitHub认证，按照步骤操作即可。 \n\n\nGitHub配置\n在设置中将Discussions设置为true \n查看Discussions，可以选择或创建一个标签作为评论系统的评论类别名称。这里选择的是 “General”。 \n\n\ngiscus配置\n在giscus中进行配置\n\n首先配置仓库：username/username.github.io\n然后选择映射关系，选择第一个，保持默认即可\n选择Discussion分类，选择之前确定或创建的分类即可 \n\n\n\n项目文件配置\n在giscus配置完成后，会生成专属id \n在项目的 “_config.yml” 文件中进行相应配置\n\nprovider: giscus\ngiscus:\n\nrepo: username/username.github.io\nrepo_id: 自己的repo_id\ncategory: Comments\ncategory_id: 自己的category_id\nmapping: pathname\n\n\n\n\n\n评论系统测试\n将修改后的项目提交，在网页的文章最后能看到评论系统，需要GitHub登陆后才能提交评论 \n\n\n\n6、关于创建过程中遇到的一些问题和解决方法\n\n文章中使用的Jekyll模板作者设计的非常全面，我们在使用的过程中可能会遇到很多问题，本章节主要记录遇到的问题和解决方案\n\n\n数学公式不显示的问题 在post编写的过程中可以使用latex写公式，GitHub也已经支持latex公式的显示，但提交的文章中公式还是源码。 在标头中设置“math: true”就可以 类似的问题可以查看源码，我之前一直以为作者没有添加公式识别功能，查看后才知道写了,需要在标头中进行设置。源码地址\n\n\n黑白两种主题不能切换的问题 缺少必要插件，具体少那个可以自己查查，我忘了\n\n\n插件安装报错wdm，在Gemfile中写的是0.1.1版本，实际安装过程中执行“bundle”命令安装的是0.2.0版本，吧Gemfile文件中的版本号改一下就行。 遇到其他插件报错的时候也可以参考这个方法\n\n\n项目识别不了http链接，可能是出于安全考虑吧 原本是”[xxx] (http://xxx/xxx)“，不能识别http协议，链接直接写就行，不然提交后会在Actions中报错。"
  },
  {
    "objectID": "content/blogs/entries/一文了解VLM.html",
    "href": "content/blogs/entries/一文了解VLM.html",
    "title": "一文了解VLM",
    "section": "",
    "text": "VLM（Vision-Language Model）: 视觉语言大模型"
  },
  {
    "objectID": "content/blogs/entries/一文了解VLM.html#参考资料",
    "href": "content/blogs/entries/一文了解VLM.html#参考资料",
    "title": "一文了解VLM",
    "section": "参考资料",
    "text": "参考资料"
  },
  {
    "objectID": "content/blogs/entries/一文了解VLM.html#一什么是视觉语言模型",
    "href": "content/blogs/entries/一文了解VLM.html#一什么是视觉语言模型",
    "title": "一文了解VLM",
    "section": "一、什么是视觉语言模型？",
    "text": "一、什么是视觉语言模型？\n\n1.1 通俗理解：给 AI 装上”眼睛”\n想象一下，如果你能和一台机器这样对话：\n\n你：“请描述这张图片里有什么？”\nAI：“图中有一只金毛犬在草地上奔跑，背景是蓝天白云，远处还有几棵树。”\n\n或者更复杂一点：\n\n你：“这张图表显示了什么趋势？”\nAI：“这张柱状图显示了 2020-2024 年公司营收的逐年增长趋势，其中 2023 年增长率最高，达到 35%。”\n\n这就是视觉语言模型（VLM）的能力——它能够同时处理视觉信息（图像、视频）和语言信息（文本），并在两者之间建立联系。\n根据 IBM 的定义，视觉语言模型是将计算机视觉（CV）与自然语言处理（NLP）功能融合到统一系统中的多模态模型。简单来说，VLM = 视觉理解 + 语言理解。\n\n\n1.2 技术定义：多模态 AI 的集大成者\n从技术角度看，VLM（也常被称为 Large Vision-Language Models，LVLMs）通常由三个核心组件构成：\n\n三个核心组件的作用：\n\n视觉编码器（Visual Encoder）：负责从图像中提取视觉特征。通常使用 Vision Transformer（ViT）架构，如 CLIP-ViT、EVA-CLIP 等。它将输入的图像转换为模型可以理解的”视觉 token”序列。\n视觉-语言适配器（Vision-Language Adapter）：作为视觉和语言之间的”桥梁”，将视觉特征映射到大语言模型的嵌入空间。常见设计包括：\n\n单层线性投影（如 LLaVA）\n带非线性的 MLP（如 MiniGPT-4）\nQ-Former 架构（如 BLIP-2）\n\n大语言模型（LLM）：负责理解视觉和文本信息，并生成自然语言响应。通常使用预训练的大语言模型，如 LLaMA、Vicuna、Qwen 等。\n\n\n\n1.3 VLM 与纯视觉模型、纯语言模型的区别\n\n\n\n\n\n\n\n\n\n\n模型类型\n输入\n输出\n典型任务\n代表模型\n\n\n\n\n纯视觉模型\n图像\n类别/检测框\n图像分类、目标检测\nResNet、ViT、YOLO\n\n\n纯语言模型\n文本\n文本\n文本生成、问答\nGPT、LLaMA、Qwen\n\n\n视觉语言模型\n图像+文本\n文本\n图像描述、视觉问答、图文检索\nCLIP、BLIP、LLaVA\n\n\n\nVLM 的核心优势在于跨模态理解能力：它不仅能识别图像中的物体，还能理解物体之间的关系、场景的语义信息，并用自然语言表达出来。"
  },
  {
    "objectID": "content/blogs/entries/一文了解VLM.html#二vlm-的发展历程从萌芽到爆发",
    "href": "content/blogs/entries/一文了解VLM.html#二vlm-的发展历程从萌芽到爆发",
    "title": "一文了解VLM",
    "section": "二、VLM 的发展历程：从萌芽到爆发",
    "text": "二、VLM 的发展历程：从萌芽到爆发\n\n2.1 早期探索（2019-2020）：双塔结构的兴起\nVLM 的发展可以追溯到 2019-2020 年，这一时期的研究主要采用双塔架构（Dual-stream Architecture），即分别用独立的编码器处理视觉和语言信息，然后在共享空间中对齐。\n代表性工作：\n\nViLBERT（2019）：将 BERT 架构扩展到视觉-语言领域，采用双流架构分别处理图像和文本\nVisualBERT（2020）：首个图像-文本预训练模型，使用 Faster R-CNN 提取视觉特征\nUNITER（2020）：大规模视觉-语言预训练，在多个下游任务上取得 SOTA\n\n这些早期模型的共同特点是： - 使用目标检测器（如 Faster R-CNN）提取区域特征 - 采用单流或双流 Transformer 进行跨模态融合 - 预训练任务主要包括掩码语言建模（MLM）和图像-文本匹配（ITM）\n\n\n2.2 CLIP 时代（2021）：对比学习的革命\n2021 年，OpenAI 发布了 CLIP（Contrastive Language-Image Pre-training），这是 VLM 发展史上的里程碑事件。\nCLIP 的核心创新：\n\n对比学习范式：通过最大化匹配图文对的相似度、最小化不匹配图文对的相似度来学习跨模态表示\n双塔架构：图像编码器和文本编码器独立工作，输出映射到同一语义空间\n大规模数据：使用 4 亿个互联网收集的图像-文本对进行训练\n\n\nCLIP 的革命性意义在于： - 零样本能力：无需微调即可应用于下游任务 - 开放词汇：不受预定义类别限制，可识别任意概念 - 强大的迁移能力：作为视觉编码器广泛应用于后续 VLM\n同期，Google 发布了 ALIGN，采用类似的对比学习思路，但使用 18 亿个噪声更大的图文对进行训练，进一步验证了规模的重要性。\n\n\n2.3 统一框架（2022）：理解与生成的一体化\n2022 年，Salesforce 发布了 BLIP（Bootstrapping Language-Image Pre-training），提出了统一的视觉-语言理解与生成框架。\nBLIP 的核心贡献：\n\nMED（Multimodal Mixture of Encoder-Decoder）架构：\n\n单模态编码器：分别编码图像和文本\n图像条件文本编码器：融合视觉信息进行理解\n图像条件文本解码器：生成图像描述\n\nCapFilt（Captioning and Filtering）：\n\n使用”生成器+过滤器”策略清洗网络数据\n生成器（Captioner）为网络图像生成合成描述\n过滤器（Filter）去除噪声描述\n\n\nBLIP 在图像-文本检索、图像描述、视觉问答等任务上取得了 SOTA 性能，并展示了强大的零样本迁移能力。\n\n\n2.4 大模型时代（2023）：LLM 赋能的视觉助手\n2023 年是 VLM 的爆发之年，核心趋势是将预训练的大语言模型（LLM）与视觉能力相结合。\n代表性模型：\n\n\n\n\n\n\n\n\n\n模型\n机构\n核心特点\n发布时间\n\n\n\n\nBLIP-2\nSalesforce\n冻结视觉编码器和 LLM，使用 Q-Former 桥接\n2023.01\n\n\nLLaVA\n威斯康星大学\n视觉指令微调，端到端训练\n2023.04\n\n\nMiniGPT-4\nKAUST\n单投影层对齐，两阶段训练\n2023.04\n\n\nQwen-VL\n阿里巴巴\n多语言、多图像、细粒度理解\n2023.08\n\n\n\n这一时期的共同特点：\n\n冻结预训练模型：视觉编码器和 LLM 保持冻结，仅训练适配器，大幅降低训练成本\n指令微调：使用指令数据对模型进行微调，提升指令跟随能力\n端到端训练：从视觉输入直接生成文本输出，简化流程\n\n以 LLaVA 为例，它首次将视觉指令微调（Visual Instruction Tuning）引入 VLM： - 使用 GPT-4 生成多模态指令跟随数据 - 将 CLIP 视觉编码器与 Vicuna LLM 连接 - 端到端微调，实现强大的多模态对话能力\nBLIP-2 则提出了两阶段训练策略： - 第一阶段：使用冻结的视觉编码器训练 Q-Former 进行视觉-语言表示学习 - 第二阶段：将 Q-Former 连接到冻结的 LLM，进行视觉到语言的生成学习\n\n\n2.5 最新进展（2024-2025）：多模态原生大模型\n进入 2024-2025 年，VLM 朝着更大规模、更强能力、更多模态的方向发展。\n主要趋势：\n\n模型规模扩大：从 7B 参数扩展到 70B+ 参数\n分辨率提升：支持更高分辨率输入（如 448×448、896×896）\n多模态扩展：从图像-文本扩展到视频、音频等多模态\n原生多模态架构：不再简单拼接单模态模型，而是从头设计多模态架构\n\n以 Qwen2-VL 为例，它引入了： - 原生动态分辨率支持，可处理任意分辨率的图像 - 多模态旋转位置编码（M-RoPE），统一处理图像和视频 - 强大的文档理解和 OCR 能力"
  },
  {
    "objectID": "content/blogs/entries/一文了解VLM.html#三vlm-的核心技术原理",
    "href": "content/blogs/entries/一文了解VLM.html#三vlm-的核心技术原理",
    "title": "一文了解VLM",
    "section": "三、VLM 的核心技术原理",
    "text": "三、VLM 的核心技术原理\n\n3.1 模型架构：单流 vs 双流\n根据 VLP 综述，VLM 的架构可以从两个维度进行分类：\n\n3.1.1 从多模态融合角度：单流 vs 双流\n单流架构（Single-stream）： - 将视觉特征和文本特征拼接后输入单个 Transformer - 使用统一的自注意力机制进行融合 - 参数效率更高，但模态间干扰较大 - 代表：VisualBERT、UNITER\n双流架构（Dual-stream）： - 视觉和文本分别输入独立的 Transformer - 通过交叉注意力（Cross-Attention）实现跨模态交互 - 模态内信息保留更好，但参数量更大 - 代表：CLIP、BLIP-2\n\n\n\n3.1.2 从整体设计角度：Encoder-only vs Encoder-Decoder\nEncoder-only： - 仅使用编码器提取跨模态表示 - 适用于理解任务（如图文检索、视觉问答） - 代表：CLIP、ALBEF\nEncoder-Decoder： - 编码器提取特征，解码器生成文本 - 适用于生成任务（如图像描述） - 代表：BLIP、OFA\n\n\n\n3.2 预训练目标\nVLM 的预训练目标是学习视觉和语言之间的语义对应关系。根据 VLP 综述，主要预训练目标可以分为四类：\n\n3.2.1 补全类（Completion）\n掩码语言建模（MLM）： - 随机掩码文本中的部分 token，让模型根据视觉信息和上下文预测 - 公式：\\(\\mathcal{L}_{MLM} = -\\mathbb{E}_{(v,w)\\sim D} \\log P(w_m|w_{\\setminus m}, v)\\) - 应用：VisualBERT、UNITER\n掩码视觉建模（MVM）： - 随机掩码部分图像区域，让模型根据文本和其他视觉信息预测 - 变体：掩码特征回归、掩码特征分类 - 应用：UNITER、OSCAR\n\n\n3.2.2 匹配类（Matching）\n图像-文本对比学习（ITC）： - 拉近匹配图文对的特征距离，推远不匹配图文对 - 使用 InfoNCE 损失函数 - 公式：\\(\\mathcal{L}_{ITC} = -\\frac{1}{2}\\mathbb{E}_{(I,T)\\sim D}[CE(y^{v2t}, p^{v2t}(I)) + CE(y^{t2v}, p^{t2v}(T))]\\) - 应用：CLIP、ALBEF、BLIP\n图像-文本匹配（ITM）： - 二分类任务，判断图文对是否匹配 - 使用难负样本挖掘策略 - 应用：ALBEF、BLIP\n\n\n3.2.3 时序类（Temporal）\n帧序建模（FOM）： - 打乱视频帧顺序，让模型预测正确顺序 - 用于视频-语言预训练 - 应用：VideoBERT\n\n\n3.2.4 特定类型\n视觉问答（VQA）： - 将 VQA 作为预训练任务 - 分类或生成式答案预测\n视觉描述（VC）： - 自回归生成图像描述 - 使用语言建模损失\n\n\n\n3.3 视觉特征提取的演进\nVLM 中视觉特征提取方式经历了三代演进：\n\n3.3.1 第一代：基于目标检测的区域特征（OD-RFs）\n\n使用预训练的目标检测器（如 Faster R-CNN）提取区域特征\n每个区域特征为 2048 维向量，附带边界框坐标\n优点：语义明确，包含物体级信息\n缺点：计算开销大，只能提取有限数量的区域\n代表：VisualBERT、UNITER、OSCAR\n\n\n\n3.3.2 第二代：基于 CNN 的网格特征（CNN-GFs）\n\n使用 CNN（如 ResNet）提取网格特征\n可以端到端训练\n优点：计算效率更高\n缺点：语义信息不如区域特征明确\n代表：PixelBERT\n\n\n\n3.3.3 第三代：基于 ViT 的 Patch 特征（ViT-PFs）\n\n使用 Vision Transformer 将图像分割为 patch 序列\n每个 patch 作为一个 token\n优点：与 NLP 的 token 形式统一，便于跨模态融合\n代表：CLIP、BLIP、LLaVA\n\n\n\n\n\n3.4 训练策略：两阶段 vs 三阶段\n现代 VLM 通常采用多阶段训练策略：\n\n3.4.1 两阶段训练（以 BLIP-2 为例）\n第一阶段：视觉-语言表示学习 - 冻结视觉编码器 - 训练 Q-Former 提取与文本最相关的视觉特征 - 使用 ITC、ITM、ITG 三个目标\n第二阶段：视觉到语言生成学习 - 将 Q-Former 连接到冻结的 LLM - 训练 Q-Former 使输出可被 LLM 理解 - 使用语言建模损失\n\n\n3.4.2 三阶段训练（以 Qwen-VL 为例）\n第一阶段：预训练 - 冻结 LLM，训练视觉编码器和适配器 - 使用大规模图文对数据（14 亿对） - 低分辨率输入（224×224）\n第二阶段：多任务预训练 - 解锁 LLM，端到端训练 - 引入高质量细粒度数据（VQA、OCR、Grounding 等） - 高分辨率输入（448×448）\n第三阶段：监督微调 - 冻结视觉编码器，微调 LLM 和适配器 - 使用指令跟随数据 - 增强对话能力和指令理解能力"
  },
  {
    "objectID": "content/blogs/entries/一文了解VLM.html#四主流-vlm-模型详解",
    "href": "content/blogs/entries/一文了解VLM.html#四主流-vlm-模型详解",
    "title": "一文了解VLM",
    "section": "四、主流 VLM 模型详解",
    "text": "四、主流 VLM 模型详解\n\n4.1 CLIP：跨模态对比学习的开创者\n基本信息： - 发布时间：2021 年 2 月 - 机构：OpenAI - 参数量：约 4 亿参数（最大版本） - 训练数据：4 亿图文对\n核心架构：\n\n# CLIP 伪代码\nimage_features = image_encoder(images)  # ViT 或 ResNet\ntext_features = text_encoder(texts)      # Transformer\n\n# 归一化\nimage_features = normalize(image_features)\ntext_features = normalize(text_features)\n\n# 计算相似度\nsimilarity = image_features @ text_features.T\n\n# 对比损失\nloss = cross_entropy_loss(similarity, labels)\n主要能力： - 零样本图像分类 - 图像-文本检索 - 作为视觉编码器用于下游任务\n局限性： - 仅支持理解任务，不支持生成任务 - 对细粒度视觉理解能力有限\n\n\n4.2 BLIP/BLIP-2：统一理解与生成\n\n4.2.1 BLIP\n核心创新： - MED（多模态编解码混合）架构 - CapFilt 数据自举方法\nCapFilt 流程：\n\n\n\n4.2.2 BLIP-2\n核心创新： - Q-Former 架构：轻量级的查询 Transformer - 两阶段训练策略 - 可插拔的冻结模型设计\nQ-Former 架构：\n\n性能表现： - 在 VQAv2 上超过 Flamingo-80B 8.7%，但可训练参数仅为其 1/54\n\n\n\n4.3 LLaVA：视觉指令微调的先锋\n基本信息： - 发布时间：2023 年 4 月 - 机构：威斯康星大学麦迪逊分校 - 核心思想：将指令微调从 NLP 扩展到视觉-语言领域\n数据生成： - 使用 GPT-4 生成多模态指令跟随数据 - 三种类型：对话、详细描述、复杂推理 - 共 158K 样本\n架构：\n\n两阶段训练：\n\n特征对齐预训练：\n\n冻结视觉编码器和 LLM\n仅训练投影矩阵\n使用 595K 图文对\n\n端到端微调：\n\n冻结视觉编码器\n微调投影层和 LLM\n使用 158K 指令数据\n\n\n性能： - 在 Science QA 上与 GPT-4 结合达到 92.53% 准确率（SOTA）\n\n\n4.4 MiniGPT-4：极简设计的强大能力\n基本信息： - 发布时间：2023 年 4 月 - 机构：阿卜杜拉国王科技大学（KAUST）\n架构：\n\n核心发现： - 仅训练一个线性投影层即可有效对齐视觉和语言 - 训练仅需 4 张 A100 GPU，约 10 小时\n两阶段训练：\n\n第一阶段：使用大规模图文对（500 万对）进行预训练\n第二阶段：使用 3500 个高质量详细描述进行微调\n\n涌现能力： - 详细图像描述 - 网站代码生成 - 诗歌创作 - 食谱生成 - 幽默解释\n\n\n4.5 Qwen-VL：多语言多图像的通用模型\n基本信息： - 发布时间：2023 年 8 月 - 机构：阿里巴巴 - 基础模型：Qwen-7B\n核心特点：\n\n多语言支持：\n\n支持中英文双语\n训练数据中 77.3% 英文，22.7% 中文\n\n多图像输入：\n\n支持任意交错的图文数据\n可比较、理解多张图像\n\n细粒度理解：\n\n高分辨率输入（448×448）\n支持文本阅读（OCR）\n支持视觉定位（Grounding）\n\n\n三阶段训练：\n\n\n\n阶段\n数据\n训练策略\n分辨率\n\n\n\n\n预训练\n14 亿图文对\n冻结 LLM，训练视觉模块\n224×224\n\n\n多任务预训练\n7 个任务（76.8M 样本）\n端到端训练\n448×448\n\n\n监督微调\n350K 指令数据\n冻结视觉，微调 LLM\n448×448\n\n\n\n性能表现： - Flickr30K 图像描述：85.8 CIDEr（零样本 SOTA） - VQAv2：79.5% 准确率 - RefCOCO 定位：88.55% 准确率"
  },
  {
    "objectID": "content/blogs/entries/一文了解VLM.html#五vlm-的应用场景",
    "href": "content/blogs/entries/一文了解VLM.html#五vlm-的应用场景",
    "title": "一文了解VLM",
    "section": "五、VLM 的应用场景",
    "text": "五、VLM 的应用场景\n\n5.1 图像描述与视觉问答\n图像描述（Image Captioning）： - 为图像生成自然语言描述 - 应用：辅助视障人士、图像检索、内容审核\n视觉问答（Visual Question Answering, VQA）： - 根据图像内容回答自然语言问题 - 应用：智能客服、教育辅助、医疗影像分析\n\n\n5.2 图文检索\n图像-文本检索： - 文本到图像检索：根据文本描述找到匹配图像 - 图像到文本检索：根据图像找到相关文本描述 - 应用：搜索引擎、电商平台、内容推荐\n\n\n5.3 文档理解\nOCR 与文档分析： - 文本阅读：识别图像中的文字内容 - 表格理解：解析表格结构和内容 - 图表分析：理解图表中的数据和趋势 - 应用：金融报告分析、合同审查、发票处理\n\n\n5.4 视觉定位与指代表达\n视觉定位（Visual Grounding）： - 根据文本描述定位图像中的物体 - 输出边界框坐标\n指代表达理解（Referring Expression Comprehension）： - 理解如”左边的红衣服女孩”这样的描述 - 应用：机器人导航、图像编辑、交互式 AI\n\n\n5.5 创意生成\n图像到代码： - 将手绘草图转换为 HTML/CSS 代码 - 应用：前端开发、原型设计\n图像到故事/诗歌： - 根据图像创作故事或诗歌 - 应用：内容创作、教育娱乐"
  },
  {
    "objectID": "content/blogs/entries/一文了解VLM.html#六幻觉问题vlm-的阿喀琉斯之踵",
    "href": "content/blogs/entries/一文了解VLM.html#六幻觉问题vlm-的阿喀琉斯之踵",
    "title": "一文了解VLM",
    "section": "六、幻觉问题：VLM 的阿喀琉斯之踵",
    "text": "六、幻觉问题：VLM 的阿喀琉斯之踵\n\n6.1 什么是 VLM 幻觉？\n根据《视觉语言大模型的幻觉综述》，VLM 幻觉是指模型生成的文本响应表现出对图像内容的错误感知。\n幻觉示例：\n\n\n\n图像内容\n模型输出\n问题\n\n\n\n\n只有酸奶和草莓的冰箱\n“有草莓味酸奶”\n物体存在幻觉\n\n\n限速 40km/h 的路牌\n“限速 60km/h”\n属性幻觉\n\n\n猫在沙发上\n“沙发上有一只狗”\n物体识别错误\n\n\n\n\n\n6.2 幻觉的分类\n根据幻觉综述，VLM 幻觉可分为三类：\n\n物体存在幻觉（Object Existence Hallucination）：\n\n描述图像中不存在的物体\n遗漏图像中存在的物体\n\n物体属性幻觉（Object Attribute Hallucination）：\n\n错误描述物体的颜色、形状、材质等属性\n\n物体关系幻觉（Object Relationship Hallucination）：\n\n错误描述物体之间的空间位置关系\n错误描述物体之间的交互关系\n\n\n此外，研究还定义了其他类型的幻觉： - 多模态冲突幻觉：文本输入与视觉输入不匹配时引发的幻觉 - 反常识幻觉：图像中存在反常识元素时导致的幻觉 - 事件幻觉：基于错误感知创造出完全虚构的事件或情景 - 数字幻觉：未能准确识别图像中特定物体的数量\n\n\n6.3 幻觉的成因\n幻觉综述从四个维度分析了幻觉的成因：\n\n6.3.1 训练数据相关\n\n图像的文本描述不够细致：\n\n开源数据集中的文本描述较为粗糙\n无法充分覆盖图像内容\n\n合成的指令微调数据存在噪声：\n\n使用 GPT-4 生成的指令数据可能包含幻觉元素\n研究显示 LLaVA 的 GPT-4 合成数据中约 32.6% 含有幻觉\n\n数据中存在统计偏差：\n\n物体类别出现频率不均衡\n正向响应比例过高\n\n\n\n\n6.3.2 训练任务相关\n\n单一的语言建模任务缺乏对模态间一致性的显式约束\n模型过于关注生成文本的流畅性，而忽略与视觉信息的一致性\n\n\n\n6.3.3 视觉编码相关\n\n细粒度视觉信息感知能力不足：\n\n输入分辨率通常低于 400 像素\n训练数据中的文本标注只能涵盖主要内容而非细节\n\n视觉特征无法受到 LLM 的充分关注：\n\n视觉 token 在 LLM 中的平均注意力分数不足 20%\n随着生成进行，对视觉 token 的关注持续下降\n\n\n\n\n6.3.4 文本生成相关\n\nLLM 的先验性知识偏差：\n\n模型倾向于依赖先验知识而非实际视觉证据\n即使输入噪声图像，仍可能输出高置信度答案\n\n自回归解码中的偏差累积：\n\n早期生成的小错误会在后续生成中被放大\n幻觉频率随生成长度增加而升高\n\n固有的采样随机性：\n\n采样过程可能导致模型偶尔输出概率较低的错误 token\n\n\n\n\n\n6.4 幻觉的评估\n幻觉评估基准包括：\n\n\n\n基准\n任务形式\n评估指标\n幻觉类型\n\n\n\n\nCHAIR\n图像描述\nCHAIRi, CHAIRs\n物体存在\n\n\nPOPE\n视觉问答\n准确率、F1\n物体存在\n\n\nMME\n视觉问答\nAccuracy+\n存在、属性\n\n\nAMBER\n描述+问答\n准确率、精确率、召回率\n存在、属性、关系\n\n\nMMHAL-BENCH\n描述+问答\nGPT-4 评分\n多种类型\n\n\n\n\n\n6.5 幻觉的治理\n幻觉综述从五个维度讨论了幻觉治理策略：\n\n6.5.1 数据侧\n\n提升指令数据的多样性\n增强图像-文本关联度\n使用高质量的人工标注数据\n\n\n\n6.5.2 视觉感知侧\n\n使用更高分辨率的视觉编码器\n集成多个视觉编码器\n增加视觉编码器的参数规模\n\n\n\n6.5.3 训练策略侧\n\n引入新的监督信号\n使用强化学习\n增加任务信息\n\n\n\n6.5.4 推理侧\n\n对比解码\n不确定性估计\n多步推理\n\n\n\n6.5.5 事后修正侧\n\n使用外部知识验证\n自我修正机制\n人类反馈"
  },
  {
    "objectID": "content/blogs/entries/一文了解VLM.html#七vlm-的技术挑战与未来方向",
    "href": "content/blogs/entries/一文了解VLM.html#七vlm-的技术挑战与未来方向",
    "title": "一文了解VLM",
    "section": "七、VLM 的技术挑战与未来方向",
    "text": "七、VLM 的技术挑战与未来方向\n\n7.1 当前挑战\n\n7.1.1 幻觉问题\n\n如前所述，幻觉是限制 VLM 在高风险领域应用的主要因素\n需要更可靠的评估和治理方法\n\n\n\n7.1.2 细粒度理解\n\n当前 VLM 对细节的理解能力仍有限\n高分辨率处理需要更多计算资源\n\n\n\n7.1.3 多模态融合\n\n如何更好地融合视觉、语言、音频等多种模态\n如何处理模态间的信息冲突\n\n\n\n7.1.4 计算效率\n\n大规模 VLM 的推理成本高昂\n需要更高效的模型压缩和加速技术\n\n\n\n\n7.2 未来方向\n\n7.2.1 原生多模态架构\n\n从头设计支持多模态的架构，而非简单拼接单模态模型\n统一处理文本、图像、视频、音频等多种模态\n\n\n\n7.2.2 世界模型\n\n构建能够理解物理世界的 VLM\n支持因果推理和物理模拟\n\n\n\n7.2.3 具身智能\n\n将 VLM 与机器人结合\n支持视觉导航、物体操作等任务\n\n\n\n7.2.4 个性化与可解释性\n\n支持用户个性化的 VLM\n提供可解释的推理过程"
  },
  {
    "objectID": "content/blogs/entries/一文了解VLM.html#八总结",
    "href": "content/blogs/entries/一文了解VLM.html#八总结",
    "title": "一文了解VLM",
    "section": "八、总结",
    "text": "八、总结\n视觉语言模型（VLM）代表了人工智能领域的重要进展，它让机器能够同时”看懂”图像和”理解”语言，开启了人机交互的全新范式。\n从发展历程看： - 从早期的双塔架构到 CLIP 的对比学习革命 - 从 BLIP 的统一框架到 LLM 赋能的视觉助手 - VLM 正在朝着更大规模、更强能力、更多模态的方向发展\n从技术原理看： - VLM 的核心在于跨模态对齐和融合 - 预训练目标、模型架构、训练策略都在不断演进 - 幻觉问题仍是当前的主要挑战\n从应用场景看： - 图像描述、视觉问答、图文检索等基础任务已较为成熟 - 文档理解、视觉定位、创意生成等高级任务正在快速发展 - 未来将在更多领域发挥重要作用\n对于初学者，理解 VLM 的关键在于把握跨模态对齐这一核心思想；对于技术从业者，则需要深入理解各种架构设计和训练策略的优劣。无论如何，VLM 都是一个值得持续关注的领域，它正在重新定义人机交互的方式，让我们离真正的通用人工智能更近一步。"
  },
  {
    "objectID": "content/blogs/entries/一文了解VLM.html#参考资料-1",
    "href": "content/blogs/entries/一文了解VLM.html#参考资料-1",
    "title": "一文了解VLM",
    "section": "参考资料",
    "text": "参考资料\n[1]: 什么是视觉语言模型 (VLM)？| IBM\n[2]: VLM 说明\n[3]: VLP: A Survey on Vision-Language Pre-training\n[4]: Learning Transferable Visual Models From Natural Language Supervision (CLIP)\n[5]: Scaling Up Visual and Vision-Language Representation Learning With Noisy Text Supervision (ALIGN)\n[6]: BLIP: Bootstrapping Language-Image Pre-training for Unified Vision-Language Understanding and Generation\n[7]: Visual Instruction Tuning (LLaVA)\n[8]: BLIP-2: Bootstrapping Language-Image Pre-training with Frozen Image Encoders and Large Language Models\n[9]: Qwen2-VL: Enhancing Vision-Language Model’s Perception of the World at Any Resolution\n[10]: 视觉语言大模型的幻觉综述：成因、评估与治理\n\n延伸阅读： - Guide to Vision-Language Models (VLMs) | Encord - 视觉语言模型详解 | Hugging Face - What Are Vision Language Models | NVIDIA"
  },
  {
    "objectID": "content/blogs/entries/pc的快捷指令.html",
    "href": "content/blogs/entries/pc的快捷指令.html",
    "title": "PC的快捷指令",
    "section": "",
    "text": "记录一下常见PC的快捷指令，主要是博主经常忘记，这里记录一下，方便后续查看。"
  },
  {
    "objectID": "content/blogs/entries/pc的快捷指令.html#windows",
    "href": "content/blogs/entries/pc的快捷指令.html#windows",
    "title": "PC的快捷指令",
    "section": "Windows",
    "text": "Windows\n\n终端配置\nWindows 终端增强配置速查\n\n基础环境\n# 安装 PowerShell 7（管理员）\nwinget install Microsoft.PowerShell\n\n# 创建配置文件\nif (!(Test-Path $PROFILE)) { New-Item -Path $PROFILE -ItemType File -Force }\nnotepad $PROFILE\n\n\n核心配置\n# 历史预测与提示\nSet-PSReadLineOption -PredictionSource History\nSet-PSReadLineOption -PredictionViewStyle InlineView\n\n# 快捷键：Ctrl+A/E 跳转行首行尾\nSet-PSReadLineKeyHandler -Key Ctrl+a -Function BeginningOfLine\nSet-PSReadLineKeyHandler -Key Ctrl+e -Function EndOfLine\n\n# 上下箭头匹配前缀\nSet-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward\nSet-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward\n\n# 默认 UTF-8\n$PSDefaultParameterValues['*:Encoding'] = 'UTF8'\n[Console]::OutputEncoding = [System.Text.Encoding]::UTF8\n\n\n工具安装\n# 安装（PowerShell 7 中执行）\nwinget install lsd\nwinget install sharkdp.bat --name bat\n\n# 若提示找不到命令，修复 Path（执行后重启终端）\n$lsdPath = \"${env:LOCALAPPDATA}\\Microsoft\\WinGet\\Packages\\lsd-rs.lsd_Microsoft.Winget.Source_8wekyb3d8bbwe\"\n$batPath = (Get-ChildItem \"${env:LOCALAPPDATA}\\Microsoft\\WinGet\\Packages\" -Recurse -Filter \"bat.exe\" | Select-Object -First 1).DirectoryName\n$userPath = [Environment]::GetEnvironmentVariable(\"Path\", \"User\")\n[Environment]::SetEnvironmentVariable(\"Path\", \"$userPath;$lsdPath;$batPath\", \"User\")\n\n\n别名设置\nfunction ls { lsd $args }\nfunction ll { lsd -la $args }\nfunction la { lsd -a $args }\nfunction cat { bat -p $args }      # 纯文本兼容\nfunction catl { bat $args }         # 带高亮行号\n\n\n验证指令\nlsd --version        # 显示版本即成功\nbat README.md        # 高亮显示文件\nGet-PSReadLineOption | Select-Object PredictionSource  # 检查预测开启"
  },
  {
    "objectID": "content/blogs/entries/pc的快捷指令.html#mac",
    "href": "content/blogs/entries/pc的快捷指令.html#mac",
    "title": "PC的快捷指令",
    "section": "Mac",
    "text": "Mac\n\n删除\n\n清空废纸篓：Cmd + Shift + Delete\n直接删除不经过废纸篓：Option + Cmd + Delete\n反向删除：Fn + Delete\n\n\n\n命令行指令提示插件\n# 安装插件\nmkdir -p ~/.oh-my-zsh/custom/plugins\n\ngit clone https://github.com/zsh-users/zsh-autosuggestions \\\n  ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions\n\ngit clone https://github.com/zsh-users/zsh-syntax-highlighting \\\n  ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting\n\n# 注册插件生效\ncode ~/.zshrc\n\n# 找到 plugins=()\n# 改成 plugins=(git zsh-autosuggestions zsh-syntax-highlighting)\n\nsource ~/.zshrc # 配置生效\n\n\n\n命令行快速到行首尾\n快速把光标跳到行首的默认快捷键是：\nCtrl + A\n快速把光标跳到行首的默认快捷键是：\nCtrl + E"
  },
  {
    "objectID": "content/blogs/entries/pc的快捷指令.html#linux",
    "href": "content/blogs/entries/pc的快捷指令.html#linux",
    "title": "PC的快捷指令",
    "section": "Linux",
    "text": "Linux"
  },
  {
    "objectID": "content/blogs/entries/PromptContextSkills.html",
    "href": "content/blogs/entries/PromptContextSkills.html",
    "title": "Prompt->Context->Skills",
    "section": "",
    "text": "从 Prompt 到上下文工程到 Skills：AI 交互范式的演进与 Vibe Coding 的崛起"
  },
  {
    "objectID": "content/blogs/entries/PromptContextSkills.html#引言ai-交互的三次革命",
    "href": "content/blogs/entries/PromptContextSkills.html#引言ai-交互的三次革命",
    "title": "Prompt->Context->Skills",
    "section": "引言：AI 交互的三次革命",
    "text": "引言：AI 交互的三次革命\n2022 年底，ChatGPT 的横空出世标志着人工智能进入了一个全新的时代。短短两年多时间，我们与 AI 的交互方式已经经历了三次深刻的范式转变：\n第一次革命：Prompt Engineering（提示工程） —— 我们学会了如何与 AI 对话，用精心设计的提示词来引导模型输出。\n第二次革命：Context Engineering（上下文工程） —— 我们意识到 AI 的能力不仅取决于提示词本身，更取决于提供给它的上下文环境。RAG、记忆系统、外部知识库的引入，让 AI 从”闭卷考试”变成了”开卷考试”。\n第三次革命：Skills & Agentic AI（技能与智能体） —— AI 不再只是被动回答问题，而是能够主动调用工具、执行动作、与其他 Agent 协作，成为真正的”数字工作者”。\n与此同时，一种全新的编程范式正在悄然兴起 —— Vibe Coding（氛围编程），它正在重新定义人类与 AI 在软件开发中的协作关系。\n本文将带你完整走过这段演进历程，无论你是刚接触 AI 的初学者，还是希望深入理解底层逻辑的技术从业者，都能从中获得系统性的认知提升。"
  },
  {
    "objectID": "content/blogs/entries/PromptContextSkills.html#第一章prompt-engineering-与-ai-对话的艺术",
    "href": "content/blogs/entries/PromptContextSkills.html#第一章prompt-engineering-与-ai-对话的艺术",
    "title": "Prompt->Context->Skills",
    "section": "第一章：Prompt Engineering —— 与 AI 对话的艺术",
    "text": "第一章：Prompt Engineering —— 与 AI 对话的艺术\n\n1.1 什么是 Prompt Engineering？\nPrompt Engineering（提示工程）是指通过设计和优化输入提示（prompt），来引导大型语言模型（LLM）产生更准确、更有用输出的技术。它是最基础、最直观的 AI 交互方式 —— 你输入文字，AI 返回文字。\n但Prompt Engineering 远不止是”问问题”这么简单。正如 2025 年的最佳实践所强调的：“Specific prompts are better prompts”（具体的提示才是好提示）。\n一个糟糕的例子：\n\"解释气候变化\"\n一个优秀的例子：\n\"为高中生撰写一段关于气候变化的三段式总结，使用项目符号，\n保持中立语气，控制在 300 字以内。\"\n\n\n1.2 核心技术技法\n\nZero-Shot Prompting（零样本提示）\n直接向模型提出任务，不提供任何示例。这是最简单的方式，适用于模型已经具备相关知识的任务。\n将以下英文翻译成中文：\n\"The quick brown fox jumps over the lazy dog.\"\n\n\nFew-Shot Prompting（少样本提示）\n提供 3-5 个高质量的示例，让模型学习模式和格式。研究表明，这是提升输出质量最有效的方法之一。\n将情感分类为正面、负面或中性。\n\n示例 1：\n文本：\"这部电影太棒了！\"\n情感：正面\n\n示例 2：\n文本：\"服务态度很差\"\n情感：负面\n\n示例 3：\n文本：\"今天天气晴朗\"\n情感：中性\n\n待分类文本：\"这个产品完全不符合预期\"\n情感：\n\n\nChain-of-Thought (CoT) 思维链\n要求模型展示推理过程，而非直接给出答案。这对数学问题、逻辑推理尤其有效。\n问题：一个农场有 35 只鸡和 28 只兔子。农场主卖掉了一半的鸡和 \n三分之一的兔子。还剩多少只动物？\n\n请一步一步思考：\n模型会输出：\n1. 初始鸡的数量：35 只\n2. 卖掉一半的鸡：35 ÷ 2 = 17.5，取整为 17 只\n3. 剩余鸡：35 - 17 = 18 只\n4. 初始兔子数量：28 只\n5. 卖掉三分之一的兔子：28 ÷ 3 ≈ 9 只\n6. 剩余兔子：28 - 9 = 19 只\n7. 总共剩余：18 + 19 = 37 只\n\n\nReAct (Reasoning + Acting) 推理+行动\n结合推理和工具调用的先进技法。模型不仅思考，还能决定何时使用外部工具。\n你需要搜索最新信息来回答用户问题。\n\n问题：苹果公司今天的股价是多少？\n\n思考：我需要搜索苹果的最新股价\n行动：搜索 \"Apple stock price today\"\n观察：[搜索结果：AAPL $182.50, +1.2%]\n思考：我已经获得了股价信息\n最终答案：苹果公司今天股价为 182.50 美元，上涨 1.2%\n\n\n\n1.3 2025 年的前沿技术\n\nRecursive Self-Improvement Prompting (RSIP) 递归自改进提示\n让 AI 批判并改进自己的输出，通过多轮迭代达到更高质量。\n流程： 1. 生成：创建初始输出 2. 批判性评估：让模型使用特定标准识别弱点 3. 改进：基于批评生成增强版本\n实践表明，这种方法可以减少约 60% 的修改周期。\n\n\nMulti-Perspective Simulation (MPS) 多视角模拟\n在单次对话中运行”虚拟专家小组”，让模型从不同角度分析问题。\n请从以下三个角度分析这个商业决策：\n1. 财务总监（关注成本与 ROI）\n2. 技术总监（关注可行性与技术债务）\n3. 市场总监（关注用户体验与竞争优势）\n\n每个视角都需要：\n- 阐述核心观点\n- 提出潜在风险\n- 给出具体建议\n\n最后，请综合三个视角给出整体评估。\n\n\n\n1.4 Prompt Engineering 的局限性\n尽管 Prompt Engineering 强大，但它存在根本性限制：\n\nFragility（脆弱性）：输入的微小变化、系统版本更新，甚至模型的随机性，都可能导致输出质量波动\nLimited Context（上下文限制）：模型的上下文窗口有限，无法处理大量外部信息\nNo Real-Time Knowledge（无实时知识）：模型只能依赖训练数据，无法获取最新信息\nNo Action Capability（无行动能力）：模型只能生成文本，无法执行实际操作\n\n这些限制催生了下一个演进阶段 —— Context Engineering。"
  },
  {
    "objectID": "content/blogs/entries/PromptContextSkills.html#第二章context-engineering-构建-ai-的操作环境",
    "href": "content/blogs/entries/PromptContextSkills.html#第二章context-engineering-构建-ai-的操作环境",
    "title": "Prompt->Context->Skills",
    "section": "第二章：Context Engineering —— 构建 AI 的操作环境",
    "text": "第二章：Context Engineering —— 构建 AI 的操作环境\n\n2.1 从 Prompt 到 Context 的范式转移\nContext Engineering（上下文工程）是 2024-2025 年兴起的新 discipline。如果说 Prompt Engineering 是”写好问题”，Context Engineering 就是”构建完整的操作环境”。\n核心定义： &gt; Context Engineering 是系统地设计和管理提供给 LLM 的所有信息 —— 包括提示、检索结果、对话历史、元数据、工具状态 —— 以控制模型的推理和输出，而无需修改模型权重。\n简单来说，Context Engineering = Prompt Engineering + RAG + 记忆管理 + 工具状态 + 环境配置\n\n\n2.2 RAG：检索增强生成\nRAG（Retrieval-Augmented Generation）是 Context Engineering 的核心组件。它解决了 LLM 无法访问私有数据、无法获取实时信息的问题。\nRAG 工作流程：\n用户查询 → 嵌入向量 → 向量数据库检索 → 获取 Top-K 相关文档 \n→ 将文档注入提示上下文 → LLM 生成回答\n实际应用场景：\n场景 1：企业知识库问答\n基于以下公司内部文档回答问题：\n&lt;documents&gt;\n[从向量数据库检索的相关文档片段]\n&lt;/documents&gt;\n\n问题：我们的年假政策是什么？\n请引用相关文档的具体章节并标注页码。\n场景 2：客服机器人\n你是一个客服助手。以下是相关的产品文档和历史对话：\n&lt;context&gt;\n[产品手册片段]\n[用户之前的工单记录]\n[常见问题解答]\n&lt;/context&gt;\n\n用户问题：我的订单什么时候能到？\n订单号：#12345\n\n\n2.3 上下文工程的技术支柱\n\n1. Prompt Design（提示设计）\n动态提示模板，根据用户、任务和系统状态组装不同的提示。\n# 动态提示模板示例\ndef build_prompt(user_type, task, context):\n    system_prompt = f\"你是一个{user_type}专家助手。\"\n    user_prompt = f\"任务：{task}\\n\\n上下文：{context}\"\n    return system_prompt + user_prompt\n\n\n2. Context Composition（上下文组合）\n现代 AI 系统需要组合多层上下文：\n\n对话历史：保持对话连贯性\n检索结果：外部知识注入\n当前工具状态：告诉 AI 有哪些工具可用\nAgent 目标与计划：长期任务的状态跟踪\n用户画像/偏好：个性化设置\n\ncontext_stack = {\n    \"system_instructions\": \"你是一个研究助手...\",\n    \"user_profile\": {\"role\": \"研究员\", \"expertise\": \"AI\"},\n    \"conversation_history\": [...],\n    \"retrieved_documents\": [...],\n    \"available_tools\": [\"search\", \"calculator\", \"code_runner\"],\n    \"current_task_state\": {\"step\": 3, \"goal\": \"完成报告\"}\n}\n\n\n3. Memory Systems（记忆系统）\n生产级 Agent 需要四层记忆架构：\n\n\n\n\n\n\n\n\n记忆类型\n描述\n技术实现\n\n\n\n\nShort-Term Memory (STM)\n当前对话的短期上下文\n滑动窗口，保留最近 N 轮对话\n\n\nWorking Memory\n当前任务的临时状态\n变量存储，任务完成即清除\n\n\nLong-Term Memory (LTM)\n用户偏好、历史交互\n向量数据库持久化存储\n\n\nEpisodic Memory\n特定事件/经验的记忆\n结构化存储，支持语义检索\n\n\n\n\n\n\n2.4 Prompt Engineering vs Context Engineering\n\n\n\n维度\nPrompt Engineering\nContext Engineering\n\n\n\n\n关注点\n提示词的措辞和结构\n完整的输入环境设计\n\n\n范围\n单次交互\n多轮对话 + 外部系统\n\n\n技术栈\n自然语言 + 模板\nRAG + 向量DB + 记忆系统\n\n\n目标\n优化单次输出\n塑造持续可靠的行为\n\n\n适用场景\n简单问答、内容生成\n复杂应用、生产系统\n\n\n\n关键洞察： &gt; “Prompt Engineering 优化即时输出，Context Engineering 治理模型在推理前看到的所有上下文，塑造生产系统中的持续行为。”"
  },
  {
    "objectID": "content/blogs/entries/PromptContextSkills.html#第三章skillstool-use-与-agentic-ai-从说话到行动",
    "href": "content/blogs/entries/PromptContextSkills.html#第三章skillstool-use-与-agentic-ai-从说话到行动",
    "title": "Prompt->Context->Skills",
    "section": "第三章：Skills、Tool Use 与 Agentic AI —— 从说话到行动",
    "text": "第三章：Skills、Tool Use 与 Agentic AI —— 从说话到行动\n\n3.1 工具调用：AI 的”手”和”脚”\n如果说 Context Engineering 给了 AI “眼睛”（看外部信息），那么 Tool Use（工具调用）就给了 AI “手”和”脚”（执行动作）。\nTool Calling 的定义： &gt; 工具调用是 LLM 决定使用外部功能（运行代码、调用 API、搜索网页、操作数据库）来完成模型自身无法独立完成的任务的过程。\n工具调用的决策流程：\n1. 解析用户查询 → 理解用户想要什么\n2. 映射意图到工具模式 → 对比可用工具描述\n3. 决定是否需要工具 → 纯推理 vs 需要执行\n4. 生成结构化工具调用 → JSON 格式的函数调用\n5. 在外部执行工具 → Python/API/数据库查询\n6. 将输出返回给 LLM → 工具执行结果\n7. LLM 决定下一步 → 继续调用工具或直接回答\n\n\n3.2 Function Calling 实战示例\n示例：天气查询 Agent\n首先，定义工具的模式（Schema）：\n{\n  \"name\": \"get_weather\",\n  \"description\": \"获取指定城市的当前天气\",\n  \"parameters\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"city\": {\n        \"type\": \"string\",\n        \"description\": \"城市名称，如 '北京'、'上海'\"\n      },\n      \"unit\": {\n        \"type\": \"string\",\n        \"enum\": [\"celsius\", \"fahrenheit\"],\n        \"description\": \"温度单位\"\n      }\n    },\n    \"required\": [\"city\"]\n  }\n}\n用户输入：“北京今天天气怎么样？”\nLLM 的决策过程：\n思考：用户询问北京天气，我需要调用 get_weather 工具\n工具调用：{\"tool\": \"get_weather\", \"arguments\": {\"city\": \"北京\", \"unit\": \"celsius\"}}\n后端执行工具，返回：\n{\n  \"temperature\": 22,\n  \"condition\": \"晴朗\",\n  \"humidity\": \"45%\"\n}\nLLM 生成最终回答：\n北京今天天气晴朗，气温 22°C，湿度 45%，是个出行的好天气！\n\n\n3.3 MCP：模型上下文协议 —— AI 的”USB-C”\n2024 年底，Anthropic 推出了 MCP（Model Context Protocol），这是一个开放标准协议，旨在标准化 AI 系统与外部工具和数据源的交互方式。\nMCP 的核心愿景： &gt; “就像 USB-C 为各种设备提供通用连接一样，MCP 为 AI 模型提供统一的接口来连接不同的工具和数据源。”\nMCP 架构：\n\nMCP 2025 年路线图包括：\n\n远程 MCP 连接：支持 OAuth 2.0 认证与授权\n分发与发现：包管理、安装工具、服务器注册\nAgent 支持：分层 Agent 系统、交互式工作流、流式结果\n\nMCP 正在快速成为行业标准，类似于当年的 LSP（Language Server Protocol）。\n\n\n3.4 A2A：Agent-to-Agent 协议 —— AI 的”社交语言”\n如果说 MCP 是 AI 与工具的通用接口，那么 A2A（Agent-to-Agent Protocol） 就是 AI 与 AI 之间的通用语言。\n2025 年 4 月，Google 推出了 A2A 协议，这是一个开放标准，旨在让不同框架、不同厂商的 AI Agent 能够发现彼此、协商任务、协作完成复杂工作流。\nA2A 的五大设计原则：\n\n拥抱自然 Agent 能力：不强制改变 Agent 的工作方式\n基于现有标准：使用 HTTP、JSON-RPC 等成熟技术\n企业级安全：内置认证、授权、加密\n支持长时间任务：异步执行、状态更新、推送通知\n模态无关：支持文本、音频、视频、结构化数据\n\nA2A 的核心概念：\n\n\n\n组件\n描述\n\n\n\n\nAgent Cards\nJSON 元数据文件，描述 Agent 的能力、身份、端点\n\n\nTask Management\n任务生命周期管理：发起、状态更新、完成通知\n\n\nCollaboration\nAgent 间交换上下文、协商执行方式\n\n\nUX Negotiation\n协商内容类型和格式，适应不同 UI 能力\n\n\n\n实际应用场景：\n招聘流程自动化：\n招聘经理 Agent → 发布招聘需求\n       ↓\n猎头 Agent A → 搜索候选人\n       ↓\n猎头 Agent B → 安排面试\n       ↓\n背景调查 Agent → 执行背景核查\n       ↓\n所有结果汇总 → 招聘经理 Agent\n每个 Agent 可能来自不同厂商、使用不同框架，但通过 A2A 协议可以无缝协作。\n\n\n3.5 现代 Agent 架构\n一个生产级的 AI Agent 可以形式化定义为：\nAgent := &lt;Perception, Memory, Reasoning, Planning, Action, Feedback&gt;\n各组件详解：\n\n\n\n组件\n功能\n技术实现\n\n\n\n\nPerception\n接收输入\n文本解析、API 适配器、日志读取\n\n\nMemory\n存储状态\n向量 DB、文档存储、短期上下文\n\n\nReasoning\n推理决策\nLLM 推理 + CoT/ReAct/ToT\n\n\nPlanning\n任务规划\n任务分解、工具选择、执行图\n\n\nAction\n执行动作\n工具调用、API 请求、代码执行\n\n\nFeedback\n反馈学习\n错误分析、自我批评、记忆更新\n\n\n\n2025 年的 Agent 类型：\n\nDeep Research Agents：自主进行深度研究，如 Perplexity、Grok\nCoding Agents：Devin、Cursor IDE Agents，自主编写、调试、测试代码\nCUA (Computer-Using Agents)：模拟人类操作电脑界面，如 AutoGPT、SIMA\nMulti-Agent Systems：多个专业 Agent 协作，如 CrewAI、AutoGen"
  },
  {
    "objectID": "content/blogs/entries/PromptContextSkills.html#第四章vibe-coding-编程范式的颠覆",
    "href": "content/blogs/entries/PromptContextSkills.html#第四章vibe-coding-编程范式的颠覆",
    "title": "Prompt->Context->Skills",
    "section": "第四章：Vibe Coding —— 编程范式的颠覆",
    "text": "第四章：Vibe Coding —— 编程范式的颠覆\n\n4.1 什么是 Vibe Coding？\nVibe Coding 是 2024-2025 年兴起的一种全新编程范式。它不关注代码的具体语法，而是关注”氛围”——开发者用自然语言描述想要的功能和感觉，AI 负责生成具体的代码实现。\n核心定义： &gt; Vibe Coding 是一种开发方法，开发者使用自然语言提示 AI 工具生成软件代码。它将重点从手动编码转移到 AI 引导的构建方式。\nVibe Coding 的工作流程：\n\n\n\n4.2 Vibe Coding 的起源与演进\n2023 年：Reddit 上的开发者开玩笑说他们在用 ChatGPT “vibe” 功能到现实中 —— 这只是一个梗。\n2024 年底：OpenAI 创始成员 Andrej Karpathy 认真对待这个概念，称之为”AI 原生开发的下一个演进”。\n2025 年初：《华尔街日报》确认企业开始在实际开发工作流中采用 Vibe Coding。\n今天：Vibe Coding 已经从梗变成了严肃的方法论。\n\n\n4.3 Vibe Coding 的工具生态\n\n\n\n工具\n特点\n适用场景\n\n\n\n\nCursor\nAI 原生代码编辑器，对话式开发\n专业开发，复杂项目\n\n\nGitHub Copilot X\nIDE 内实时代码建议\n日常编码，快速补全\n\n\nReplit Ghostwriter\n浏览器内多模态构建\n快速原型，教育\n\n\nClaude 3/4\n长上下文理解\n复杂逻辑，代码审查\n\n\nChatGPT-4/4.5\n自然语言优先\n快速原型，学习\n\n\n\n\n\n4.4 Vibe Coding 实战示例\n场景：创建一个待办事项应用\n传统方式：\n// 需要手动编写所有代码\nimport React, { useState } from 'react';\n\nfunction TodoApp() {\n  const [todos, setTodos] = useState([]);\n  const [input, setInput] = useState('');\n  \n  const addTodo = () =&gt; {\n    if (input.trim()) {\n      setTodos([...todos, { id: Date.now(), text: input, done: false }]);\n      setInput('');\n    }\n  };\n  \n  // ... 还需要写 toggle、delete、filter 等功能\n  \n  return (\n    // ... JSX 代码\n  );\n}\nVibe Coding 方式：\n用户：\"创建一个漂亮的待办事项应用，要有：\n- 添加任务的功能\n- 标记完成/未完成\n- 删除任务\n- 按状态筛选（全部/进行中/已完成）\n- 使用现代简洁的设计风格\n- 数据保存在 localStorage\"\n\nAI：（生成完整可运行的代码）\n\n用户：\"把完成任务的动画做得更流畅一些，\n再加一个进度统计在顶部\"\n\nAI：（更新代码）\n\n\n4.5 Vibe Coding 的核心理念\n\n设计优先，快速原型：先描述想要的感觉和体验，再迭代细节\n对话式调试：用自然语言问”为什么这个会失败？“而不是查文档一小时\n关注产品而非语法：把精力集中在用户体验和业务逻辑上\n迭代速度至上：快速实验，快速验证，快速调整\n\n\n\n4.6 Vibe Coding 的优势与风险\n优势： - ✅ 极大提升开发速度（10倍加速在 build-test 周期） - ✅ 降低编程门槛，非技术人员也能构建原型 - ✅ 减少样板代码的编写 - ✅ 加速学习和实验\n风险与争议： - ⚠️ 安全漏洞：AI 生成的代码可能存在安全隐患，需要人工审查 - ⚠️ 技术债务：快速生成的代码可能缺乏长期可维护性 - ⚠️ 理解深度：开发者可能不完全理解 AI 生成的代码 - ⚠️ 调试困难：当 AI 生成的代码出错时，定位问题可能更困难\n最佳实践： &gt; “Vibe Coding 不是完全替代传统开发，而是改变开发者的角色 —— 从逐行编写代码，转变为指导、测试和优化 AI 生成的输出。开发者成为 AI 的导师，确保生成的代码符合项目需求和最佳实践。”"
  },
  {
    "objectID": "content/blogs/entries/PromptContextSkills.html#第五章整合与展望-四层架构的统一视图",
    "href": "content/blogs/entries/PromptContextSkills.html#第五章整合与展望-四层架构的统一视图",
    "title": "Prompt->Context->Skills",
    "section": "第五章：整合与展望 —— 四层架构的统一视图",
    "text": "第五章：整合与展望 —— 四层架构的统一视图\n\n5.1 四个层次的演进关系\n┌─────────────────────────────────────────────────────────────────┐\n│                    第四层：Vibe Coding                           │\n│              （人类与 AI 协作的最高形态）                          │\n│         开发者描述意图 → AI 生成完整应用 → 迭代优化               │\n├─────────────────────────────────────────────────────────────────┤\n│                    第三层：Skills & Agentic AI                   │\n│              （AI 的行动能力和协作能力）                           │\n│    MCP（工具连接） + A2A（Agent 协作） + Function Calling        │\n├─────────────────────────────────────────────────────────────────┤\n│                    第二层：Context Engineering                   │\n│              （AI 的知识环境和记忆系统）                           │\n│         RAG + 记忆管理 + 上下文组合 + 外部数据注入                │\n├─────────────────────────────────────────────────────────────────┤\n│                    第一层：Prompt Engineering                    │\n│              （与 AI 对话的基础能力）                              │\n│         Zero/Few-Shot + CoT + ReAct + 结构化输出                │\n└─────────────────────────────────────────────────────────────────┘\n\n\n5.2 各层之间的依赖关系\n\nPrompt Engineering 是基础：所有上层都依赖于如何有效地与模型沟通\nContext Engineering 是增强：让模型能够访问更多信息和知识\nSkills/Agentic AI 是跃迁：让模型从”说话”到”行动”\nVibe Coding 是融合：重新定义人类在 AI 时代的角色\n\n\n\n5.3 2025-2026 年的关键趋势\n\n趋势 1：协议标准化\nMCP 和 A2A 正在快速成为行业标准，类似于： - MCP ≈ USB-C：统一 AI 与工具的连接方式 - A2A ≈ HTTP：统一 AI 与 AI 的通信方式\n\n\n趋势 2：Agent 经济崛起\n据 2025 年全球 AI 调查： - 29% 的企业已经在生产环境运行 Agentic AI - 44% 计划在未来一年内加入 - 88% 的早期采用者报告了正向 ROI\n\n\n趋势 3：开发者角色转型\n开发者的工作正在从：\n编写代码 → 架构设计 + AI 协作 + 代码审查\n\n\n趋势 4：多 Agent 协作成为常态\n复杂任务将由多个专业 Agent 协作完成： - 研究 Agent + 写作 Agent + 审查 Agent - 前端 Agent + 后端 Agent + 测试 Agent - 数据分析 Agent + 可视化 Agent + 报告 Agent\n\n\n\n5.4 给初学者的学习路径\n阶段 1：掌握 Prompt Engineering（1-2 周） - 学习 Zero/Few-Shot、CoT、ReAct 等基础技术 - 练习编写清晰、具体的提示 - 理解模型的能力和局限性\n阶段 2：理解 Context Engineering（2-3 周） - 学习 RAG 原理和实现 - 了解向量数据库（Pinecone、Weaviate、Chroma） - 实践构建有记忆的对话系统\n阶段 3：探索 Tool Use & Agents（3-4 周） - 学习 Function Calling - 了解 MCP 协议 - 尝试构建简单的 Agent\n阶段 4：实践 Vibe Coding（持续） - 使用 Cursor、Copilot 等工具 - 从小项目开始，逐步建立信任 - 保持批判性思维，审查 AI 生成的代码\n\n\n5.5 给技术从业者的深度建议\n\n深入理解协议层：MCP 和 A2A 将成为基础设施，理解它们的设计哲学\n关注 Agent 架构：学习 ReAct、ToT、Reflexion 等推理模式\n掌握编排能力：多 Agent 系统的协调、状态管理、错误恢复\n保持工程纪律：AI 再强大，软件工程的基本原则依然适用"
  },
  {
    "objectID": "content/blogs/entries/PromptContextSkills.html#结语人机协作的新纪元",
    "href": "content/blogs/entries/PromptContextSkills.html#结语人机协作的新纪元",
    "title": "Prompt->Context->Skills",
    "section": "结语：人机协作的新纪元",
    "text": "结语：人机协作的新纪元\n从 Prompt Engineering 到 Context Engineering，从 Tool Use 到 Vibe Coding，我们正见证着人机协作方式的根本性转变。\n这不仅仅是技术的演进，更是认知范式的转移：\n\n过去：人类告诉计算机”如何做”（How）\n现在：人类告诉 AI”做什么”（What）\n未来：人类与 AI 共同探索”为什么做”（Why）\n\n在这个新时代，最宝贵的技能不再是记住最多的 API 或写出最优雅的算法，而是：\n\n清晰表达意图的能力 —— 知道你想要什么\n批判性评估的能力 —— 判断 AI 输出是否正确\n系统思考的能力 —— 理解各部分如何协同工作\n持续学习的能力 —— 适应快速变化的技术 landscape\n\n正如 Vibe Coding 所揭示的，未来的开发者可能不再是”代码的编写者”，而是”智能的编排者”。而 Prompt Engineering、Context Engineering、Skills 这些层次，正是构建这个新世界的基石。\n无论你是初学者还是资深工程师，现在都是最好的入场时机。因为在这个领域，每个人都在学习，每天都有新发现，每个参与者都有机会塑造未来。"
  },
  {
    "objectID": "content/blogs/entries/PromptContextSkills.html#参考资源",
    "href": "content/blogs/entries/PromptContextSkills.html#参考资源",
    "title": "Prompt->Context->Skills",
    "section": "参考资源",
    "text": "参考资源\nPrompt Engineering： - Prompt Engineering Best Practices 2025 - The Complete Prompt Engineering Guide for 2025\nContext Engineering： - What is Context Engineering? - Context Engineering: Best Practices & Examples\nAgentic AI & Protocols： - Model Context Protocol - Anthropic - Agent2Agent Protocol - Google - The Rise of Autonomous AI Agents\nVibe Coding： - Vibe Coding in 2025 - What is Vibe Coding? - Vibe Coding: Fun, AI-Assisted Programming"
  },
  {
    "objectID": "content/blogs/entries/Hot 100(golang).html",
    "href": "content/blogs/entries/Hot 100(golang).html",
    "title": "Hot100(golang)",
    "section": "",
    "text": "记录一下经典leetcode hot100的解题思路和题解"
  },
  {
    "objectID": "content/blogs/entries/Hot 100(golang).html#哈希",
    "href": "content/blogs/entries/Hot 100(golang).html#哈希",
    "title": "Hot100(golang)",
    "section": "哈希",
    "text": "哈希\n\n1. 两数之和\n\n题解\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\nfunc twoSum(nums []int, target int) (ans []int) {\n    mp := map[int]int{}\n\n    for idx, num := range nums {\n        if i, ok := mp[target-num]; ok {\n            ans = []int{i, idx}\n        }\n        mp[num] = idx\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        nums   []int\n        target int\n        ans    []int\n    }{\n        {nums: []int{2, 7, 11, 15}, target: 9, ans: []int{0, 1}},\n        {nums: []int{3, 2, 4}, target: 6, ans: []int{1, 2}},\n        {nums: []int{3, 3}, target: 6, ans: []int{0, 1}},\n    }\n\n    for _, t := range testCases {\n        fmt.Println(reflect.DeepEqual(twoSum(t.nums, t.target), t.ans))\n    }\n}\n\n\n\n\n\n49. 字母异位词分组\n\n题解\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"slices\"\n)\n\nfunc groupAnagrams(strs []string) [][]string {\n    mp := map[string][]string{}\n\n    for _, str := range strs {\n        s := []byte(str)\n        slices.Sort(s)\n        mp[string(s)] = append(mp[string(s)], str)\n    }\n\n    ans := make([][]string, 0, len(mp))\n\n    for i := range mp {\n        ans = append(ans, mp[i])\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        strs []string\n        ans  [][]string\n    }{\n        {\n            []string{\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"},\n            [][]string{\n                {\"eat\", \"tea\", \"ate\"},\n                {\"tan\", \"nat\"},\n                {\"bat\"},\n            },\n        },\n        {\n            []string{\"\"},\n            [][]string{\n                {\"\"},\n            },\n        },\n        {\n            []string{\"a\"},\n            [][]string{\n                {\"a\"},\n            },\n        },\n    }\n\n    for _, t := range testCases {\n        fmt.Println(reflect.DeepEqual(groupAnagrams(t.strs), t.ans))\n    }\n}\n\n\n\n\n\n128. 最长连续序列\n\n题解\npackage main\n\nimport \"fmt\"\n\nfunc longestConsecutive(nums []int) int {\n    ans := 0\n    mp := map[int]bool{}\n\n    for _, num := range nums {\n        mp[num] = true\n    }\n\n    for i := range mp {\n        if mp[i-1] == true {\n            continue\n        }\n        cnt := 1\n\n        for mp[i+1] == true {\n            i += 1\n            cnt += 1\n        }\n\n        ans = max(ans, cnt)\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        nums []int\n        ans  int\n    }{\n        {[]int{100, 4, 200, 1, 3, 2}, 4},\n        {[]int{0, 3, 7, 2, 5, 8, 4, 6, 0, 1}, 9},\n        {[]int{1, 0, 1, 2}, 3},\n    }\n\n    for _, t := range testCases {\n        fmt.Println(longestConsecutive(t.nums) == t.ans)\n    }\n}"
  },
  {
    "objectID": "content/projects/index.html",
    "href": "content/projects/index.html",
    "title": "Projects项目",
    "section": "",
    "text": "Project write-ups, demos, and technical summaries.\n\n\n\n\n\n\n\n\n\n\n\n\nDaily Log Maker\n\n\n\nselfTools\n\n前端\n\n每日记录\n\n\n\n\n\n\n\n\n\n\nNov 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nGesture-Fireworks\n\n\n\nselfTools\n\n前端\n\n手指烟花\n\nFireworks\n\n\n\n\n\n\n\n\n\n\nNov 16, 2025\n\n\n\n\n\n\n\n\n\n\n\nQuarto-Blogs-Template\n\n\n\nQuarto\n\nBlog\n\n\n\n\n\n\n\n\n\n\nNov 16, 2025\n\n\n\n\n\n\n\n\n\n\n\ngo-zero-demo\n\n\n\ngolang\n\n微服务\n\ndemo\n\n\n\n\n\n\n\n\n\n\nJan 11, 2025\n\n\n\n\n\n\n\n\n\n\n\nGoLink\n\n\n\ngolang\n\ngo-zero\n\ndemo\n\nshortUrl\n\n\n\n\n\n\n\n\n\n\nJan 11, 2025\n\n\n\n\n\n\n\n\n\n\n\nGoList\n\n\n\ngolang\n\nkratos\n\ndemo\n\nlist\n\n\n\n\n\n\n\n\n\n\nJan 11, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/papers/index.html",
    "href": "content/papers/index.html",
    "title": "Paper&Report论文和技术报告",
    "section": "",
    "text": "记录论文和技术报告阅读\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDeepSeek\n\n\n\nLLM\n\nPaper\n\nReport\n\nDeepSeek\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n个人研究相关论文阅读笔记\n\n\n\n个人研究\n\nLabNotes\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/learning-notes/microservices/index.html",
    "href": "content/learning-notes/microservices/index.html",
    "title": "微服务学习笔记",
    "section": "",
    "text": "记录一下微服务学习过程中的笔记.主要语言还是golang.\n相关代码仓库github: aorangehc/GoFramwork\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKratos 微服务框架\n\n\n\ngolang\n\n微服务\n\nKratos\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\ngo-zero的API语言\n\n\n\ngolang\n\n微服务\n\napi\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nGo-Kit 微服务框架\n\n\n\ngolang\n\n微服务\n\ngo-kit\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nGo-Zero 微服务框架\n\n\n\ngolang\n\n微服务\n\ngo-zero\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nProtobuf\n\n\n\ngolang\n\n微服务\n\nProtobuf\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n微服务框架(golang)\n\n\n\ngolang\n\n微服务\n\n框架\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/learning-notes/index.html",
    "href": "content/learning-notes/index.html",
    "title": "Learning Notes学习笔记",
    "section": "",
    "text": "课程学习笔记.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngo的版本管理工具-g的安装和使用\n\n\n\ngolang\n\ng\n\ngolang版本管理\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nKratos 微服务框架\n\n\n\ngolang\n\n微服务\n\nKratos\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\ngo-zero的API语言\n\n\n\ngolang\n\n微服务\n\napi\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nGo-Kit 微服务框架\n\n\n\ngolang\n\n微服务\n\ngo-kit\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nGo-Zero 微服务框架\n\n\n\ngolang\n\n微服务\n\ngo-zero\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nProtobuf\n\n\n\ngolang\n\n微服务\n\nProtobuf\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n微服务框架(golang)\n\n\n\ngolang\n\n微服务\n\n框架\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nConsul\n\n\n\ngolang\n\n微服务\n\n基础设施\n\nconsul\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n基础设施(golang)\n\n\n\ngolang\n\n微服务\n\n基础设施\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（13）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 20, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（12）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 20, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（11）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 20, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（10）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 20, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（9）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 19, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（8）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 18, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（7）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 17, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（6）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 16, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（5）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 14, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（4）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 13, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（3）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nSep 29, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（2）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nSep 23, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（1）-在win搭建go环境\n\n\n\ngolang\n\n环境搭建\n\n\n\n\n\n\n\n\n\nSep 16, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n通过案例了解机器学习\n\n\n\n深度学习\n\n深度学习基础\n\n\n\n\n\n\n\n\n\nAug 26, 2024\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/learning-notes/deepL/index.html",
    "href": "content/learning-notes/deepL/index.html",
    "title": "深度学习学习笔记",
    "section": "",
    "text": "记录一下深度学习相关的学习笔记.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n通过案例了解机器学习\n\n\n\n深度学习\n\n深度学习基础\n\n\n\n\n\n\n\n\n\nAug 26, 2024\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/blogs/index.html",
    "href": "content/blogs/index.html",
    "title": "Blogs博客",
    "section": "",
    "text": "Short essays, reviews, and research notes.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHot100(golang)\n\n\n\nLeetcode\n\nHot100\n\nGolang\n\n\n\n\n\n\n\n\n\nJan 1, 2026\n\n\n\n\n\n\n\n\n\n\n\n\nPrompt-&gt;Context-&gt;Skills\n\n\n\nPrompt\n\nContext\n\nSkills\n\nVibe-Coding\n\n\n\n\n\n\n\n\n\nJan 1, 2026\n\n\n\n\n\n\n\n\n\n\n\n\n一文了解RAG\n\n\n\nRAG\n\nLLM\n\n\n\n\n\n\n\n\n\nJan 1, 2026\n\n\n\n\n\n\n\n\n\n\n\n\n一文了解VLM\n\n\n\nVLM\n\nLLM\n\n\n\n\n\n\n\n\n\nJan 1, 2026\n\n\n\n\n\n\n\n\n\n\n\n\n本地服务器低速传输解决方案\n\n\n\n技术\n\n技术实践\n\nssh\n\n网络\n\n\n\n\n\n\n\n\n\nDec 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nMac安装Jekyll\n\n\n\nGitHub\n\nBlog\n\nJekyll\n\n\n\n\n\n\n\n\n\nOct 24, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nPC的快捷指令\n\n\n\nWindows\n\nMac\n\nLinux\n\nInstruction\n\n\n\n\n\n\n\n\n\nOct 24, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nWindows安装Jekyll\n\n\n\nGitHub\n\nBlog\n\nJekyll\n\n\n\n\n\n\n\n\n\nOct 24, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n基于BM25检索算法构建RAG智能文档问答助手–学习和实践\n\n\n\n大模型\n\nRAG\n\n信息检索\n\n智能助手\n\n\n\n\n\n\n\n\n\nMar 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nDeepseek-R1-32B模型部署\n\n\n\n大模型\n\n部署\n\nDeepseek\n\n\n\n\n\n\n\n\n\nJan 25, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n如何使用git\n\n\n\n技术\n\ngit\n\n指令\n\n\n\n\n\n\n\n\n\nJan 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n开源协议\n\n\n\n技术\n\n技术理论\n\n\n\n\n\n\n\n\n\nJan 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n一种免费、高清、安全、但是很麻烦的远程桌面连接方案\n\n\n\n技术\n\n技术实践\n\n\n\n\n\n\n\n\n\nJan 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n保姆教程如何创建自己的“个人网站”\n\n\n\nGitHub\n\nBlog\n\nJekyll\n\n\n\n\n\n\n\n\n\nSep 15, 2024\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "pages/index.html",
    "href": "pages/index.html",
    "title": "About Me关于我",
    "section": "",
    "text": "我是 aorangehc(He Cheng)\n\n\n这是我的邮箱，欢迎联系：morange0205@gmail.com\n\n\n\n\n\ngolang后端开发\n\n\n大模型应用开发\n\n\nLLM实现和部署\n\n\n\n\n\n\n\n2024 - 2027 [硕士学位/网络空间安全] [北京邮电大学]\n\n\n2020 - 2024 [学士学位/计算机科学与技术] [北方工业大学]\n\n\n\n\n\n\n\n[2025.1-2025.7] [科研实习] [中科院软件所] — [MindSpore框架下经典NLP模型复现和优化]\n\n\n[2025.8-2025.10] [后端开发实习] [长亭科技] — [参与长亭科技项目的后端开发、多模态RAG拓展和项目优化]\n\n\n\n\n\n\n\n[年份] [项目名称] [一句话描述/亮点] GitHub · Blog\n\n\n\n\n\n\nGolang 开发 LLM 深度学习 联邦学习\n\n\n\n\n\nI am aorangehc(He Cheng)\n\n\nThis is my email, feel free to contact me: morange0205@gmail.com\n\n\n\n\n\nGolang Backend Development\n\n\nLarge Model Application Development\n\n\nLLM Implementation and Deployment\n\n\n\n\n\n\n\n2024 - 2027 [Master’s Degree/Cyberspace Security] [Beijing University of Posts and Telecommunications]\n\n\n2020 - 2024 [Bachelor’s Degree/Computer Science and Technology] [North China University of Technology]\n\n\n\n\n\n\n\n[Jan 2025 - Jul 2025] [Research Intern] [Institute of Software, Chinese Academy of Sciences] — [Reproduction and optimization of classic NLP models under MindSpore framework]\n\n\n[Aug 2025 - Oct 2025] [Backend Development Intern] [Chaitin Technology] — [Participated in backend development, multimodal RAG expansion and project optimization for Chaitin Technology projects]\n\n\n\n\n\n\n\n[Years] [Project Name] [One-sentence Description/Highlight] GitHub · Blog\n\n\n\n\n\n\nGolang Development LLM Deep Learning Federated Learning"
  },
  {
    "objectID": "pages/index.html#方向",
    "href": "pages/index.html#方向",
    "title": "About Me关于我",
    "section": "",
    "text": "golang后端开发\n\n\n大模型应用开发\n\n\nLLM实现和部署"
  },
  {
    "objectID": "pages/index.html#教育经历",
    "href": "pages/index.html#教育经历",
    "title": "About Me关于我",
    "section": "",
    "text": "2024 - 2027 [硕士学位/网络空间安全] [北京邮电大学]\n\n\n2020 - 2024 [学士学位/计算机科学与技术] [北方工业大学]"
  },
  {
    "objectID": "pages/index.html#工作经历",
    "href": "pages/index.html#工作经历",
    "title": "About Me关于我",
    "section": "",
    "text": "[2025.1-2025.7] [科研实习] [中科院软件所] — [MindSpore框架下经典NLP模型复现和优化]\n\n\n[2025.8-2025.10] [后端开发实习] [长亭科技] — [参与长亭科技项目的后端开发、多模态RAG拓展和项目优化]"
  },
  {
    "objectID": "pages/index.html#项目",
    "href": "pages/index.html#项目",
    "title": "About Me关于我",
    "section": "",
    "text": "[年份] [项目名称] [一句话描述/亮点] GitHub · Blog"
  },
  {
    "objectID": "pages/index.html#技术栈",
    "href": "pages/index.html#技术栈",
    "title": "About Me关于我",
    "section": "",
    "text": "Golang 开发 LLM 深度学习 联邦学习"
  },
  {
    "objectID": "pages/index.html#focus-areas",
    "href": "pages/index.html#focus-areas",
    "title": "About Me关于我",
    "section": "",
    "text": "Golang Backend Development\n\n\nLarge Model Application Development\n\n\nLLM Implementation and Deployment"
  },
  {
    "objectID": "pages/index.html#education",
    "href": "pages/index.html#education",
    "title": "About Me关于我",
    "section": "",
    "text": "2024 - 2027 [Master’s Degree/Cyberspace Security] [Beijing University of Posts and Telecommunications]\n\n\n2020 - 2024 [Bachelor’s Degree/Computer Science and Technology] [North China University of Technology]"
  },
  {
    "objectID": "pages/index.html#experience",
    "href": "pages/index.html#experience",
    "title": "About Me关于我",
    "section": "",
    "text": "[Jan 2025 - Jul 2025] [Research Intern] [Institute of Software, Chinese Academy of Sciences] — [Reproduction and optimization of classic NLP models under MindSpore framework]\n\n\n[Aug 2025 - Oct 2025] [Backend Development Intern] [Chaitin Technology] — [Participated in backend development, multimodal RAG expansion and project optimization for Chaitin Technology projects]"
  },
  {
    "objectID": "pages/index.html#projects",
    "href": "pages/index.html#projects",
    "title": "About Me关于我",
    "section": "",
    "text": "[Years] [Project Name] [One-sentence Description/Highlight] GitHub · Blog"
  },
  {
    "objectID": "pages/index.html#technical-skills",
    "href": "pages/index.html#technical-skills",
    "title": "About Me关于我",
    "section": "",
    "text": "Golang Development LLM Deep Learning Federated Learning"
  },
  {
    "objectID": "pages/home.html",
    "href": "pages/home.html",
    "title": "Home主页",
    "section": "",
    "text": "这里是首页，汇总各模块最近更新内容。\n\n\nThis is the home page with the latest updates from each module.\n\n\n\nBlogs博客\n\n\n\n\n\n\n\n\n\n\n\nHot100(golang)\n\n\n\nLeetcode\n\nHot100\n\nGolang\n\n\n\n\n\n\n\n\n\nJan 1, 2026\n\n\n\n\n\n\n\n\n\n\n\n\nPrompt-&gt;Context-&gt;Skills\n\n\n\nPrompt\n\nContext\n\nSkills\n\nVibe-Coding\n\n\n\n\n\n\n\n\n\nJan 1, 2026\n\n\n\n\n\n\n\n\n\n\n\n\n一文了解RAG\n\n\n\nRAG\n\nLLM\n\n\n\n\n\n\n\n\n\nJan 1, 2026\n\n\n\n\n\nNo matching items\n\n\n\n\nProjects项目\n\n\n\n\n\n\n\n\n\nDaily Log Maker\n\n\n\nselfTools\n\n前端\n\n每日记录\n\n\n\n\n\n\n\n\n\n\nNov 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nGesture-Fireworks\n\n\n\nselfTools\n\n前端\n\n手指烟花\n\nFireworks\n\n\n\n\n\n\n\n\n\n\nNov 16, 2025\n\n\n\n\n\n\n\n\n\n\n\nQuarto-Blogs-Template\n\n\n\nQuarto\n\nBlog\n\n\n\n\n\n\n\n\n\n\nNov 16, 2025\n\n\n\n\n\n\nNo matching items\n\n\n\n\nPapers论文\n\n\n\n\n\n\n\n\n\n\n\nDeepSeek\n\n\n\nLLM\n\nPaper\n\nReport\n\nDeepSeek\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n个人研究相关论文阅读笔记\n\n\n\n个人研究\n\nLabNotes\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\nNo matching items\n\n\n\n\nLearning Notes学习笔记\n\n\n\n\n\n\n\n\n\n\n\ngolang实现hot100题解(ACM版本)\n\n\n\n算法\n\nleetcode\n\nhot100\n\n\n\n\n\n\n\n\n\nNov 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nleetcode-灵神跟练-滑动窗口与双指针-不定长滑动窗口-越长越合法+求最短+最小\n\n\n\n算法\n\nleetcode\n\n滑动窗口\n\n不定长滑动窗口\n\n\n\n\n\n\n\n\n\nNov 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nleetcode-灵神跟练-滑动窗口与双指针-定长滑动窗口-基础\n\n\n\n算法\n\nleetcode\n\n滑动窗口与双指针\n\n\n\n\n\n\n\n\n\nNov 9, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/learning-notes/algorithm/index.html",
    "href": "content/learning-notes/algorithm/index.html",
    "title": "算法学习笔记",
    "section": "",
    "text": "不开long long见祖宗，不过golang没long long(笑)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngolang实现hot100题解(ACM版本)\n\n\n\n算法\n\nleetcode\n\nhot100\n\n\n\n\n\n\n\n\n\nNov 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nleetcode-灵神跟练-滑动窗口与双指针-不定长滑动窗口-越长越合法+求最短+最小\n\n\n\n算法\n\nleetcode\n\n滑动窗口\n\n不定长滑动窗口\n\n\n\n\n\n\n\n\n\nNov 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nleetcode-灵神跟练-滑动窗口与双指针-定长滑动窗口-基础\n\n\n\n算法\n\nleetcode\n\n滑动窗口与双指针\n\n\n\n\n\n\n\n\n\nNov 9, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/learning-notes/golang/index.html",
    "href": "content/learning-notes/golang/index.html",
    "title": "golang",
    "section": "",
    "text": "记录一下golang学习过程中的笔记.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngo的版本管理工具-g的安装和使用\n\n\n\ngolang\n\ng\n\ngolang版本管理\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（13）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 20, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（12）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 20, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（11）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 20, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（10）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 20, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（9）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 19, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（8）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 18, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（7）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 17, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（6）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 16, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（5）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 14, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（4）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 13, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（3）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nSep 29, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（2）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nSep 23, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（1）-在win搭建go环境\n\n\n\ngolang\n\n环境搭建\n\n\n\n\n\n\n\n\n\nSep 16, 2024\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/learning-notes/infrastructure/index.html",
    "href": "content/learning-notes/infrastructure/index.html",
    "title": "基础设施学习笔记",
    "section": "",
    "text": "记录一下基础设施相关的学习笔记.\n基础设施是指支撑应用程序运行的硬件、软件和网络资源。它包括服务器、存储设备、网络设备、操作系统、数据库等。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConsul\n\n\n\ngolang\n\n微服务\n\n基础设施\n\nconsul\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n基础设施(golang)\n\n\n\ngolang\n\n微服务\n\n基础设施\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/papers/deepseek/index.html",
    "href": "content/papers/deepseek/index.html",
    "title": "DeepSeek",
    "section": "",
    "text": "DeepSeek论文阅读笔记\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDeepSeek\n\n\n\nLLM\n\nPaper\n\nReport\n\nDeepSeek\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/papers/labnotes/index.html",
    "href": "content/papers/labnotes/index.html",
    "title": "个人研究相关论文",
    "section": "",
    "text": "个人研究相关论文阅读笔记\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n个人研究相关论文阅读笔记\n\n\n\n个人研究\n\nLabNotes\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/blogs/entries/Deepseek-R1-32B模型部署.html",
    "href": "content/blogs/entries/Deepseek-R1-32B模型部署.html",
    "title": "Deepseek-R1-32B模型部署",
    "section": "",
    "text": "这段时间国产大模型deepseek受到广泛关注，deepseek也开源了他们模型的参数，在huggingface上，提供了原始模型和经过不同程度蒸馏的模型\n因为好奇，手边刚好也有之前白嫖的阿里云的服务器，就尝试一下本地部署的过程\n本文简单介绍一下部署的过程，也提供一个gradio的示例，进行模型的使用\n\n\n\n\n免费试用，可以选择交互式建模进行试用。\n\n\n注册阿里云账号并选择试用即可\n\n\n\n\n\n首先在阿里云创建一个实例\n\n然后选择选择A10的GPU和图中所示的镜像\n\n之后等待实例创建完成，进入实例环境，点击右上方加号，进入命令行\n\n\n\n\n\n在命令行进行模型下载与测试\n\n1、设置Hugging Face镜像源\n export HF_ENDPOINT=https://hf-mirror.com\n2、下载DeepSeek-R1 32B模型\nhuggingface-cli download Valdemardi/DeepSeek-R1-Distill-Qwen-32B-AWQ --cache-dir /mnt/workspace/Valdemardi/DeepSeek-R1-Distill-Qwen-32B-AWQ\n3、测试模型是否能加载成功\n vllm serve Valdemardi/DeepSeek-R1-Distill-Qwen-32B-AWQ --quantization awq_marlin --max-model-len 1024 --max-num-batched-tokens 2048 --max-num-seqs 1 --tensor-parallel-size 1 --port 8003 --enforce-eager --gpu_memory_utilization=0.90 --enable-chunked-prefill\n\n相关参数说明： quantization awq_marlin：启用AWQ量化，显著降低显存占用。 max-model-len 1024：设置最大序列长度为1024个token，适用于大部分NLP任务。 max-num-batched-tokens 2048：设置批量处理的token数为512，平衡处理速度和显存占用。 max-num-seqs 1：设置同时处理的序列数为1，避免多序列处理带来的显存碎片。 tensor-parallel-size 1：禁用 tensor 并行，最大化利用显存。 port 8003：设置服务监听端口为8003。 enforce-eager：启用 eager 模式，加快推理速度。 gpu_memory_utilization 0.90：设置显存使用率为98%，尽可能多地利用显存。 enable-chunked-prefill：启用分块预填充，减少显存碎片。\n\n\n\n\n\n\n使用gradio加载vllm推理模型，进行可视化交互，使用的代码如下：\n\nimport gradio as gr\nimport requests\nfrom subprocess import Popen, PIPE\nimport threading\nimport time\nimport json\n\n# ============== 配置参数 ==============\nMODEL_NAME = \"DeepSeek-R1-Distill-Qwen-32B-AWQ\"\nVLLM_PORT = 8003\nGRADIO_PORT = 7860\n\nVLLM_CMD = [\n    \"vllm\", \"serve\", MODEL_NAME,\n    \"--quantization\", \"awq\",\n    \"--max-model-len\", \"1024\",\n    \"--max-num-batched-tokens\", \"2048\",\n    \"--max-num-seqs\", \"1\",\n    \"--tensor-parallel-size\", \"1\",\n    \"--port\", str(VLLM_PORT),\n    \"--gpu-memory-utilization\", \"0.9\",\n    \"--enforce-eager\",\n    \"--disable-log-requests\",\n    \"--swap-space\", \"16\"\n]\n\n# ============== 服务管理类 ==============\nclass VLLMServer:\n    def __init__(self):\n        self.process = None\n        self._ready = threading.Event()\n        self.start_time = time.time()\n\n    def start(self):\n        try:\n            print(f\"正在加载模型 {MODEL_NAME}...\")\n            self.process = Popen(VLLM_CMD, stdout=PIPE, stderr=PIPE, text=True)\n            \n            def log_monitor():\n                while self.process.poll() is None:\n                    line = self.process.stderr.readline()\n                    if \"Uvicorn running\" in line:\n                        print(\"vLLM服务启动成功！\")\n                        self._ready.set()\n                    if time.time() - self.start_time &gt; 600:\n                        print(\"模型加载超时，请检查显存是否足够\")\n                        self.process.terminate()\n                    print(\"[vLLM]\", line.strip())\n            \n            threading.Thread(target=log_monitor, daemon=True).start()\n            return True\n        except Exception as e:\n            print(f\"vLLM启动失败: {str(e)}\")\n            return False\n\n    def is_ready(self, timeout=600):\n        return self._ready.wait(timeout=timeout)\n\n# ============== 提示词构建 ==============\ndef build_prompt(history):\n    prompt = \"&lt;|beginofutterance|&gt;system\\n你是一个智能助手&lt;|endofutterance|&gt;\\n\"\n    for entry in history:\n        if entry[\"role\"] == \"user\":\n            prompt += f\"&lt;|beginofutterance|&gt;user\\n{entry['content']}&lt;|endofutterance|&gt;\\n\"\n        elif entry[\"role\"] == \"assistant\":\n            prompt += f\"&lt;|beginofutterance|&gt;assistant\\n{entry['content']}&lt;|endofutterance|&gt;\\n\"\n    prompt += \"&lt;|beginofutterance|&gt;assistant\\n\"\n    return prompt\n\n# ============== 流式生成逻辑 ==============\ndef stream_generator(history):\n    try:\n        response = requests.post(\n            f\"http://localhost:{VLLM_PORT}/v1/completions\",\n            headers={\"Content-Type\": \"application/json\"},\n            json={\n                \"model\": MODEL_NAME,\n                \"prompt\": build_prompt(history),\n                \"max_tokens\": 512,\n                \"temperature\": 0.7,\n                \"top_p\": 0.9,\n                \"stop\": [\"&lt;|endofutterance|&gt;\"],\n                \"stream\": True\n            },\n            stream=True,\n            timeout=120\n        )\n        response.raise_for_status()\n        \n        full_response = \"\"  # 用于缓存完整的助手回答\n        for chunk in response.iter_lines():\n            if chunk:\n                decoded = chunk.decode().replace(\"data: \", \"\")\n                try:\n                    data = json.loads(decoded)\n                    token = data[\"choices\"][0][\"text\"]\n                    full_response += token\n                    yield full_response  # 返回完整的生成内容（逐步追加）\n                except:\n                    pass\n                    \n    except requests.exceptions.ConnectionError:\n        yield \"服务未就绪，请稍后重试\"\n    except Exception as e:\n        yield f\"请求失败: {str(e)}\"\n\n# ============== 界面布局 ==============\nwith gr.Blocks(title=\"DeepSeek-32B vLLM版\") as demo:\n    gr.Markdown(\"## DeepSeek-R1-32B 智能助手 (vLLM版)\")\n    \n    status = gr.Textbox(label=\"服务状态\", interactive=False)\n    chatbot = gr.Chatbot(\n        height=500,\n        type=\"messages\",\n        label=\"对话历史\",\n        avatar_images=(\"user.png\", \"bot.png\")\n    )\n    msg = gr.Textbox(label=\"输入消息\", placeholder=\"请输入您的问题...\")\n    clear = gr.Button(\"清空历史\", variant=\"secondary\")\n\n    def user(user_message, history):\n        return \"\", history + [{\"role\": \"user\", \"content\": user_message}]\n\n    def bot(history):\n        if not history or history[-1][\"role\"] != \"user\":\n            yield history\n            return\n            \n        history.append({\"role\": \"assistant\", \"content\": \"\"})  # 添加空的助手消息\n        full_response = \"\"  # 用于存储完整回答\n        for chunk in stream_generator(history):\n            full_response = chunk  # 缓存生成的内容\n            yield history[:-1] + [{\"role\": \"assistant\", \"content\": full_response}]  # 更新生成的回答\n        \n        # 最终更新完整历史记录\n        history[-1][\"content\"] = full_response\n        yield history\n\n    msg.submit(user, [msg, chatbot], [msg, chatbot], queue=True).then(\n        bot, chatbot, chatbot\n    )\n    clear.click(lambda: [], None, chatbot, queue=False)\n\n    # 状态检查\n    demo.load(\n        fn=lambda: \"服务已就绪\" if vllm_server.is_ready() else \"启动中...\",\n        outputs=status\n    )\n\nif __name__ == \"__main__\":\n    vllm_server = VLLMServer()\n    print(\"正在启动vLLM服务...\")\n    threading.Thread(target=vllm_server.start, daemon=True).start()\n    \n    if vllm_server.is_ready():\n        print(\"启动Gradio界面...\")\n        demo.launch(\n            server_name=\"0.0.0.0\",\n            server_port=GRADIO_PORT,\n            share=False\n        )\n    else:\n        print(\"服务启动失败\")\n\n\n\n\n\n\n运行成功后点击下方链接即可打开界面\n\n\n\n\n从图中测试可以看出，数学方面好像有提升，但是草莓问题中的’r’还是不能数出有多少\n\n\n\n\n\n使用3090单显卡部署deepseek-r1 32B"
  },
  {
    "objectID": "content/blogs/entries/Deepseek-R1-32B模型部署.html#白嫖阿里云服务器",
    "href": "content/blogs/entries/Deepseek-R1-32B模型部署.html#白嫖阿里云服务器",
    "title": "Deepseek-R1-32B模型部署",
    "section": "",
    "text": "免费试用，可以选择交互式建模进行试用。\n\n\n注册阿里云账号并选择试用即可"
  },
  {
    "objectID": "content/blogs/entries/Deepseek-R1-32B模型部署.html#模型下载和加载测试",
    "href": "content/blogs/entries/Deepseek-R1-32B模型部署.html#模型下载和加载测试",
    "title": "Deepseek-R1-32B模型部署",
    "section": "",
    "text": "首先在阿里云创建一个实例\n\n然后选择选择A10的GPU和图中所示的镜像\n\n之后等待实例创建完成，进入实例环境，点击右上方加号，进入命令行\n\n\n\n\n\n在命令行进行模型下载与测试\n\n1、设置Hugging Face镜像源\n export HF_ENDPOINT=https://hf-mirror.com\n2、下载DeepSeek-R1 32B模型\nhuggingface-cli download Valdemardi/DeepSeek-R1-Distill-Qwen-32B-AWQ --cache-dir /mnt/workspace/Valdemardi/DeepSeek-R1-Distill-Qwen-32B-AWQ\n3、测试模型是否能加载成功\n vllm serve Valdemardi/DeepSeek-R1-Distill-Qwen-32B-AWQ --quantization awq_marlin --max-model-len 1024 --max-num-batched-tokens 2048 --max-num-seqs 1 --tensor-parallel-size 1 --port 8003 --enforce-eager --gpu_memory_utilization=0.90 --enable-chunked-prefill\n\n相关参数说明： quantization awq_marlin：启用AWQ量化，显著降低显存占用。 max-model-len 1024：设置最大序列长度为1024个token，适用于大部分NLP任务。 max-num-batched-tokens 2048：设置批量处理的token数为512，平衡处理速度和显存占用。 max-num-seqs 1：设置同时处理的序列数为1，避免多序列处理带来的显存碎片。 tensor-parallel-size 1：禁用 tensor 并行，最大化利用显存。 port 8003：设置服务监听端口为8003。 enforce-eager：启用 eager 模式，加快推理速度。 gpu_memory_utilization 0.90：设置显存使用率为98%，尽可能多地利用显存。 enable-chunked-prefill：启用分块预填充，减少显存碎片。"
  },
  {
    "objectID": "content/blogs/entries/Deepseek-R1-32B模型部署.html#gradio交互",
    "href": "content/blogs/entries/Deepseek-R1-32B模型部署.html#gradio交互",
    "title": "Deepseek-R1-32B模型部署",
    "section": "",
    "text": "使用gradio加载vllm推理模型，进行可视化交互，使用的代码如下：\n\nimport gradio as gr\nimport requests\nfrom subprocess import Popen, PIPE\nimport threading\nimport time\nimport json\n\n# ============== 配置参数 ==============\nMODEL_NAME = \"DeepSeek-R1-Distill-Qwen-32B-AWQ\"\nVLLM_PORT = 8003\nGRADIO_PORT = 7860\n\nVLLM_CMD = [\n    \"vllm\", \"serve\", MODEL_NAME,\n    \"--quantization\", \"awq\",\n    \"--max-model-len\", \"1024\",\n    \"--max-num-batched-tokens\", \"2048\",\n    \"--max-num-seqs\", \"1\",\n    \"--tensor-parallel-size\", \"1\",\n    \"--port\", str(VLLM_PORT),\n    \"--gpu-memory-utilization\", \"0.9\",\n    \"--enforce-eager\",\n    \"--disable-log-requests\",\n    \"--swap-space\", \"16\"\n]\n\n# ============== 服务管理类 ==============\nclass VLLMServer:\n    def __init__(self):\n        self.process = None\n        self._ready = threading.Event()\n        self.start_time = time.time()\n\n    def start(self):\n        try:\n            print(f\"正在加载模型 {MODEL_NAME}...\")\n            self.process = Popen(VLLM_CMD, stdout=PIPE, stderr=PIPE, text=True)\n            \n            def log_monitor():\n                while self.process.poll() is None:\n                    line = self.process.stderr.readline()\n                    if \"Uvicorn running\" in line:\n                        print(\"vLLM服务启动成功！\")\n                        self._ready.set()\n                    if time.time() - self.start_time &gt; 600:\n                        print(\"模型加载超时，请检查显存是否足够\")\n                        self.process.terminate()\n                    print(\"[vLLM]\", line.strip())\n            \n            threading.Thread(target=log_monitor, daemon=True).start()\n            return True\n        except Exception as e:\n            print(f\"vLLM启动失败: {str(e)}\")\n            return False\n\n    def is_ready(self, timeout=600):\n        return self._ready.wait(timeout=timeout)\n\n# ============== 提示词构建 ==============\ndef build_prompt(history):\n    prompt = \"&lt;|beginofutterance|&gt;system\\n你是一个智能助手&lt;|endofutterance|&gt;\\n\"\n    for entry in history:\n        if entry[\"role\"] == \"user\":\n            prompt += f\"&lt;|beginofutterance|&gt;user\\n{entry['content']}&lt;|endofutterance|&gt;\\n\"\n        elif entry[\"role\"] == \"assistant\":\n            prompt += f\"&lt;|beginofutterance|&gt;assistant\\n{entry['content']}&lt;|endofutterance|&gt;\\n\"\n    prompt += \"&lt;|beginofutterance|&gt;assistant\\n\"\n    return prompt\n\n# ============== 流式生成逻辑 ==============\ndef stream_generator(history):\n    try:\n        response = requests.post(\n            f\"http://localhost:{VLLM_PORT}/v1/completions\",\n            headers={\"Content-Type\": \"application/json\"},\n            json={\n                \"model\": MODEL_NAME,\n                \"prompt\": build_prompt(history),\n                \"max_tokens\": 512,\n                \"temperature\": 0.7,\n                \"top_p\": 0.9,\n                \"stop\": [\"&lt;|endofutterance|&gt;\"],\n                \"stream\": True\n            },\n            stream=True,\n            timeout=120\n        )\n        response.raise_for_status()\n        \n        full_response = \"\"  # 用于缓存完整的助手回答\n        for chunk in response.iter_lines():\n            if chunk:\n                decoded = chunk.decode().replace(\"data: \", \"\")\n                try:\n                    data = json.loads(decoded)\n                    token = data[\"choices\"][0][\"text\"]\n                    full_response += token\n                    yield full_response  # 返回完整的生成内容（逐步追加）\n                except:\n                    pass\n                    \n    except requests.exceptions.ConnectionError:\n        yield \"服务未就绪，请稍后重试\"\n    except Exception as e:\n        yield f\"请求失败: {str(e)}\"\n\n# ============== 界面布局 ==============\nwith gr.Blocks(title=\"DeepSeek-32B vLLM版\") as demo:\n    gr.Markdown(\"## DeepSeek-R1-32B 智能助手 (vLLM版)\")\n    \n    status = gr.Textbox(label=\"服务状态\", interactive=False)\n    chatbot = gr.Chatbot(\n        height=500,\n        type=\"messages\",\n        label=\"对话历史\",\n        avatar_images=(\"user.png\", \"bot.png\")\n    )\n    msg = gr.Textbox(label=\"输入消息\", placeholder=\"请输入您的问题...\")\n    clear = gr.Button(\"清空历史\", variant=\"secondary\")\n\n    def user(user_message, history):\n        return \"\", history + [{\"role\": \"user\", \"content\": user_message}]\n\n    def bot(history):\n        if not history or history[-1][\"role\"] != \"user\":\n            yield history\n            return\n            \n        history.append({\"role\": \"assistant\", \"content\": \"\"})  # 添加空的助手消息\n        full_response = \"\"  # 用于存储完整回答\n        for chunk in stream_generator(history):\n            full_response = chunk  # 缓存生成的内容\n            yield history[:-1] + [{\"role\": \"assistant\", \"content\": full_response}]  # 更新生成的回答\n        \n        # 最终更新完整历史记录\n        history[-1][\"content\"] = full_response\n        yield history\n\n    msg.submit(user, [msg, chatbot], [msg, chatbot], queue=True).then(\n        bot, chatbot, chatbot\n    )\n    clear.click(lambda: [], None, chatbot, queue=False)\n\n    # 状态检查\n    demo.load(\n        fn=lambda: \"服务已就绪\" if vllm_server.is_ready() else \"启动中...\",\n        outputs=status\n    )\n\nif __name__ == \"__main__\":\n    vllm_server = VLLMServer()\n    print(\"正在启动vLLM服务...\")\n    threading.Thread(target=vllm_server.start, daemon=True).start()\n    \n    if vllm_server.is_ready():\n        print(\"启动Gradio界面...\")\n        demo.launch(\n            server_name=\"0.0.0.0\",\n            server_port=GRADIO_PORT,\n            share=False\n        )\n    else:\n        print(\"服务启动失败\")"
  },
  {
    "objectID": "content/blogs/entries/Deepseek-R1-32B模型部署.html#效果测试",
    "href": "content/blogs/entries/Deepseek-R1-32B模型部署.html#效果测试",
    "title": "Deepseek-R1-32B模型部署",
    "section": "",
    "text": "运行成功后点击下方链接即可打开界面\n\n\n\n\n从图中测试可以看出，数学方面好像有提升，但是草莓问题中的’r’还是不能数出有多少"
  },
  {
    "objectID": "content/blogs/entries/Deepseek-R1-32B模型部署.html#参考",
    "href": "content/blogs/entries/Deepseek-R1-32B模型部署.html#参考",
    "title": "Deepseek-R1-32B模型部署",
    "section": "",
    "text": "使用3090单显卡部署deepseek-r1 32B"
  },
  {
    "objectID": "content/blogs/entries/Mac安装Jekyll.html",
    "href": "content/blogs/entries/Mac安装Jekyll.html",
    "title": "Mac安装Jekyll",
    "section": "",
    "text": "更新了在Windows的Jekyll教程。顺便把环境在Mac上重新配置了一遍，把完整流程记录下来，给正在折腾博客的你一份可直接照做的macOS安装指南。\n\n本文默认你使用 zsh 终端（macOS 默认），并通过 rbenv 管理 Ruby 版本，避免系统自带 Ruby 的权限与兼容问题。\n\n\n\n\n\n\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n安装完成后，根据提示把 brew 加入 PATH，并重新打开终端或执行 source ~/.zshrc。\n\n\n\nbrew update\nbrew install rbenv ruby-build\n\n\n\necho 'eval \"$(rbenv init - zsh)\"' &gt;&gt; ~/.zshrc\nsource ~/.zshrc\n\n\n\n\n\n\n\nrbenv install 3.3.5\nrbenv global 3.3.5\nruby -v\n\n\n\ngem install bundler jekyll\n\n\n\n\n\n在你的博客主目录下运行：\nbundle install\nbundle exec jekyll serve\n看到成功提示后，在浏览器访问：\nhttp://127.0.0.1:4000\n\n\n\n\n恭喜！现在你已经在 macOS 上成功安装并运行了 Jekyll。后续可以在 _config.yml 中调整主题与配置、在 _posts 中编写文章，用 bundle exec jekyll build 生成静态文件进行部署。"
  },
  {
    "objectID": "content/blogs/entries/Mac安装Jekyll.html#第一步准备基础环境",
    "href": "content/blogs/entries/Mac安装Jekyll.html#第一步准备基础环境",
    "title": "Mac安装Jekyll",
    "section": "",
    "text": "/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n安装完成后，根据提示把 brew 加入 PATH，并重新打开终端或执行 source ~/.zshrc。\n\n\n\nbrew update\nbrew install rbenv ruby-build\n\n\n\necho 'eval \"$(rbenv init - zsh)\"' &gt;&gt; ~/.zshrc\nsource ~/.zshrc"
  },
  {
    "objectID": "content/blogs/entries/Mac安装Jekyll.html#第二步安装-ruby-与-jekyll",
    "href": "content/blogs/entries/Mac安装Jekyll.html#第二步安装-ruby-与-jekyll",
    "title": "Mac安装Jekyll",
    "section": "",
    "text": "rbenv install 3.3.5\nrbenv global 3.3.5\nruby -v\n\n\n\ngem install bundler jekyll"
  },
  {
    "objectID": "content/blogs/entries/Mac安装Jekyll.html#第三步在项目中安装依赖并启动",
    "href": "content/blogs/entries/Mac安装Jekyll.html#第三步在项目中安装依赖并启动",
    "title": "Mac安装Jekyll",
    "section": "",
    "text": "在你的博客主目录下运行：\nbundle install\nbundle exec jekyll serve\n看到成功提示后，在浏览器访问：\nhttp://127.0.0.1:4000"
  },
  {
    "objectID": "content/blogs/entries/Mac安装Jekyll.html#安装完成",
    "href": "content/blogs/entries/Mac安装Jekyll.html#安装完成",
    "title": "Mac安装Jekyll",
    "section": "",
    "text": "恭喜！现在你已经在 macOS 上成功安装并运行了 Jekyll。后续可以在 _config.yml 中调整主题与配置、在 _posts 中编写文章，用 bundle exec jekyll build 生成静态文件进行部署。"
  },
  {
    "objectID": "content/blogs/entries/Windows安装Jekyll.html",
    "href": "content/blogs/entries/Windows安装Jekyll.html",
    "title": "Windows安装Jekyll",
    "section": "",
    "text": "之前分享了如何在GitHub上搭建个人博客，但缺少Jekyll的安装教程。最近换了新电脑，正好借此机会补上这个重要的环节，为想要搭建技术博客的朋友们提供一份详细的Windows安装指南。\n\n\nJekyll基于Ruby开发，所以我们首先需要安装Ruby环境：\n\n访问Ruby官网下载适合你的RubyInstaller\n我选择的是rubyinstaller-devkit-3.4.7-1-x64版本\n你也可以根据系统配置选择合适的版本\n\n\n安装时的关键步骤：\n\n双击下载的安装程序，按提示进行安装\n重要：务必勾选”添加到PATH”选项，方便在命令行中直接使用\n安装过程中会自动安装MSYS2，这是后续安装gem和Jekyll的必要组件\n\n\n安装完成后，打开命令提示符测试是否安装成功：\nruby -v\n\n\n\n\nRubyGems是Ruby的包管理器，我们需要用它来安装Jekyll：\n\n前往RubyGems下载页面\n选择ZIP格式下载\n\n\n安装步骤：\n\n将下载的ZIP文件解压到合适的目录\n在解压后的文件夹中打开命令提示符\n运行安装命令：\n\nruby setup.rb\n\n\n\n\n现在我们可以开始安装Jekyll了：\n安装Jekyll核心：\ngem install jekyll\n安装分页插件（很多主题都需要）：\ngem install jekyll-paginate\n验证安装是否成功：\njekyll -v\n\n\n\n在你的Jekyll博客目录中，启动本地服务器：\nbundle exec jekyll server\n如果提示缺少某些插件，按照提示安装即可：\n\n安装完成后重新运行，看到成功提示：\n\n在浏览器中访问 http://localhost:4000，就能看到你的博客在本地运行的效果了！\n\n\n\n\n恭喜！现在你已经在Windows上成功安装了Jekyll，可以开始本地开发和测试你的博客了。如果在安装过程中遇到任何问题，欢迎在评论区留言交流。\n贴心提示：建议将整个安装过程记录下来，这样下次换电脑或者重装系统时就能快速完成环境配置。\n参考资源：在Windows上安装Jekyll\n博客作者简介 大家好，我是一名热爱分享的技术博主，专注于Web开发和开源技术。通过这个博客，我希望与大家分享我的学习心得和实践经验，帮助更多开发者解决实际问题。如果你对技术分享感兴趣，欢迎关注我的博客，我们一起成长！"
  },
  {
    "objectID": "content/blogs/entries/Windows安装Jekyll.html#第一步安装ruby环境",
    "href": "content/blogs/entries/Windows安装Jekyll.html#第一步安装ruby环境",
    "title": "Windows安装Jekyll",
    "section": "",
    "text": "Jekyll基于Ruby开发，所以我们首先需要安装Ruby环境：\n\n访问Ruby官网下载适合你的RubyInstaller\n我选择的是rubyinstaller-devkit-3.4.7-1-x64版本\n你也可以根据系统配置选择合适的版本\n\n\n安装时的关键步骤：\n\n双击下载的安装程序，按提示进行安装\n重要：务必勾选”添加到PATH”选项，方便在命令行中直接使用\n安装过程中会自动安装MSYS2，这是后续安装gem和Jekyll的必要组件\n\n\n安装完成后，打开命令提示符测试是否安装成功：\nruby -v"
  },
  {
    "objectID": "content/blogs/entries/Windows安装Jekyll.html#第二步安装rubygems",
    "href": "content/blogs/entries/Windows安装Jekyll.html#第二步安装rubygems",
    "title": "Windows安装Jekyll",
    "section": "",
    "text": "RubyGems是Ruby的包管理器，我们需要用它来安装Jekyll：\n\n前往RubyGems下载页面\n选择ZIP格式下载\n\n\n安装步骤：\n\n将下载的ZIP文件解压到合适的目录\n在解压后的文件夹中打开命令提示符\n运行安装命令：\n\nruby setup.rb"
  },
  {
    "objectID": "content/blogs/entries/Windows安装Jekyll.html#第三步安装jekyll及相关组件",
    "href": "content/blogs/entries/Windows安装Jekyll.html#第三步安装jekyll及相关组件",
    "title": "Windows安装Jekyll",
    "section": "",
    "text": "现在我们可以开始安装Jekyll了：\n安装Jekyll核心：\ngem install jekyll\n安装分页插件（很多主题都需要）：\ngem install jekyll-paginate\n验证安装是否成功：\njekyll -v"
  },
  {
    "objectID": "content/blogs/entries/Windows安装Jekyll.html#第四步本地测试",
    "href": "content/blogs/entries/Windows安装Jekyll.html#第四步本地测试",
    "title": "Windows安装Jekyll",
    "section": "",
    "text": "在你的Jekyll博客目录中，启动本地服务器：\nbundle exec jekyll server\n如果提示缺少某些插件，按照提示安装即可：\n\n安装完成后重新运行，看到成功提示：\n\n在浏览器中访问 http://localhost:4000，就能看到你的博客在本地运行的效果了！"
  },
  {
    "objectID": "content/blogs/entries/Windows安装Jekyll.html#安装完成",
    "href": "content/blogs/entries/Windows安装Jekyll.html#安装完成",
    "title": "Windows安装Jekyll",
    "section": "",
    "text": "恭喜！现在你已经在Windows上成功安装了Jekyll，可以开始本地开发和测试你的博客了。如果在安装过程中遇到任何问题，欢迎在评论区留言交流。\n贴心提示：建议将整个安装过程记录下来，这样下次换电脑或者重装系统时就能快速完成环境配置。\n参考资源：在Windows上安装Jekyll\n博客作者简介 大家好，我是一名热爱分享的技术博主，专注于Web开发和开源技术。通过这个博客，我希望与大家分享我的学习心得和实践经验，帮助更多开发者解决实际问题。如果你对技术分享感兴趣，欢迎关注我的博客，我们一起成长！"
  },
  {
    "objectID": "content/blogs/entries/一文了解RAG.html",
    "href": "content/blogs/entries/一文了解RAG.html",
    "title": "一文了解RAG",
    "section": "",
    "text": "RAG（Retrieval Augmented Generation）：检索增强生成"
  },
  {
    "objectID": "content/blogs/entries/一文了解RAG.html#引言",
    "href": "content/blogs/entries/一文了解RAG.html#引言",
    "title": "一文了解RAG",
    "section": "0 引言",
    "text": "0 引言\n写在前面，作者也是初学者，抱着学习的心态写了这篇文章，如果有问题，欢迎大家邮箱联系进行批评指正。\n本篇将系统介绍RAG的基本概念、核心技术原理、发展背景和典型架构，随后深入探讨多模态RAG（如文本-图像、文本-视频的检索增强生成）和Graph RAG（基于图结构数据的检索增强生成）等前沿方向，最后分析当前面临的挑战与未来发展趋势。"
  },
  {
    "objectID": "content/blogs/entries/一文了解RAG.html#基本概念",
    "href": "content/blogs/entries/一文了解RAG.html#基本概念",
    "title": "一文了解RAG",
    "section": "1 基本概念",
    "text": "1 基本概念\nRAG（Retrieval Augmented Generation），中文名称是检索增强生成，通俗意义上来讲就是通过检索提升大模型生成效果的技术，旨在提升生成式AI的准确性与可信度。它实现了大语言模型与外部知识库的结合，是缓解幻觉与提升可追溯性的关键路线之一。该概念最初由Facebook AI研究团队在2020年提出，并发表了命名RAG的开创性论文。如今，RAG已发展为一类庞大的方法体系，被认为是通向更可靠生成式AI的重要方向。"
  },
  {
    "objectID": "content/blogs/entries/一文了解RAG.html#背景和技术原理",
    "href": "content/blogs/entries/一文了解RAG.html#背景和技术原理",
    "title": "一文了解RAG",
    "section": "2 背景和技术原理",
    "text": "2 背景和技术原理\n\n2. 1 背景\n大模型在没有外部知识库的情况下也能”记住”大量知识，但仍然存在明显局限：参数中的知识更新成本高、回答往往缺少可核验的证据来源；遇到冷门知识、最新信息或长链路推理时，错误率会上升；在多轮对话与长上下文场景里，也可能出现信息遗忘、主题漂移与证据混淆等问题。\n比如，你问的是aorangehc是谁，它却开始讲爱因斯坦是谁，这类与问题无关或事实不符的生成通常被称为幻觉（LLM Hallucination)。幻觉并非某一个模型的偶然故障，而是概率式生成在信息不足、目标不清或证据缺失时容易出现的系统性现象，因此研究者开始从模型之外引入约束与外部信息来降低这类问题的发生。\n一种方法是在预训练之后对模型进行指令微调与对齐训练，让它在不确定时更倾向于回答”不知道”或主动澄清。一种方法是使用者通过Prompt对回答范围、证据要求与输出格式进行限制，减少模型自由发挥的空间。\n还有一种就是引入外部知识库。我们现在使用ChatGPT、Gemini、Kimi、豆包以及DeepSeek等大模型应用时，经常会看到联网搜索或知识库问答功能：系统会根据问题去外部数据源检索网页或文档片段，将检索结果作为证据提供给模型，再由模型基于证据与自身语言能力组织答案，从而显著提升事实性与可解释性。这个”先检索、再生成”的过程，就是RAG的典型范式。\n\n\n2.2 技术原理\n现在意义上的大模型具有很多能力，我们日常中更多是使用大模型进行提问，让它解决遇到的难题，比如Python代码报错，把报错信息扔给大模型，它给出修改意见，这个过程中使用的主要能力是指令遵循。除此之外还有上下文学习、推理、工具使用等，随着技术的发展，大模型可调用的能力在不断扩展。\n在RAG中主要利用的就是大模型的上下文学习能力，通过检索获取相关知识作为上下文提供给大模型，然后由大模型基于问题与证据进行归纳总结并生成回答。\nRAG的核心思想是在生成任务中引入检索模块。模型在接到输入后，先由检索模块从外部知识库（如维基百科、专有文档库、企业内部资料等）中检索出相关资料，再将检索到的内容与原始输入一起送入生成模型，生成最终回答或文本。这种”检索-生成”策略使模型能够现查现用所需知识，而不必完全依赖参数中存储的旧知识。OpenAI的WebGPT工作即是典型案例：它让GPT-3在一个受控的浏览环境中搜索网页、抽取引用片段并据此回答长问题，从而提升答案的事实性与可核验性。通过引入检索，不仅能降低幻觉发生率，也使知识库可以更灵活地扩展与更新，例如用户可以按需接入新的数据源供系统使用。\n自RAG提出后，各大研究团队纷纷推出改进的检索增强模型。例如，DeepMind在2021年发布的RETRO模型通过接入超大规模文本数据库进行检索增强，在较小参数规模下取得了与当时超大模型相当甚至在部分基准上更优的效果，体现了检索对”以更小模型获得更强知识能力”的潜力。又如Meta在2022年推出的Atlas模型，将预训练的检索增强语言模型用于少样本学习，在开放域问答等知识密集任务上，用显著更少的参数规模取得了与超大模型相竞争的表现。这些成果表明，检索增强可以在更小模型规模下达到甚至逼近超大模型的效果，凸显了参数与检索融合的效率优势与工程价值。"
  },
  {
    "objectID": "content/blogs/entries/一文了解RAG.html#rag框架",
    "href": "content/blogs/entries/一文了解RAG.html#rag框架",
    "title": "一文了解RAG",
    "section": "3 RAG框架",
    "text": "3 RAG框架\n\n图片引用自文献Retrieval-Augmented Generation for AI-Generated Content: A Survey\n典型RAG系统包含检索器与生成器两大核心组件。\n\n3.1 RAG基本流程\n首先，输入查询会被检索模块编码为向量表示，并在外部知识库的向量索引中进行相似度搜索，检索出若干相关文本片段，并可能应用重排序技术来提高精度。随后，这些检索到的证据片段与原始查询一并提供给生成模型，模型将基于问题与证据生成最终回答。通过将外部知识融入生成过程，RAG能够让回答更贴近事实，并在工程实现上支持给出引用来源与证据片段，从而提升可解释性与可审计性。\n经典RAG在生成整个回答时往往使用固定的一组检索文档；也有更高级的变体如RAG-Token，可以在生成过程中对不同位置动态使用不同检索证据，从而提升信息使用的灵活性。\n无论哪种方式，检索结果与生成模型的融合都是关键。很多实现会将检索文本直接拼接到模型输入中，而一些研究也探索在模型内部以更结构化的方式利用检索信息，使模型在生成时能更稳定地对齐证据、减少无关发挥。实践中，检索器与生成器既可以分阶段独立优化，也可以在特定设定下进行联合训练或端到端微调，以让检索器更偏向于返回对生成最有帮助的证据、生成器也更善于引用与整合证据。\n\n\n3.2 检索器\n检索是指根据信息需求识别并获取相关信息。具体来说，我们可以将信息资源视为一个键值存储，其中每个键对应一个值，键和值可以相同。给定一个查询，目标是使用相似性函数搜索出最相似的前k个键，并获取与之配对的值。根据不同的相似性函数，现有的检索方法可分为稀疏检索、稠密检索及其他类型。\n\n3.2.1 稀疏检索器\n稀疏检索器利用词项匹配指标，如TF-IDF、BM25，主要用于文档的相关检索。这些方法通过分析文本中的词统计信息并构建倒排索引来实现高效搜索。本质上，BM25是大规模网络搜索中的一个强大基线，它整合了逆文档频率权重、查询词项出现次数和其他相关指标。\n\n\n3.2.2 稠密检索器\n稠密检索通过稠密嵌入向量来表示查询和键，并构建近似最近邻索引加快搜索速度，能用于所有模态的检索。稠密检索将原本的数据通过预训练模型编码成为向量，然后通过计算相似度分数进行检索，相似度计算可以通过余弦、内积和L2距离等。\n现在的RAG系统为了提升效果一般采用稀疏检索+稠密检索的混合检索模式，提升效果。\n\n\n\n3.3 生成器\n生成器结合检索到的内容，生成所需内容。\n随着AIGC时代的发展，生成器也不断发展丰富成熟，不同的生成器模型可以用于不同的场景，比如\n\nTransformer模型用于文本到文本的任务\nVisualGPT可以用于图像到文本的任务\nStable Diffusion可以用于文本到图像的任务\nCodex可以用于文本到代码的任务"
  },
  {
    "objectID": "content/blogs/entries/一文了解RAG.html#rag增强",
    "href": "content/blogs/entries/一文了解RAG.html#rag增强",
    "title": "一文了解RAG",
    "section": "4 RAG增强",
    "text": "4 RAG增强\n是的检索增强生成(的)增强也是很重要的研究点，有很多技巧。\n\n4.1 输入增强\n最初输入到检索器中的内容对检索阶段的最终结果有显著影响，输入增强的方式主要有以下几种。\n\n4.1.1 查询转换\n查询转换可以通过修改输入查询来增强检索结果。\nQuery2doc和HyDE，利用原始查询生成伪文档，之后将该伪文档用作检索的查询。伪文档包含更丰富的相关信息，有助于检索出更准确的结果。\nTOC利用检索到的内容，将模糊的查询分解为多个清晰的子查询，这些子查询被发送到生成器，经聚合后产生最终结果。对于。\nRQ-RAG将复杂或模糊的查询分解为清晰的子查询以进行细粒度检索，并对响应进行综合，从而为原始查询提供连贯的答案\n\n\n4.1.2 数据增强\n数据增强表示在检索前对数据进行改进，包括去除无关信息、消除歧义、更新过时文档、合成新数据等技术\nMake-An-Audio利用字幕生成和音频-文本检索为无语言音频生成字幕，以缓解数据稀疏问题，并添加随机概念音频来改进原始音频。\nLESS通过分析梯度信息优化下游任务的数据集选择，旨在提升模型对指令提示的响应性能。\nReACC通过重命名和死代码插入来预训练代码检索模型。\n\n\n\n4.2 检索器增强\n\n4.2.1 递归检索\n归检索是指执行多次搜索以获取更丰富、更高质量的内容。\nReACT利用思维链（CoT）将查询分解以进行递归检索，并提供更丰富的信息。\nRATP采用蒙特卡洛树搜索进行模拟，以选择最优的检索内容，然后将其模板化并转发给生成器进行输出。\n\n\n4.2.2 块优化\n块优化指的是调整块大小以改善检索结果。\nLlamaIndex集成了一系列 chunk 优化方法，其中一种遵循”从小到大”的原则。其核心思想是精准定位更细粒度的内容，同时返回更丰富的信息。例如，句子窗口检索会获取小的文本块，并返回检索片段周围的相关句子窗口。在自动合并检索中，文档被组织成树状结构。该过程先获取子节点，再检索包含其子节点内容的父节点。\nRAPTOR采用递归嵌入、聚类和文本块摘要的方法，直到无法进一步聚类为止，从而构建多层树状结构。\nPrompt-RAG通过预先生成目录来提高检索准确性，使模型能够根据查询自主选择相关章节。\n\n\n4.2.3 检索器微调\n在稠密检索中检索器依赖于一个高效的嵌入模型，来表示相关内容并为生成器提供输入，从而提升系统性能。\n可以通过特定领域或任务相关的数据进行微调，以提升在目标领域的性能。\nREPLUG将语言模型视为黑盒，并根据最终结果更新检索模型。\nAPICoder使用Python文件以及API名称、签名和描述对检索模型进行微调。\nEDITSUM对检索模型进行微调，以减小检索后摘要之间的杰卡德距离。\n最新的模型Qwen3系列开源了多种embedding和rerank模型，并开放了技术报告，效果很好。其中小模型适合用来做微调测试和效果对比。\n\n\n4.2.4 混合检索\n混合检索指同时采用多种不同的检索方法或从多个不同的来源提取信息。\nRAP-Gen、BlendedRAG 和ReACC均同时使用密集检索器和稀疏检索器来提高检索质量。\nRencos使用稀疏检索器在句法层面检索相似的代码片段，并使用密集检索器在语义层面检索相似的代码片段。\nBASHEXPLAINER首先使用密集检索器捕获语义信息，然后使用稀疏检索器获取词汇信息。\nRetDream先通过文本进行检索，再通过图像嵌入进行检索。\nCRAG的特点是配备了一个检索评估器，用于衡量文档与查询的相关性，并根据置信度生成三种检索响应：如果结果准确，则直接用于知识优化；如果结果不正确，则进行网络搜索；对于模糊情况，则采用混合方法。\n\n\n4.2.5 Rerank\n重排序应该是最常见的方式，指对检索到的内容进行重新排序，以获得更高的多样性和更好的结果。也有很多重排序的模型开源可以使用。\nRe2G在传统检索器之后应用了一个重排序器模型，以减少因将文本压缩为向量而导致的信息丢失所带来的影响。\nAceCoder利用选择器对检索到的程序进行重排序，以减少冗余程序并获得多样化的检索程序。\nXRICL在检索后使用基于蒸馏的示例重排序器。\nRangan采用量化影响度量，通过评估查询和参考之间的统计偏差来衡量数据子集的相似性，并对检索结果进行重排序。\nUDAPDR利用大语言模型经济高效地生成用于训练特定领域重排序器的合成查询，然后应用多教师知识蒸馏来开发一个协同的检索器。\n\n\n4.2.6 检索转换\n检索转换通过重新表述检索到的内容，以更好地激发生成器的潜力，从而改进输出结果。\nFILCO能高效地从检索到的文本中清除无关内容，只保留相关的支持性内容，从而简化生成器的任务，有助于准确预测答案。\nFiD-Light首先使用编码器将检索到的内容转换为向量，然后对其进行压缩，大幅减少了延迟时间。\n\n\n\n4.3 生成器增强\n\n4.3.1 提示工程-Prompt Engineering\n提示工程是一种专注于提高大型语言模型输出质量的提示工程技术，如提示压缩、后退提示、主动提示、思维链提示等，均适用于检索增强生成系统中的大型语言模型生成器。\nLLMLingua应用一个小型模型来压缩查询的整体长度，以加速模型推理，减轻无关信息对模型的负面影响，并缓解中间迷失现象。\nReMoDiffuse通过使用ChatGPT将复杂描述分解为结构化文本脚本。\nASAP将包含输入代码、函数定义、分析结果和相应注释的示例元组纳入提示词中，以获得更好的结果。\nCEDAR使用设计好的提示词模板，将代码演示、查询和自然语言指令组织成提示词。\nXRICL利用思维链技术，在跨语言语义解析和推理中添加翻译对作为中间步骤。\nACTIVERAG采用认知连接机制来校准大语言模型的内在认知，并在答案生成中应用思维链提示词。\nMake-An-Audio能够使用其他模态作为输入，这可以为后续过程提供更丰富的信息。\n\n\n4.3.2 解码调优\n解码调优包括通过微调超参数来增强生成器控制，以提高多样性、限制输出词汇量以及进行其他调整。\nInferFix通过调整解码器的温度来平衡结果的多样性和质量。（温度可以理解为一个参数，控制模型生成内容的发散程度）\nSYNCHROMESH通过实施补全引擎来消除实现错误，从而限制解码器的输出词汇量。\n\n\n4.3.3 生成器微调\n生成器的微调可以增强模型掌握更精确领域知识的能力，或使其更好地与检索器相适配。\nRETRO固定了检索器的参数，并在生成器中使用分块交叉注意力机制来结合查询和检索器的内容。\nCARE 利用图像、音频和视频-文本对训练编码器，然后微调解码器（生成器）以同时减少字幕和概念检测损失，同时保持编码器和检索器固定。\nAnimate-A-Story利用图像数据优化视频生成器，然后微调LoRA适配器以捕捉给定角色的外观细节。\n\n\n\n4.4 结果增强\n\n4.4.1 输出重写\n输出重写指的是在特定场景下对生成器生成的内容进行改写，以满足下游任务的需求。\nSARGAM通过采用一种特殊的Transformer，结合删除分类器、占位符分类器和插入分类器，在代码相关任务中优化输出，使其更贴合现实世界的代码语境。\nRing根据生成器产生的每个令牌的对数概率平均值对候选结果进行重新排序，从而获得多样化的结果。\nCBR-KBQA通过将生成的关系与知识图谱中查询实体的本地邻域所呈现的关系进行对齐，来修正结果。\n\n\n\n4.5 流程增强 Pipeline Enhancement\nRAG流程增强指的是对RAG的整个流程进行优化，以获得更好的性能结果。\n\n4.5.1 自适应检索\n一些关于RAG的研究表明，检索并非总能提升最终结果。当模型固有的参数化知识足以回答相关问题时，过度检索可能会导致资源浪费，并可能造成混淆。因此有些方法研究是否应该进行RAG。\n\n基于规则\n\nFLARE会在生成过程中主动决定是否以及何时对概率进行搜索。\nEfficient-KNNLM将 KNN-LM 和 NPM的生成概率与超参数 λ 相结合，以确定生成和检索的比例。\n还有对问题进行统计分析，以便为高频问题提供直接答案，并对低频问题应用检索增强生成等。\n\n基于模型\n\nSelf-RAG使用训练过的生成器，根据不同用户查询下的检索令牌来决定是否执行检索。\nSKR利用大型语言模型自身的能力预先判断其是否能够回答该问题，若能回答，则不执行检索。\nRowen将一个问题翻译成多种语言，并检查这些语言版本答案的一致性，以此来决定是否需要信息检索。\nAdaptiveRAG通过一个较小的语言模型作为分类器，根据查询的复杂程度动态决定是否进行检索。\n\n\n\n\n4.5.2 迭代式检索增强生成\n迭代式检索增强生成通过在检索和生成阶段反复循环来逐步优化结果，实际就是进行多轮操作\nRepoCoder采用迭代检索-生成方法进行代码补全，利用先前生成的代码优化查询，以更好地利用分散的信息并改善结果。\nITER-RETGEN通过使用生成器的输出来确定知识缺口、检索必要信息并为未来的生成周期提供信息，从而迭代地提高内容质量。\nSelfMemory迭代地利用检索增强生成器来构建一个庞大的记忆池，记忆选择器从该池中挑选输出，为下一个生成周期提供信息。\nRAT首先由大语言模型通过零样本思维链提示生成内容，然后通过从外部知识库检索知识来修改每个思维步骤。"
  },
  {
    "objectID": "content/blogs/entries/一文了解RAG.html#rag的多跳多领域问题graph-rag",
    "href": "content/blogs/entries/一文了解RAG.html#rag的多跳多领域问题graph-rag",
    "title": "一文了解RAG",
    "section": "5 RAG的多跳多领域问题（Graph RAG）",
    "text": "5 RAG的多跳多领域问题（Graph RAG）\n在RAG中有一个非常经典的瓶颈问题：有些问题并不是在找某一段最相似的文本，而是在要求把分散在多篇文档、多个概念、甚至多个领域的线索串起来，形成综合结论。当回答需要沿着共享实体、属性或关系在不同信息片段间穿行，并在此基础上生成新的洞察时，单纯依赖向量相似度检索往往不够用。这就是RAG需要面对的多跳与多领域问题。\nGraphRAG（Graph Retrieval-Augmented Generation）可以被看作是为这两类问题准备的一条升级路线，它不只检索语义相近的文本块，而是把知识显式表示成图结构，例如从文本中抽取实体与关系形成知识图谱或图索引，并利用图中的关系结构来组织证据与推进推理。\nIBM对GraphRAG的定义很贴近工程实践：GraphRAG是一种引入图结构数据的高级RAG；不同于仅靠向量检索语义相似文本，它利用图的关系结构来检索与处理信息，尤其擅长多跳推理、关系上下文以及层级结构数据的组织与查询。"
  },
  {
    "objectID": "content/blogs/entries/一文了解RAG.html#多模态rag",
    "href": "content/blogs/entries/一文了解RAG.html#多模态rag",
    "title": "一文了解RAG",
    "section": "6 多模态RAG",
    "text": "6 多模态RAG\n\n6.1 多模态大模型\n随着大语言模型技术的不断发展，多模态甚至全模态大模型已经成为重要研究对象，并不断发展，现在多模态大模型也逐渐成为主流，给人们的生活带来便利，值得一提的是，gemini图像生成真的很强，下面的图就是它生成的，直观地展示了多模态大模型从早期的图文基础连接（如CLIP, DALL-E）起步，经历多感官融合（如GPT-4V, Gemini），最终迈向全模态实时交互与通用人工智能（AGI）的完整技术演进路线图。使用的提示词是：“生成一张介绍多模态大模型发展历程的图片”，很简单的提示词，但是生成的图挺科幻的。\n\n\n\n6.2 多模态检索增强生成\n随着多模态大模型的发展，研究者开始探索多模态检索增强生成（Multimodal RAG），即让系统不仅能检索文本，还能利用图像、音频、视频以及代码等多种数据源作为知识依据。比较特殊的是，RAG的核心思想和流程在不同模态之间基本保持一致，不过需要在检索器、生成器和相关技术细节上进行调整。\n多模态RAG的基本理念是：针对不同模态的数据，引入对应的编码器将它们映射到可比较的向量空间，从而支持跨模态检索。例如，系统可以将图像用视觉模型编码为向量、将文本用语言模型编码为向量，并建立统一或可对齐的检索索引。当用户以文本提出查询时，检索模块不仅可以返回相关文本片段，也可以返回相关图像、音频片段或视频片段作为补充信息。目前多模态检索最常见的是图文两种模态，更深入的细节往往与VLM相关，后面会进一步介绍。\n多模态RAG在需要综合视觉与文本信息的任务中展现出独特价值。例如在跨媒体问答场景中，用户给出一张图片并提出与之相关的问题，系统可以先对图像内容进行理解，再结合检索到的外部知识文本回答更深入的问题，例如图片中的人物背景、地点信息或历史事件脉络等。又如在视频问答或多媒体搜索中，系统可以综合检索字幕文本、视频关键帧、片段摘要乃至音频线索来获得更全面的信息。\n一些研究将多模态RAG用于视觉问答任务，证明结合图像内容与外部知识能够回答一些仅凭图像本身难以回答的问题。业界也出现了支持多模态检索的开源工具与框架，例如使用CLIP类模型编码图文以实现跨模态搜索。总体而言，多模态RAG拓展了传统RAG只能处理纯文本的限制，为系统提供了面向多模态世界的外部证据通道，使生成结果更丰富且更可核验。\n\n\n6.3 多模态RAG难题\n\n不同模态的数据格式各异，如何对齐多模态表示是关键，常见做法是基于大规模图文对、音频与转写文本等进行对比学习，使不同模态向量落在语义一致的空间中。\n检索过程可能需要在不同模态间跳转，例如以图搜文或以文搜图，这要求索引能够存储多模态信息并支持任意模态查询到任意模态内容。\n多模态数据规模大且检索计算开销高，尤其是在海量图像或视频片段上做近似最近邻检索时，对成本与延迟都是挑战。一些系统会采用先转文本再检索的策略，例如对图片做OCR或生成描述后再进入文本检索流程，以兼容现有文本检索体系，但这可能丢失关键视觉细节。更偏前沿的方法倾向于保留原始模态信息，让检索结果直接返回图像或视频内容，并由多模态生成模型端到端完成理解与生成，从而减少中间表示带来的信息损失。"
  },
  {
    "objectID": "content/blogs/entries/一文了解RAG.html#rag的应用",
    "href": "content/blogs/entries/一文了解RAG.html#rag的应用",
    "title": "一文了解RAG",
    "section": "7 RAG的应用",
    "text": "7 RAG的应用\n\n7.1 应用分类\n\n文本RAG\n\n问答：通过从海量且全面的文本资源集合中提取信息，对提出的问题做出回应。\n事实核查：通常是指判断给定的自然语言文本与相关的主张或断言是否与文本中的事实相符。\n常识推理：指的是机器利用所获取的外部知识及其应用，以类人的方式对问题或任务进行推断或做出决策的能力。\n人机对话：包括机器理解自然语言的能力，以及熟练运用这种技能与人类进行无缝交流的能力。\n神经机器翻译：将文本从源语言自动翻译为目标语言。\n事件抽取：这是自然语言处理中的一个过程，它涉及识别文本中的特定事件并对其进行分类，同时将这些事件与相关实体关联起来。\n摘要生成：从冗长的文本中提炼关键信息，并生成一个简洁、连贯的摘要，以概括主要主题。\n\n代码RAG\n\n代码生成：将自然语言描述转换为代码实现。\n代码摘要：将代码转换为自然语言描述。\n代码补全：代码补全类似于下一句预测任务的代码版本。\n自动程序修复：基于查询的RAG常用于自动程序修复中，以帮助生成模型修复有缺陷的代码\nText2SQL和基于代码的语义解析：语义解析将自然语言转换为清晰的结构化表示，例如SQL或其他特定领域语言，通常会借助代码的帮助。\n\n知识RAG\n\n知识库问答：通常利用知识库来确定问题的正确答案。\n知识增强的开放域问答：主要是对结构化知识的应用。\n表格问答：表格作为另一种结构化知识形式，也有助于问答。\n\n3D RAG\n\nText-2-3D：检索可用于增强3D资产生成。\n\n图像 RAG\n\n图像生成：指的是创建新图像的过程，通常运用人工智能和机器学习领域的算法。\n图像摘要： 是生成图像文本描述的过程。\n\n视频 RAG\n\n视频摘要：将视觉内容转化为描述性语句。\n视频问答和对话：视频问答与对话会生成与视频内容一致的单轮或多轮响应。\n\n音频 RAG\n\n音频字幕生成：音频 captioning 本质上是一项序列到序列任务，它为音频数据生成自然语言数据\n音频生成：通常根据自然语言提示合成音频。\n\n科学领域 RAG\n\n药物发现：药物发现的目标是生成能同时满足多种特性的分子。\n生物医学信息学增强：通过从生物医学领域特定数据库中检索信息，提高了大语言模型的表达能力，从而增强了模型为医疗领域的任务提供有价值指导的能力。\n数学问答：数学领域的检索增强生成技术简化了解题过程，促进了研究创新，并优化了教育策略。\n\n\n\n\n7.2 应用领域\n个人与企业内部知识库 这类应用致力于解决私有数据的检索与问答难题，它将公司内部文档、手册或个人笔记进行结构化处理与向量化索引，当用户提问时系统能够定位到文件中的相关段落并由大模型基于证据生成答案，从而在很多场景中替代传统关键词搜索并显著提升信息获取效率。\n学术论文深度阅读与溯源 针对科研人员需要处理海量文献且对准确性要求极高的场景，这类应用能够跨多篇论文检索证据并生成综述或回答，其核心特点是强调证据可追溯与引用对齐，尽可能让每一个关键结论都能回到原文依据，从而最大化降低幻觉带来的风险。\n超大规模代码库智能助手 为了解决传统大模型难以一次性读完完整项目代码的问题，这类应用会对代码仓库的结构、符号与依赖关系进行索引，让开发者能够用自然语言查询项目架构或具体函数实现细节，并在证据范围内给出解释与修改建议，从而更高效地理解与维护复杂的遗留代码。\n\n\n7.3 Ima\nima是腾讯开发的Ai知识库工具，核心就是采用RAG，目前支持导入公众号文章构建知识库进行检索。\n在公众号中文章中点击转发，将文章导入知识库，之后可以通过AI进行相关问答。\n\n\n\n7.4 Coze\nCoze空间是字节跳动旗下AI应用开发平台扣子，是一个多智能体协作开发环境，它允许开发者在一个统一的画布式界面中，将多个AI Agent、工具、数据源和工作流编排成复杂的自动化任务系统，实现从单一聊天机器人到多角色协同、多步骤执行的进阶AI应用构建。\n我们下面使用其中的Agent和知识库构建功能，构建一个八股问答姬。\n首先导入文本，构建知识库，然后创建智能体，并进行测试，测试能从知识库中检索对应信息，这是一个知识库RAG的应用。\n  \n\n\n7.5 Ragflow\nRAGFlow是领先的开源检索增强生成（RAG）引擎，它融合了尖端的RAG与智能体功能，为大语言模型打造卓越的上下文层。它提供了精简的RAG工作流，适用于任何规模的企业。在融合的上下文引擎和预制智能体模板的支持下，RAGFlow使开发者能够将复杂数据转化为高保真、可投入生产的人工智能系统，且效率和精度都极为出色。\n它可以进行本地部署和使用。"
  },
  {
    "objectID": "content/blogs/entries/一文了解RAG.html#数据集benchmark",
    "href": "content/blogs/entries/一文了解RAG.html#数据集benchmark",
    "title": "一文了解RAG",
    "section": "8 数据集&Benchmark",
    "text": "8 数据集&Benchmark\n\n8.1 Others;\n\n噪声鲁棒性，测试大型语言模型能否从含噪声的文档中提取必要信息\n负例拒绝，评估大型语言模型在检索到的内容不足时能否拒绝回答\n信息整合，检查大型语言模型能否通过整合多个检索到的内容来获取知识并进行回答\n反事实鲁棒性，判断大型语言模型能否识别检索到的内容中的反事实错误\n忠实性，基于检索到的内容评估事实准确性\n答案相关性，判断结果是否针对查询\n上下文相关性，评估检索到的内容的相关性及其简洁性\nCRUD-RAG将RAG任务分为四种类型：创建、读取、更新和删除，并通过文本续写、问答、幻觉纠正和开放域多文档摘要来对其进行评估\n我之前用过的数据集TreezzZ/WebQA，测试多模态效果，这玩意本身就是一个benchmark，包含问答对，通过简单脚本处理就能使用\n\n\n\n8.2 多模态RAG\n\n8.2.1 数据集\n\n\n\n图像-文本数据集\n\n\nLAION-400M：4亿对图文数据；用于多模态模型的预训练（图像-文本） Conceptual-Captions：超过300万对图像-标题；多语言的英德图像描述（图像-文本）CIRR：来自21,552张图像的36,554个三元组；侧重于自然图像关系（图像-文本）MS-COCO：33万张带字幕的图像；用于字幕到图像和图像到字幕的生成（图像-文本）Flickr30K：31K张图像，每张图像都配有5个英文 caption（图像-文本）Multi30K：30k条来自母语者的德语字幕和人工翻译的字幕（图像-文本）NoCaps：用于零样本图像 captioning 评估；15K 张图像（图像-文本）Laion-5B：58.5亿个图像-文本对被用作检索的外部存储器（图像-文本）COCO-CN：用于跨语言标记和带中文句子的图像描述的20,341张图像（图像-文本）CIRCO：1020个查询，每个查询平均有4.53个基准真值；用于组合图像检索（图像-文本）MINT-1T：1万亿个文本标记和34亿张图像；比现有的开源数据集大10倍（图像-文本）ShareGPT4V：120万张图片，配有GPT-4生成的说明文字，包括空间和事实细节（图像-文本）OmniCorpus：22亿个网页文档中的86亿张图像和1.7万亿个标记；交错的文本-图像布局（图像-文本）\n\n\n\n\n视频-文本数据集\n\n\nBDD-X：77小时的驾驶视频，配有专家的文字解释；用于可解释的驾驶行为研究（视频-文本）YouCook2：2000个带有对齐描述的烹饪视频；专注于视频-文本任务（视频-文本）ActivityNet：20,000个带有多个字幕的视频；用于视频理解和字幕生成（视频-文本）SoccerNet：550场足球比赛的视频和元数据；包括转录的解说和关键事件注释（视频-文本）MSVD：1970个视频，每个视频大约有40条字幕（视频-文本）LSMDC：来自202部电影的118,081个视频-文本对；一个电影描述数据集（视频-文本）DiDemo：10,000个视频，每个视频有4个拼接的字幕；包含事件的时间定位（视频-文本）COIN：涵盖180项任务的11,827个教学类YouTube视频，用于全面的教学视频分析（视频-文本）MSRVTT-QA：视频问答基准（视频-文本）ActivityNet-QA：58,000个人工标注的问答对，涉及5,800个视频；视频问答模型的基准（视频-文本）EpicKitchens-100：用于在线动作预测的700个视频（100小时的烹饪活动）；以自我为中心的视觉数据集（视频-文本）Ego4D：430万个以自我为中心的视频的视频-文本对；大规模以自我为中心的视频数据集（视频-文本）HowTo100M：来自120万个YouTube视频的1.36亿个带字幕的视频片段；用于学习文本-视频嵌入（视频-文本）CharadesEgo：来自第一视角和第三人称视角视频的68,536个活动实例；用于评估（视频-文本）ActivityNet：20K个视频，每个视频有3.7个时间定位的句子；对视频中的事件进行密集字幕标注（视频-文本）\n\n\n\n\n音频-文本数据集\n\n\nLibriSpeech：1000小时的英语朗读语音及对应文本；基于有声读物的语音识别语料库（音频-文本）SpeechBrown：55K对语音-文本样本；15个类别，涵盖从宗教到小说的各种主题（音频-文本）AudioCaps：46K个音频片段与人工编写的文本字幕配对（音频-文本）MusicCaps：它由5.5k个音乐-文本对组成，配有人类专家提供的丰富文本描述（音频-文本）Clotho：包含多样化音景的音频字幕数据集（音频-文本）WavCaps：大规模弱标记音频-文本数据集，包含约40万个带配对字幕的音频片段（音频-文本）Spoken SQuAD：SQuAD数据集的音频版本，用于口语问答，侧重于听力理解任务（音频-文本）AudioSet：来自YouTube的2,084,320个人工标注的10秒音频片段；632个音频事件类别（音频-文本）\n\n\n\n\n知识与问答数据集\n\n\nVQA：用于视觉问答的40万个带图像的问答对（图像-文本）PAQ：6500万个基于文本的问答对；一个大规模数据集（文本）ELI5：270K个复杂多样的问题，配有网页和图像作为补充（文本）MultimodalQA：29,918个需要对文本、表格和图像进行多模态多跳推理的问题（图像-文本-表格）ViQuAE：来自维基百科的1180万个段落，涵盖2397个独特实体；知识密集型问答（文本）OK-VQA：14K个需要外部知识的视觉问答问题（图像-文本）WebQA：46K个需要跨文本和图像进行推理的查询（图像-文本）Infoseek：使用基于维基百科的知识库（600万个段落）进行细粒度视觉知识检索（图像-文本）ClueWeb22：100亿个网页被分为三个子集；一个大规模的网络语料库（文本）MOCHEG：15,601个带有真实性标签的声明，并附有文本和图像证据（图像-文本）VQA：110万个问题（通过VG-QA问题扩充），用于微调VQA模型（图像-文本）A-OKVQA：使用世界知识进行视觉问答的基准；约25000个问题（图像-文本）XL-HeadTags：415K条新闻标题-文章对包含来自六个不同语系的20种语言（文本）DocVQA：12767张不同的文档图像，包含50K个问答对，按推理类型分类，用于评估文档视觉问答（DocVQA）方法（图像-文本）ChartQA：9.6K个人工编写的问答对 + 23.1K个从图表摘要生成的问答对（图像-文本）DVQA：30万个图表上的350万个问答对，用于评估结构、数据检索和推理能力（图像-文本）\n\n\n\n\n医学数据集\n\n\nMIMIC-CXR：125,417个胸部X光片和报告的训练对（图像-文本）CheXpert：65,240名患者的224,316张胸部X光片；专注于医学分析（图像-文本）MIMIC-III：超过4万名患者的健康相关数据（文本）IU-Xray：7470对胸部X光片和相应的诊断报告（图像-文本）PubLayNet：从PubLayNet构建了100,000个训练样本和2,160个测试样本（医疗领域定制）（图像-文本）Quilt-1M：438K张医学图像，配有768K个文本对；包含显微图像和UMLS实体（图像-文本）\n\n\n\n\n时尚数据集\n\n\nFashion-IQ：三个类别共77,684张图像；采用Recall@10和Recall@50进行评估 （图像-文本）FashionGen：260.5K 个时尚图像和物品描述的图像-文本对（图像-文本）VITON-HD：83K张用于虚拟试穿的图像；高分辨率服装物品（图像-文本）Fashionpedia：48,000张带有分割掩码和细粒度属性标注的时尚图像（图像-文本）DeepFashion：约80万张多样化的时尚图片，用于伪三元组生成（图像-文本）\n\n\n\n\n3D数据集\n\n\nShapeNet：涵盖55个常见物体类别，包含51300个独特的3D模型（3D-文本）\n\n\n\n\nOthers\n\n\nGeoDE：来自6个世界地区的40个类别中的61,940张图像；强调物体识别中的地理多样性（图像）RU-AI ：147万个真实内容与AI生成内容的样本，用于虚假检测的稳健性（图像-文本-音频）MIMIC-IT：用于模型对齐的280万个多模态指令-响应对（图像-视频-文本）MMVQA：横跨3146份多页研究PDF，包含26.2万个问答对，用于稳健的多模态信息检索（图像-文本）\n\n\n\n\n\n8.2.2 Benchmark\n\n\n\n跨模态\n\n\nMRAG-Bench：评估视觉检索、整合以及对不相关视觉信息的鲁棒性（图像）M2⁢R⁢A⁢G：对多模态检索增强生成（RAG）进行基准测试；评估检索、多跳推理和整合能力（图像-文本）Dyn-VQA：专注于动态检索、多跳推理以及对变化信息的鲁棒性（图像-文本）MMBench：涵盖视觉问答、图像描述、检索；评估跨视觉、文本和音频的跨模态理解能力（图像-文本-音频）ScienceQA：包含21,208个问题；通过文本、图表和图像测试科学推理能力（图像-表格-文本）SK-VQA：提供200万个问答对；专注于合成知识、多模态推理和外部知识整合（图像-文本）SMMQG：包含1024个问答对；侧重于合成多模态数据和受控问题生成（图像-文本）\n\n\n\n\n文本\n\n\nTriviaQA：提供65万个问答对；阅读理解数据集，适用于多模态检索增强生成（RAG）（文本）Natural Questions：包含307,373个训练示例；真实世界的搜索查询，可适配视觉语境（文本）\n\n\n\n\n\n8.2.3 评估指标\n\n检索评估\n\n准确率\n召回率和Recall@K：用于检查前K个结果中的相关项目，比标准召回率更受青睐\n精确率和Top-K准确率\n\n\n\nF1分数\n平均倒数排名（MRR）：用于衡量返回列表中第一个相关结果的排名位置，其中Q是查询的总数。r⁢a⁢n⁢kq是查询q的第一个相关结果的排名。\n\n\n模态评估\n\n文本评估\n\n精确匹配（EM）\nBLEU\n\n\n\n\nROUGE：用于评估文本摘要和生成\nROUGE-N：用于衡量生成文本与参考文本之间 N 元语法的重叠度\n\n\n\nROUGE-L：衡量生成文本与参考文本之间的最长公共子序列（LCS）\n\n\n\nMETEOR\n\n图像评估\n\n图像描述\n\nCIDEr（基于共识的图像描述评估）：利用TF-IDF和余弦相似度来衡量描述质量\nSPICE（语义命题图像描述评估）\nSPIDEr ：结合CIDEr和SPICE\n\n语义对齐\n\nBERTScore\nCLIPScore\n\n\n图像质量\n\nFID\n\n\n\nKID\nInception Score：通过分类概率评估图像的多样性和质量"
  },
  {
    "objectID": "content/blogs/entries/一文了解RAG.html#参考资料",
    "href": "content/blogs/entries/一文了解RAG.html#参考资料",
    "title": "一文了解RAG",
    "section": "参考资料",
    "text": "参考资料\n为什么大家都用RAG，这篇小白都看懂了\nRetrieval-Augmented Generation for AI-Generated Content: A Survey\nAsk in Any Modality: A Comprehensive Survey on Multimodal Retrieval-Augmented Generation\n未完待续，后续我们会对文章进行优化，并提供相关图片、数据集、代码和文献链接等，这是一个长期不断优化的过程！"
  },
  {
    "objectID": "content/blogs/entries/一种免费、高清、安全、但是很麻烦的远程桌面连接方案.html",
    "href": "content/blogs/entries/一种免费、高清、安全、但是很麻烦的远程桌面连接方案.html",
    "title": "一种免费、高清、安全、但是很麻烦的远程桌面连接方案",
    "section": "",
    "text": "该方案能够解决的问题\n1、远程连接不受距离限制，通过tailscale实现，但是一定要保证网络的稳定\n2、免费高清串流，通过sunshine和moonlight实现\n3、安全，本方案中安全指的是远端的电脑屏幕在串流期间能够保持黑屏，能有效保护隐私，通过ParsecVDisplay诱骗电脑分屏实现\n\n\n\n\n通过上面的几个工具，大概能够推测出实现的原理 串流指的是将远程计算机的桌面环境、应用程序界面、音频和鼠标键盘输入等实时传输到另一台计算机或设备的过程。 在本方案中，通过ParsecVDisplay诱骗远端的分屏，然后将分屏串流到本地电脑，串流通过sunshine和moonlight实现。 在电脑上设置只在分屏显示，就可以实现主屏幕全程黑屏，保护隐私。然后通过tailscale将两个设备拉到同一个虚拟局域网中，实现不受距离限制的远程连接。\n\n基本原理如下图所示（画的比较糙了）\n\n相较于已有的方法，这个设置起来比较麻烦，但是免费、高清和安全还是非常诱人的。\n同时，这个方案有一个非常之名的缺点，这是由于分屏工具的一个BUG引起的。需要按照严格步骤才能防止意外地发生。\n\n\n\n这个工具的安装没有什么特别的，按照步骤进行安装即可，，可以点击下面的链接找到工具下载地址，如果是在Windows的环境中运行，可以按照图中的版本进行下载，实测有效。\n1、sunshine \n2、moonlight \n3、ParsecVDisplay \n4、tailscale \n注意： 1、sunshine要安装在远端的电脑上\n2、moonlight要安装在本地的电脑上\n3、ParsecVDisplay要安装在远端的电脑上\n4、tailscale在两个电脑上都要安装，注册完成后，登陆同一个账号即可\n\n\n\n在工具安装完成后，我们能够实现基本的串流，然后就是我们方案的实施\n\n\n打开moonlight，在右上角点击添加计算机，然后在框中输入远端主机的IP地址即可。 \n关于ip地址的获取：Win+R，输入cmd，回车，输入ipconfig，回车，找到IPv4地址即可。 \n同时为了能够更好的实现远程的连接推荐使用tailscale安装完成后分配的地址吗，这样可以实现更稳定的远程连接，电脑的ip地址离开局域网之后就不能用了。会自动更换其他地址，这会导致远程连接的失败。\n点击计算机列表中需要远程的电脑，第一次需要输入一个验证码，看到验证码后，在远程主机点击sunshine弹出的框，在框中输入就行。  \n输入完成后，就能实现最基本的电脑远程了。\n\n\n\n保持远程连接的状态下，打开ParsecVDisplay，右下角添加分屏，不过要记住分屏的名称 \n\n需要注意的是，分屏名称会发生变化，这也是 必要按照这个步骤执行的原因\n\n\n\n\n打开sunshine\n在配置中选择Audio/Video，将输出名称改成之前设置分屏的名称，然后重启sunshine\n\n\n这个时候会断连一次\n\n\n\n等待远程电脑的感叹号消失，连接回复正常，连接远程电脑 \n\n\n\n在设置里设置屏幕只在屏2显示，然后就可以实现远程电脑全程黑屏了。 \n\n\n\n先在设置中将原本的只在屏2显示改成复制这些屏幕，然后关闭ParsecVDisplay，然后将远端的电脑锁定，保证下次能正常连接。 \n之后用ctrl+alt+shift+Q退出moonlight就可以了\n\n只有按照上部步骤才能实现稳定连接，不然分屏工具会随机改变分屏名称，这是导致出现意外地原因，可以使用其他分屏工具进行实验 还有关于tailscale的配置和安装，可以参照相关教程\n\n\n\n\n\n\n这件事的灵感来源于跟师兄的聊天，由于初次接触远程连接，感觉很有趣，然后产生了能不能保护隐私的想法，从网上没找到合适方案。由此问师兄，师兄说不能实现吗，串流本质就是投屏，屏幕亮着才能实现吗，然后我就想起了可以借助分屏工具实现，最后测试一番才成功。 个人感觉很有趣，但是限制比较多，也很容易失败，但是也很实用不是吗。"
  },
  {
    "objectID": "content/blogs/entries/一种免费、高清、安全、但是很麻烦的远程桌面连接方案.html#基本原理",
    "href": "content/blogs/entries/一种免费、高清、安全、但是很麻烦的远程桌面连接方案.html#基本原理",
    "title": "一种免费、高清、安全、但是很麻烦的远程桌面连接方案",
    "section": "",
    "text": "通过上面的几个工具，大概能够推测出实现的原理 串流指的是将远程计算机的桌面环境、应用程序界面、音频和鼠标键盘输入等实时传输到另一台计算机或设备的过程。 在本方案中，通过ParsecVDisplay诱骗远端的分屏，然后将分屏串流到本地电脑，串流通过sunshine和moonlight实现。 在电脑上设置只在分屏显示，就可以实现主屏幕全程黑屏，保护隐私。然后通过tailscale将两个设备拉到同一个虚拟局域网中，实现不受距离限制的远程连接。\n\n基本原理如下图所示（画的比较糙了）\n\n相较于已有的方法，这个设置起来比较麻烦，但是免费、高清和安全还是非常诱人的。\n同时，这个方案有一个非常之名的缺点，这是由于分屏工具的一个BUG引起的。需要按照严格步骤才能防止意外地发生。"
  },
  {
    "objectID": "content/blogs/entries/一种免费、高清、安全、但是很麻烦的远程桌面连接方案.html#工具安装",
    "href": "content/blogs/entries/一种免费、高清、安全、但是很麻烦的远程桌面连接方案.html#工具安装",
    "title": "一种免费、高清、安全、但是很麻烦的远程桌面连接方案",
    "section": "",
    "text": "这个工具的安装没有什么特别的，按照步骤进行安装即可，，可以点击下面的链接找到工具下载地址，如果是在Windows的环境中运行，可以按照图中的版本进行下载，实测有效。\n1、sunshine \n2、moonlight \n3、ParsecVDisplay \n4、tailscale \n注意： 1、sunshine要安装在远端的电脑上\n2、moonlight要安装在本地的电脑上\n3、ParsecVDisplay要安装在远端的电脑上\n4、tailscale在两个电脑上都要安装，注册完成后，登陆同一个账号即可"
  },
  {
    "objectID": "content/blogs/entries/一种免费、高清、安全、但是很麻烦的远程桌面连接方案.html#实施步骤",
    "href": "content/blogs/entries/一种免费、高清、安全、但是很麻烦的远程桌面连接方案.html#实施步骤",
    "title": "一种免费、高清、安全、但是很麻烦的远程桌面连接方案",
    "section": "",
    "text": "在工具安装完成后，我们能够实现基本的串流，然后就是我们方案的实施\n\n\n打开moonlight，在右上角点击添加计算机，然后在框中输入远端主机的IP地址即可。 \n关于ip地址的获取：Win+R，输入cmd，回车，输入ipconfig，回车，找到IPv4地址即可。 \n同时为了能够更好的实现远程的连接推荐使用tailscale安装完成后分配的地址吗，这样可以实现更稳定的远程连接，电脑的ip地址离开局域网之后就不能用了。会自动更换其他地址，这会导致远程连接的失败。\n点击计算机列表中需要远程的电脑，第一次需要输入一个验证码，看到验证码后，在远程主机点击sunshine弹出的框，在框中输入就行。  \n输入完成后，就能实现最基本的电脑远程了。\n\n\n\n保持远程连接的状态下，打开ParsecVDisplay，右下角添加分屏，不过要记住分屏的名称 \n\n需要注意的是，分屏名称会发生变化，这也是 必要按照这个步骤执行的原因\n\n\n\n\n打开sunshine\n在配置中选择Audio/Video，将输出名称改成之前设置分屏的名称，然后重启sunshine\n\n\n这个时候会断连一次\n\n\n\n等待远程电脑的感叹号消失，连接回复正常，连接远程电脑 \n\n\n\n在设置里设置屏幕只在屏2显示，然后就可以实现远程电脑全程黑屏了。 \n\n\n\n先在设置中将原本的只在屏2显示改成复制这些屏幕，然后关闭ParsecVDisplay，然后将远端的电脑锁定，保证下次能正常连接。 \n之后用ctrl+alt+shift+Q退出moonlight就可以了\n\n只有按照上部步骤才能实现稳定连接，不然分屏工具会随机改变分屏名称，这是导致出现意外地原因，可以使用其他分屏工具进行实验 还有关于tailscale的配置和安装，可以参照相关教程"
  },
  {
    "objectID": "content/blogs/entries/一种免费、高清、安全、但是很麻烦的远程桌面连接方案.html#总结",
    "href": "content/blogs/entries/一种免费、高清、安全、但是很麻烦的远程桌面连接方案.html#总结",
    "title": "一种免费、高清、安全、但是很麻烦的远程桌面连接方案",
    "section": "",
    "text": "这件事的灵感来源于跟师兄的聊天，由于初次接触远程连接，感觉很有趣，然后产生了能不能保护隐私的想法，从网上没找到合适方案。由此问师兄，师兄说不能实现吗，串流本质就是投屏，屏幕亮着才能实现吗，然后我就想起了可以借助分屏工具实现，最后测试一番才成功。 个人感觉很有趣，但是限制比较多，也很容易失败，但是也很实用不是吗。"
  },
  {
    "objectID": "content/blogs/entries/基于BM25检索算法构建RAG智能文档问答助手--学习和实践.html",
    "href": "content/blogs/entries/基于BM25检索算法构建RAG智能文档问答助手--学习和实践.html",
    "title": "基于BM25检索算法构建RAG智能文档问答助手–学习和实践",
    "section": "",
    "text": "本篇文章记录DataWhale微学习中课程–从零打造RAG检索系统\n\n\n推一波DataWhale的学习内容，可以关注DataWhale公众号，选择自己喜欢的内容\n\n\n学习内容原作者的公众号: 从零打造RAG检索系统：BM25让检索快到飞起 github仓库地址: XiaokeAILabs\n\n\n文章重点是了解RAG检索的基础，运行作者代码测试工具效果\n\n\n\n\n\nRAG（Retrieval-Augmented Generation，检索增强生成）是一种结合检索和自然语言生成的技术，旨在提高生成模型的性能和效果。RAG的基本思想是在生成模型的输入中同时包含检索到的相关信息，从而提高生成模型的生成质量和准确性。\n想起之前使用过Langchain结合ChatGLM3-6B模型，实现过一个智能漏洞问答系统，用的应该就是RAG，不过当时对这些概念并不了解。\n在日常使用中的kimi、豆包和加入联网功能的DeepSeek，应该都应用到了这种技术，不过他们的实现原理和算法应该更加复杂，实现细节上可能也有不同。\n\n\n\nRAG的基本流程还是比较简单的，可以分成两个阶段：\n\n索引阶段:预处理并存储文档数据，构建检索索引\n查询阶段:接收用户查询，检索相关文档，将文档信息作为生成模型的输入，生成相应的回答\n\n\n\n\n想要实现一个完整的RAG过程需要上传并处理额外的文档和数据，这些数据可以是文本、图像、音频、视频等。然后要对这些数据进行处理，比如对文本进行分词、去除停用词、向量化……\n之后要构建检索索引，这一步可以使用多种算法，比如BM25、TF-IDF、向量检索等。\n最后就是生成模型，根据用户输入的信息，检索额外数据，将检索到的信息与用户查询结合，通过LLM生成最终答案。\n核心部分可以分成 1. 数据处理 2. 检索索引 3. 生成模型\n当然这是我自己的概括，不准确\n\n\n\nBM25（Best Matching 25）是一种经典的信息检索算法，是基于Okapi TF-IDF算法的改进版本，旨在解决Okapi TF-IDF算法的一些不足之处。它被广泛应用于信息检索领域的排名函数，用于估计文档D与用户查询Q之间的相关性。BM25是一种基于概率检索框架的改进，特别是在处理长文档和短查询时表现出色。它旨在评估一组查询项与文档的相关性，并为每个文档计算一个分数，该分数决定了文档在搜索结果中的排名。BM25的核心思想是基于词频（TF）和逆文档频率（IDF），同时还引入了文档的长度信息来计算文档D和查询Q之间的相关性。目前被广泛运用的搜索引擎ES就内置了BM25算法进行全文检索。\n具体计算公式就不详细介绍了。\n除了BM25，还有很多其他的检索算法，比如TF-IDF、向量检索、语义检索等。\n\n\n\n\n\n\n环境配置的过程一波三折，可能用linux环境运行更好？\nPython版本: 3.10+\n环境管理工具: conda\n打开cmd，使用下面的命令直接创建环境\nconda create --name RAG python=3.10\n\n\n\n原作者的github仓库地址XiaokeAILabs\n可以使用下面的指令直接git到本地\ngit clone https://github.com/li-xiu-qi/XiaokeAILabs.git\n\n\n\n先进入项目中的xiaoke_doc_assist_by_bm25文件夹，然后在该目录下进入cmd\n首先使用下面的指令安装依赖\npip install -r requirements.txt\n安装完成后在当前目录下创建 .env 文件，文件内容可以复制 .env.example 中的\n这里要配置调用模型的API，我之前在硅基流动免费领过额度，所以跟作者一样使用硅基流动的API和密钥\n如果使用硅基流动，直接修改 API_KEY=your_api_key\n\n也可以使用其他平台的API，比如 OpenAI、火山等，要修改 API_KEY 和 BASE_URL\n配置好后还要下载MinerU模型，用于高质量PDF解析\n在当前目录下使用下面指令，如果开了IDE也可以直接运行python文件\npython download_mineru_models.py\n\n\n\n\n在当前目录下使用下面指令运行项目\nstreamlit run main.py\n\n当然，这只是开始，我们仍旧有很多潜在的依赖没有安装，由于不知道安装啥，只能一遍遍运行启动项目的指令，根据报错信息安装，直到最后项目成功启动。\n\n总的来说，缺啥补啥，最后会运行成功的。\n下面是我的辛路历程\n1、缺少magic-pdf\n\n检查后这里需要升级magic-pdf\n使用指令\npip install --upgrade magic-pdf\n\n2、缺少paddle \n安装paddle\npip install paddle\n但是还会报错，缺少paddle的依赖 \n安装依赖\npip install common dual tight data prox\n安装之后发现还是报错\n\n搜索发现paddle太老了，应该升级安装paddlepaddle\n安装指令\npip install --upgrade paddlepaddle\n3、缺少cv2\n\n安装依赖\npip install opencv-python\n\n4、缺少ultralytics\n\n安装依赖\npip install ultralytics\n\n5、缺少doclayout_yolo\n\n安装依赖\npip install doclayout_yolo\n\n6、缺少pycocotools\n\n安装依赖\npip install pycocotools\n\n7、缺少detectron2\n\n安装依赖\n这个依赖的安装可以参考博客Windows11安装detectron2全流程记录帖（含torch安装）\n这个过程中可能会报错，缺少ninja\n使用下面指令安装\npip install ninja\n还会报错要安装Microsoft C++ Build Tools，可能是缺少C++编译器？\n如果有这个报错点击连接，安装就行，在安装的时候一定要勾选C++桌面开的部分\n解决上面两个问题后安装应该不会有问题\n8、缺少timm\n\n安装依赖\npip install timm\n\n9、缺少unimernet\n\n安装依赖\npip install unimernet\n\n10、缺少paddleocr \n安装依赖\npip install paddleocr\n\n11、缺少rapid_table\n\n安装依赖\npip install rapid_table\n12、缺少struct_eqtable\n\n安装依赖\npip install struct_eqtable\n\n13、缺少Stemmer\n\n安装依赖\npip install PyStemmer\n\n\n现在应该能正常运行项目了？\n\n在运行起来之后，我尝试上传文件，还有一个报错安装依赖\n\n安装依赖\npip install rapidocr_onnxruntime\n\n\n现在确实可以运行了\n\n\n\n\n\n在运行完成后，我上传了自己桌面上的一个论文，经过测试可以成功解析，但是不能够检索内容并喂给大模型，还没找到原因。\n之后我用作者提供的测试论文，发现可以成功运行。\n贴一张图：\n\n\n\n\n这是一个非常简单（可能也没那么简单），但是非常有意思的RAG检索系统，但是可以作为一个学习的起点，了解RAG检索的基本流程和原理。\n在实际应用中，RAG检索系统的实现可能会更加复杂，需要考虑更多的因素，比如数据处理、检索索引、生成模型等。\n现在运行项目还会有很多问题，后续我也会发现原因，或许实践构建一个自己的RAG检索系统？"
  },
  {
    "objectID": "content/blogs/entries/基于BM25检索算法构建RAG智能文档问答助手--学习和实践.html#rag及相关基础概念",
    "href": "content/blogs/entries/基于BM25检索算法构建RAG智能文档问答助手--学习和实践.html#rag及相关基础概念",
    "title": "基于BM25检索算法构建RAG智能文档问答助手–学习和实践",
    "section": "",
    "text": "RAG（Retrieval-Augmented Generation，检索增强生成）是一种结合检索和自然语言生成的技术，旨在提高生成模型的性能和效果。RAG的基本思想是在生成模型的输入中同时包含检索到的相关信息，从而提高生成模型的生成质量和准确性。\n想起之前使用过Langchain结合ChatGLM3-6B模型，实现过一个智能漏洞问答系统，用的应该就是RAG，不过当时对这些概念并不了解。\n在日常使用中的kimi、豆包和加入联网功能的DeepSeek，应该都应用到了这种技术，不过他们的实现原理和算法应该更加复杂，实现细节上可能也有不同。\n\n\n\nRAG的基本流程还是比较简单的，可以分成两个阶段：\n\n索引阶段:预处理并存储文档数据，构建检索索引\n查询阶段:接收用户查询，检索相关文档，将文档信息作为生成模型的输入，生成相应的回答\n\n\n\n\n想要实现一个完整的RAG过程需要上传并处理额外的文档和数据，这些数据可以是文本、图像、音频、视频等。然后要对这些数据进行处理，比如对文本进行分词、去除停用词、向量化……\n之后要构建检索索引，这一步可以使用多种算法，比如BM25、TF-IDF、向量检索等。\n最后就是生成模型，根据用户输入的信息，检索额外数据，将检索到的信息与用户查询结合，通过LLM生成最终答案。\n核心部分可以分成 1. 数据处理 2. 检索索引 3. 生成模型\n当然这是我自己的概括，不准确\n\n\n\nBM25（Best Matching 25）是一种经典的信息检索算法，是基于Okapi TF-IDF算法的改进版本，旨在解决Okapi TF-IDF算法的一些不足之处。它被广泛应用于信息检索领域的排名函数，用于估计文档D与用户查询Q之间的相关性。BM25是一种基于概率检索框架的改进，特别是在处理长文档和短查询时表现出色。它旨在评估一组查询项与文档的相关性，并为每个文档计算一个分数，该分数决定了文档在搜索结果中的排名。BM25的核心思想是基于词频（TF）和逆文档频率（IDF），同时还引入了文档的长度信息来计算文档D和查询Q之间的相关性。目前被广泛运用的搜索引擎ES就内置了BM25算法进行全文检索。\n具体计算公式就不详细介绍了。\n除了BM25，还有很多其他的检索算法，比如TF-IDF、向量检索、语义检索等。"
  },
  {
    "objectID": "content/blogs/entries/基于BM25检索算法构建RAG智能文档问答助手--学习和实践.html#基于bm25的rag检索系统运行",
    "href": "content/blogs/entries/基于BM25检索算法构建RAG智能文档问答助手--学习和实践.html#基于bm25的rag检索系统运行",
    "title": "基于BM25检索算法构建RAG智能文档问答助手–学习和实践",
    "section": "",
    "text": "环境配置的过程一波三折，可能用linux环境运行更好？\nPython版本: 3.10+\n环境管理工具: conda\n打开cmd，使用下面的命令直接创建环境\nconda create --name RAG python=3.10\n\n\n\n原作者的github仓库地址XiaokeAILabs\n可以使用下面的指令直接git到本地\ngit clone https://github.com/li-xiu-qi/XiaokeAILabs.git\n\n\n\n先进入项目中的xiaoke_doc_assist_by_bm25文件夹，然后在该目录下进入cmd\n首先使用下面的指令安装依赖\npip install -r requirements.txt\n安装完成后在当前目录下创建 .env 文件，文件内容可以复制 .env.example 中的\n这里要配置调用模型的API，我之前在硅基流动免费领过额度，所以跟作者一样使用硅基流动的API和密钥\n如果使用硅基流动，直接修改 API_KEY=your_api_key\n\n也可以使用其他平台的API，比如 OpenAI、火山等，要修改 API_KEY 和 BASE_URL\n配置好后还要下载MinerU模型，用于高质量PDF解析\n在当前目录下使用下面指令，如果开了IDE也可以直接运行python文件\npython download_mineru_models.py\n\n\n\n\n在当前目录下使用下面指令运行项目\nstreamlit run main.py\n\n当然，这只是开始，我们仍旧有很多潜在的依赖没有安装，由于不知道安装啥，只能一遍遍运行启动项目的指令，根据报错信息安装，直到最后项目成功启动。\n\n总的来说，缺啥补啥，最后会运行成功的。\n下面是我的辛路历程\n1、缺少magic-pdf\n\n检查后这里需要升级magic-pdf\n使用指令\npip install --upgrade magic-pdf\n\n2、缺少paddle \n安装paddle\npip install paddle\n但是还会报错，缺少paddle的依赖 \n安装依赖\npip install common dual tight data prox\n安装之后发现还是报错\n\n搜索发现paddle太老了，应该升级安装paddlepaddle\n安装指令\npip install --upgrade paddlepaddle\n3、缺少cv2\n\n安装依赖\npip install opencv-python\n\n4、缺少ultralytics\n\n安装依赖\npip install ultralytics\n\n5、缺少doclayout_yolo\n\n安装依赖\npip install doclayout_yolo\n\n6、缺少pycocotools\n\n安装依赖\npip install pycocotools\n\n7、缺少detectron2\n\n安装依赖\n这个依赖的安装可以参考博客Windows11安装detectron2全流程记录帖（含torch安装）\n这个过程中可能会报错，缺少ninja\n使用下面指令安装\npip install ninja\n还会报错要安装Microsoft C++ Build Tools，可能是缺少C++编译器？\n如果有这个报错点击连接，安装就行，在安装的时候一定要勾选C++桌面开的部分\n解决上面两个问题后安装应该不会有问题\n8、缺少timm\n\n安装依赖\npip install timm\n\n9、缺少unimernet\n\n安装依赖\npip install unimernet\n\n10、缺少paddleocr \n安装依赖\npip install paddleocr\n\n11、缺少rapid_table\n\n安装依赖\npip install rapid_table\n12、缺少struct_eqtable\n\n安装依赖\npip install struct_eqtable\n\n13、缺少Stemmer\n\n安装依赖\npip install PyStemmer\n\n\n现在应该能正常运行项目了？\n\n在运行起来之后，我尝试上传文件，还有一个报错安装依赖\n\n安装依赖\npip install rapidocr_onnxruntime\n\n\n现在确实可以运行了"
  },
  {
    "objectID": "content/blogs/entries/基于BM25检索算法构建RAG智能文档问答助手--学习和实践.html#项目效果",
    "href": "content/blogs/entries/基于BM25检索算法构建RAG智能文档问答助手--学习和实践.html#项目效果",
    "title": "基于BM25检索算法构建RAG智能文档问答助手–学习和实践",
    "section": "",
    "text": "在运行完成后，我上传了自己桌面上的一个论文，经过测试可以成功解析，但是不能够检索内容并喂给大模型，还没找到原因。\n之后我用作者提供的测试论文，发现可以成功运行。\n贴一张图："
  },
  {
    "objectID": "content/blogs/entries/基于BM25检索算法构建RAG智能文档问答助手--学习和实践.html#总结",
    "href": "content/blogs/entries/基于BM25检索算法构建RAG智能文档问答助手--学习和实践.html#总结",
    "title": "基于BM25检索算法构建RAG智能文档问答助手–学习和实践",
    "section": "",
    "text": "这是一个非常简单（可能也没那么简单），但是非常有意思的RAG检索系统，但是可以作为一个学习的起点，了解RAG检索的基本流程和原理。\n在实际应用中，RAG检索系统的实现可能会更加复杂，需要考虑更多的因素，比如数据处理、检索索引、生成模型等。\n现在运行项目还会有很多问题，后续我也会发现原因，或许实践构建一个自己的RAG检索系统？"
  },
  {
    "objectID": "content/blogs/entries/开源协议.html",
    "href": "content/blogs/entries/开源协议.html",
    "title": "开源协议",
    "section": "",
    "text": "开源协议是软件开发与分发中的重要组成部分。它们不仅影响软件的使用方式，还影响开发者、用户及整个社区的权利与责任。本文将深入探讨开源协议的定义、类型、重要性及其对软件生态的影响。\n\n\n开源协议是一种法律协议，允许软件的源代码被自由使用、修改和分发。开源协议的核心理念在于促进协作与创新，确保用户和开发者可以自由地利用软件，同时保护原作者的权利。\n\n\n开源软件与自由软件的概念常常被混淆。开源软件强调源代码的可得性，而自由软件则更强调用户的自由。根据自由软件基金会（FSF）的定义，自由软件不仅要允许用户使用软件，还要允许他们修改和分发软件。\n\n\n\n\n开源协议通常分为两大类：宽松型协议和严格型协议。\n\n\n宽松型协议允许用户自由使用、修改和分发软件，同时对后续衍生作品的限制较少。常见的宽松型协议包括：\n\nMIT 许可证：该协议极为简单，允许几乎任何人以任何方式使用、复制、修改和分发软件，只需附上原许可证即可。\nApache 许可证：与MIT许可证类似，Apache许可证允许用户自由使用、修改和分发，但还附加了一些对专利权的保障。\nBSD 许可证：BSD许可证有多个版本，通常允许自由使用和分发，且对源代码的修改并没有严格要求。\n\n\n\n\n严格型协议通常要求任何派生作品都必须遵循相同的协议，保持开源。这类协议包括：\n\nGNU 通用公共许可证（GPL）：GPL是最著名的严格型开源协议之一。它要求任何基于GPL软件的衍生作品也必须以GPL的方式发布，确保用户的自由。\nGNU 较宽松公共许可证（LGPL）：LGPL允许将开源库与闭源软件链接，但任何对库本身的修改仍需以LGPL发布。\nAGPL：与GPL类似，但还要求任何通过网络提供软件的用户也必须开放源代码。\n\n\n\n\n\n\n\n开源协议允许开发者在已有软件的基础上进行修改和扩展。这种开放性促进了技术创新，使得社区成员能够快速迭代和共享最佳实践。\n\n\n\n开放源代码使得任何人都可以检查和审计代码。这种透明性有助于快速发现和修复安全漏洞，增强软件的整体安全性。\n\n\n\n开源协议明确了用户的权利，确保用户能够自由使用、修改和分发软件。这对保护用户的自由和选择权至关重要。\n\n\n\n开源协议吸引了大量开发者和用户参与到软件的开发和维护中。通过社区的合作，软件通常能得到更快的更新和更高的质量。\n\n\n\n\n选择合适的开源协议对于开发者和项目至关重要。以下是选择协议时需要考虑的一些因素：\n\n使用场景：考虑软件的使用场景和目标用户群体，选择适合的协议。\n社区支持：某些协议在特定社区或行业中更受欢迎，选择这样的协议可能更容易获得支持。\n法律风险：了解不同协议在法律上的含义，选择能够保护自己和用户权利的协议。\n兼容性：确保所选协议与项目中使用的其他开源软件的协议兼容，避免法律问题。\n\n\n\n\n\n\nLinux 是一个典型的开源软件项目，采用了 GNU GPL 许可证。这使得任何人都可以使用和修改 Linux 内核，同时要求所有衍生作品也必须以 GPL 发布。Linux 的成功离不开全球开发者社区的贡献，使其成为服务器和嵌入式设备的主流操作系统。\n\n\n\nApache HTTP Server 采用了 Apache 许可证，属于宽松型协议。这使得企业和开发者可以自由使用和修改 Apache，同时也能将其与闭源软件结合使用。Apache 的成功在于其灵活性和广泛的支持，成为了全球使用最广泛的 web 服务器。\n\n\n\n\n随着开源软件的普及，开源协议的未来也在不断演变。以下是一些可能的趋势：\n\n增加透明度：更多的开源项目将会采用透明的审计机制，以增强用户对软件安全性的信任。\n法律合规：随着开源软件使用的增多，法律合规性将变得尤为重要。开发者需要更加重视许可协议的理解与遵循。\n新兴协议：随着技术的发展，新兴的开源协议可能会不断涌现，以适应新的需求和挑战。\n\n\n\n\n开源协议是软件开发的基础，它们不仅定义了软件的使用方式，还塑造了整个技术生态。因此，理解开源协议的作用和选择合适的协议，对于开发者和用户都是至关重要的。随着开源运动的不断发展，开源协议将继续在促进创新、保护用户权利以及推动社区合作中发挥重要作用。希望本文能帮助读者更好地理解开源协议，并在未来的项目中做出明智的选择。"
  },
  {
    "objectID": "content/blogs/entries/开源协议.html#什么是开源协议",
    "href": "content/blogs/entries/开源协议.html#什么是开源协议",
    "title": "开源协议",
    "section": "",
    "text": "开源协议是一种法律协议，允许软件的源代码被自由使用、修改和分发。开源协议的核心理念在于促进协作与创新，确保用户和开发者可以自由地利用软件，同时保护原作者的权利。\n\n\n开源软件与自由软件的概念常常被混淆。开源软件强调源代码的可得性，而自由软件则更强调用户的自由。根据自由软件基金会（FSF）的定义，自由软件不仅要允许用户使用软件，还要允许他们修改和分发软件。"
  },
  {
    "objectID": "content/blogs/entries/开源协议.html#开源协议的类型",
    "href": "content/blogs/entries/开源协议.html#开源协议的类型",
    "title": "开源协议",
    "section": "",
    "text": "开源协议通常分为两大类：宽松型协议和严格型协议。\n\n\n宽松型协议允许用户自由使用、修改和分发软件，同时对后续衍生作品的限制较少。常见的宽松型协议包括：\n\nMIT 许可证：该协议极为简单，允许几乎任何人以任何方式使用、复制、修改和分发软件，只需附上原许可证即可。\nApache 许可证：与MIT许可证类似，Apache许可证允许用户自由使用、修改和分发，但还附加了一些对专利权的保障。\nBSD 许可证：BSD许可证有多个版本，通常允许自由使用和分发，且对源代码的修改并没有严格要求。\n\n\n\n\n严格型协议通常要求任何派生作品都必须遵循相同的协议，保持开源。这类协议包括：\n\nGNU 通用公共许可证（GPL）：GPL是最著名的严格型开源协议之一。它要求任何基于GPL软件的衍生作品也必须以GPL的方式发布，确保用户的自由。\nGNU 较宽松公共许可证（LGPL）：LGPL允许将开源库与闭源软件链接，但任何对库本身的修改仍需以LGPL发布。\nAGPL：与GPL类似，但还要求任何通过网络提供软件的用户也必须开放源代码。"
  },
  {
    "objectID": "content/blogs/entries/开源协议.html#开源协议的重要性",
    "href": "content/blogs/entries/开源协议.html#开源协议的重要性",
    "title": "开源协议",
    "section": "",
    "text": "开源协议允许开发者在已有软件的基础上进行修改和扩展。这种开放性促进了技术创新，使得社区成员能够快速迭代和共享最佳实践。\n\n\n\n开放源代码使得任何人都可以检查和审计代码。这种透明性有助于快速发现和修复安全漏洞，增强软件的整体安全性。\n\n\n\n开源协议明确了用户的权利，确保用户能够自由使用、修改和分发软件。这对保护用户的自由和选择权至关重要。\n\n\n\n开源协议吸引了大量开发者和用户参与到软件的开发和维护中。通过社区的合作，软件通常能得到更快的更新和更高的质量。"
  },
  {
    "objectID": "content/blogs/entries/开源协议.html#开源协议的选择",
    "href": "content/blogs/entries/开源协议.html#开源协议的选择",
    "title": "开源协议",
    "section": "",
    "text": "选择合适的开源协议对于开发者和项目至关重要。以下是选择协议时需要考虑的一些因素：\n\n使用场景：考虑软件的使用场景和目标用户群体，选择适合的协议。\n社区支持：某些协议在特定社区或行业中更受欢迎，选择这样的协议可能更容易获得支持。\n法律风险：了解不同协议在法律上的含义，选择能够保护自己和用户权利的协议。\n兼容性：确保所选协议与项目中使用的其他开源软件的协议兼容，避免法律问题。"
  },
  {
    "objectID": "content/blogs/entries/开源协议.html#开源协议的案例分析",
    "href": "content/blogs/entries/开源协议.html#开源协议的案例分析",
    "title": "开源协议",
    "section": "",
    "text": "Linux 是一个典型的开源软件项目，采用了 GNU GPL 许可证。这使得任何人都可以使用和修改 Linux 内核，同时要求所有衍生作品也必须以 GPL 发布。Linux 的成功离不开全球开发者社区的贡献，使其成为服务器和嵌入式设备的主流操作系统。\n\n\n\nApache HTTP Server 采用了 Apache 许可证，属于宽松型协议。这使得企业和开发者可以自由使用和修改 Apache，同时也能将其与闭源软件结合使用。Apache 的成功在于其灵活性和广泛的支持，成为了全球使用最广泛的 web 服务器。"
  },
  {
    "objectID": "content/blogs/entries/开源协议.html#开源协议的未来",
    "href": "content/blogs/entries/开源协议.html#开源协议的未来",
    "title": "开源协议",
    "section": "",
    "text": "随着开源软件的普及，开源协议的未来也在不断演变。以下是一些可能的趋势：\n\n增加透明度：更多的开源项目将会采用透明的审计机制，以增强用户对软件安全性的信任。\n法律合规：随着开源软件使用的增多，法律合规性将变得尤为重要。开发者需要更加重视许可协议的理解与遵循。\n新兴协议：随着技术的发展，新兴的开源协议可能会不断涌现，以适应新的需求和挑战。"
  },
  {
    "objectID": "content/blogs/entries/开源协议.html#结语",
    "href": "content/blogs/entries/开源协议.html#结语",
    "title": "开源协议",
    "section": "",
    "text": "开源协议是软件开发的基础，它们不仅定义了软件的使用方式，还塑造了整个技术生态。因此，理解开源协议的作用和选择合适的协议，对于开发者和用户都是至关重要的。随着开源运动的不断发展，开源协议将继续在促进创新、保护用户权利以及推动社区合作中发挥重要作用。希望本文能帮助读者更好地理解开源协议，并在未来的项目中做出明智的选择。"
  },
  {
    "objectID": "content/learning-notes/algorithm/entries/滑动窗口与双指针-定长滑动窗口-基础.html",
    "href": "content/learning-notes/algorithm/entries/滑动窗口与双指针-定长滑动窗口-基础.html",
    "title": "leetcode-灵神跟练-滑动窗口与双指针-定长滑动窗口-基础",
    "section": "",
    "text": "定长滑动窗口-基础\n\n1456. 定长子串中元音的最大数目\n\n题面\n给你字符串 s 和整数 k 。 请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。 英文中的 元音字母 为（a, e, i, o, u）。\n示例 1： 输入：s = “abciiidef”, k = 3 输出：3 解释：子字符串 “iii” 包含 3 个元音字母。\n示例 2： 输入：s = “aeiou”, k = 2 输出：2 解释：任意长度为 2 的子字符串都包含 2 个元音字母。\n示例 3： 输入：s = “leetcode”, k = 3 输出：2 解释：“lee”、“eet” 和 “ode” 都包含 2 个元音字母。\n示例 4： 输入：s = “rhythms”, k = 4 输出：0 解释：字符串 s 中不含任何元音字母。\n示例 5： 输入：s = “tryhard”, k = 4 输出：1\n提示： 1 &lt;= s.length &lt;= 10^5 s 由小写英文字母组成 1 &lt;= k &lt;= s.length\n\n\n思路说明\n本题是一个比较简单的滑动窗口，窗口的大小固定不变是K，要做的是判断窗口内元音字母的个数\n首先我们构建一个变量用来统计当前窗口内元音字母的数量，设置为cnt\n窗口只要不断向右滑动的，还需要一个变量存储所有经历过的窗口中元音字母数的最大值，也就是我们最后需要的结果，设置为ans\n然后我们就是对字符串进行遍历\n针对定长滑动窗口的类型，我们可以简单总结一个规律 - 先进行条件判断，修改对应变量值 - 判断窗口是否需要移动，如果移动修改对应值 - 判断窗口是否已经达到了固定长度，如果达到了，进行结果更新\n一个简单的总结，仅供参考\n针对我们现在的题目 - 创建一个变量记录当前窗口内元音字母的个数，设置为cnt - 创建一个变量记录所有经历过的窗口内元音字母数最大值，设置为ans - 然后进行遍历 - 先判断是不是元音字母，如果是窗口内元音字母个数cnt+1 - 然后判断窗口是否需要滑动，如果需要，判断最左边元素是不是元音字母，如果是cnt-1，如果不是，不需要进行更新 - 最后，判断当前窗口长度是不是达到要求，如果是，进行最大值的更新 - 返回最终结果ans\n\n\n题解\npackage main\n\nimport \"fmt\"\n\nfunc judge(ch byte) bool {\n    if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n        return true\n    }\n\n    return false\n}\n\nfunc maxVowels(s string, k int) int {\n    ans := 0\n    cnt := 0\n\n    for i := 0; i &lt; len(s); i++ {\n        if judge(s[i]) {\n            cnt++\n        }\n        if i &gt;= k {\n            if judge(s[i-k]) {\n                cnt -= 1\n            }\n        }\n        if i &gt;= k-1 {\n            ans = max(ans, cnt)\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        s string\n        k int\n    }{\n        {\"abciiidef\", 3},\n        {\"aeiou\", 2},\n        {\"leetcode\", 3},\n        {\"rhythms\", 4},\n        {\"tryhard\", 4},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(maxVowels(testCase.s, testCase.k))\n    }\n}\n\n\n\n\n\n643. 子数组最大平均数 I\n\n题面\n给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。 请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。 任何误差小于 10-5 的答案都将被视为正确答案。\n示例 1：\n输入：nums = [1,12,-5,-6,50,3], k = 4\n输出：12.75\n解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75\n示例 2：\n输入：nums = [5], k = 1\n输出：5.00000\n提示：\nn == nums.length\n1 &lt;= k &lt;= n &lt;= 10^5\n-10^4 &lt;= nums[i] &lt;= 10^4\n\n\n思路说明\n构建长度为k的滑动窗口，设置变量计算窗口内数字的和，当窗口滑动的时候更新变量\n设置变量动态更新最大平均数，注意这个变量初始化的时候设置成 math.MinInt\n\n\n题解\n\n// 643.子数组最大平均数I\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc findMaxAverage(nums []int, k int) float64 {\n    ans, cnt := math.MinInt, 0\n\n    for i, num := range nums {\n        cnt += num\n\n        if i &gt;= k {\n            cnt -= nums[i-k]\n        }\n\n        if i &gt;= k-1 {\n            ans = max(ans, cnt)\n        }\n    }\n\n    return float64(ans) / float64(k)\n}\n\nfunc main() {\n    testCases := []struct {\n        nums []int\n        k    int\n    }{\n        {[]int{1, 12, -5, -6, 50, 3}, 4},\n        {[]int{5}, 1},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(findMaxAverage(testCase.nums, testCase.k))\n    }\n}\n\n\n\n\n1343. 大小为 K 且平均值大于等于阈值的子数组数目\n\n题面\n给你一个整数数组 arr 和两个整数 k 和 threshold 。\n请你返回长度为 k 且平均值大于等于 threshold 的子数组数目。\n示例 1：\n输入：arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4\n输出：3\n解释：子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4，5 和 6 。其他长度为 3 的子数组的平均值都小于 4 （threshold 的值)。\n示例 2：\n输入：arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5\n输出：6\n解释：前 6 个长度为 3 的子数组平均值都大于 5 。注意平均值不是整数。\n提示：\n1 &lt;= arr.length &lt;= 10^5\n1 &lt;= arr[i] &lt;= 10^4\n1 &lt;= k &lt;= arr.length\n0 &lt;= threshold &lt;= 10^4\n\n\n思路说明\n基本思路就是构建大小为k的窗口，计算窗口内元素的和，然后计算平均值是否大于等于某个阈值\n还是按照咱们的步骤来\n\n\n题解\n\n// 1343.大小为K且平均值大于等于阈值的子数组数目\npackage main\n\nimport \"fmt\"\n\nfunc numOfSubarrays(arr []int, k, threshold int) int {\n    ans, cnt := 0, 0\n\n    for i, num := range arr {\n        cnt += num\n        if i &gt;= k {\n            cnt -= arr[i-k]\n        }\n\n        if i &gt;= k-1 && cnt &gt;= k*threshold {\n            ans += 1\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        arr       []int\n        k         int\n        threshold int\n    }{\n        {[]int{2, 2, 2, 2, 5, 5, 5, 8}, 3, 4},\n        {[]int{11, 13, 17, 23, 29, 31, 7, 5, 2, 3}, 3, 5},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(numOfSubarrays(testCase.arr, testCase.k, testCase.threshold))\n    }\n}\n\n\n\n\n\n2090. 半径为 k 的子数组平均值\n\n题面\n给你一个下标从 0 开始的数组 nums ，数组中有 n 个整数，另给你一个整数 k 。\n半径为 k 的子数组平均值 是指：nums 中一个以下标 i 为 中心 且 半径 为 k 的子数组中所有元素的平均值，即下标在 i - k 和 i + k 范围（含 i - k 和 i + k）内所有元素的平均值。如果在下标 i 前或后不足 k 个元素，那么 半径为 k 的子数组平均值 是 -1 。\n构建并返回一个长度为 n 的数组 avgs ，其中 avgs[i] 是以下标 i 为中心的子数组的 半径为 k 的子数组平均值 。\nx 个元素的 平均值 是 x 个元素相加之和除以 x ，此时使用截断式 整数除法 ，即需要去掉结果的小数部分。\n例如，四个元素 2、3、1 和 5 的平均值是 (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75，截断后得到 2 。\n示例 1：\n输入：nums = [7,4,3,9,1,8,5,2,6], k = 3\n输出：[-1,-1,-1,5,4,4,-1,-1,-1]\n解释： - avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。 - 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。 使用截断式 整数除法，avg[3] = 37 / 7 = 5 。 - 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。 - 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。 - avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。\n示例 2：\n输入：nums = [100000], k = 0\n输出：[100000]\n解释： - 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。 avg[0] = 100000 / 1 = 100000 。\n示例 3：\n输入：nums = [8], k = 100000\n输出：[-1]\n解释： - avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。\n提示：\nn == nums.length\n1 &lt;= n &lt;= 10^5\n0 &lt;= nums[i], k &lt;= 10^5\n\n\n思路说明\n本题提出了一个概念，半径为k的字数组\n这个时候滑动窗口的实际大小是k * 2 + 1\n之后能作为圆心的点才能够有平均值，其他的都是-1\n所以，先设置答案存储的数组 ans 然后将全部的值初始化为-1\n之后还是按照我们之前总结的思路来\n\n\n题解\n// 2090.半径为k的子数组平均值\npackage main\n\nimport \"fmt\"\n\nfunc getAverages(nums []int, k int) []int {\n    ans := make([]int, len(nums))\n\n    for i := range ans {\n        ans[i] = -1\n    }\n\n    cnt := 0\n\n    for i, num := range nums {\n        cnt += num\n\n        if i &gt;= 2*k {\n            ans[i-k] = cnt / (k*2 + 1)\n            cnt -= nums[i-2*k]\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        nums []int\n        k    int\n    }{\n        {[]int{7, 4, 3, 9, 1, 8, 5, 2, 6}, 3},\n        {[]int{100000}, 0},\n        {[]int{8}, 100000},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(getAverages(testCase.nums, testCase.k))\n    }\n}\n\n\n\n\n\n2379. 得到 K 个黑块的最少涂色次数\n\n题面\n给你一个长度为 n 下标从 0 开始的字符串 blocks ，blocks[i] 要么是 ‘W’ 要么是 ‘B’ ，表示第 i 块的颜色。字符 ‘W’ 和 ‘B’ 分别表示白色和黑色。\n给你一个整数 k ，表示想要 连续 黑色块的数目。\n每一次操作中，你可以选择一个白色块将它 涂成 黑色块。\n请你返回至少出现 一次 连续 k 个黑色块的 最少 操作次数。\n示例 1：\n输入：blocks = “WBBWWBBWBW”, k = 7\n输出：3\n解释： 一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色。\n得到 blocks = “BBBBBBBWBW” 。\n可以证明无法用少于 3 次操作得到 7 个连续的黑块。\n所以我们返回 3 。\n示例 2：\n输入：blocks = “WBWBBBW”, k = 2\n输出：0\n解释：\n不需要任何操作，因为已经有 2 个连续的黑块。\n所以我们返回 0 。\n提示：\nn == blocks.length\n1 &lt;= n &lt;= 100\nblocks[i] 要么是 ‘W’ ，要么是 ‘B’ 。\n1 &lt;= k &lt;= n\n\n\n思路说明\n我们需要的是K个连续的黑色块，也就是把大小为k的窗口中的白色块全部涂黑\n我们要到这个最小的涂色数，也是黑色块最多，白色块最少\n我们找到黑色块最多的然后用k减去这个数量即可\n\n\n题解\n// 2379.得到K个黑块的最少涂色次数\npackage main\n\nimport \"fmt\"\n\nfunc minimumRecolors(blocks string, k int) int {\n    ans, cnt := 0, 0\n\n    for i, block := range blocks {\n        if block == 'B' {\n            cnt += 1\n        }\n\n        if i &gt;= k {\n            if blocks[i-k] == 'B' {\n                cnt -= 1\n            }\n        }\n\n        if i &gt;= k-1 {\n            ans = max(ans, cnt)\n        }\n    }\n\n    return k - ans\n}\n\nfunc main() {\n    testCases := []struct {\n        blocks string\n        k      int\n    }{\n        {\"WBBWWBBWBW\", 7},\n        {\"WBWBBBW\", 2},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(minimumRecolors(testCase.blocks, testCase.k))\n    }\n}\n\n\n\n\n\n2841. 几乎唯一子数组的最大和\n\n题面\n给你一个整数数组 nums 和两个正整数 m 和 k 。\n请你返回 nums 中长度为 k 的 几乎唯一 子数组的 最大和 ，如果不存在几乎唯一子数组，请你返回 0 。\n如果 nums 的一个子数组有至少 m 个互不相同的元素，我们称它是 几乎唯一 子数组。\n子数组指的是一个数组中一段连续 非空 的元素序列。\n示例 1：\n输入：nums = [2,6,7,3,1,7], m = 3, k = 4\n输出：18\n解释：总共有 3 个长度为 k = 4 的几乎唯一子数组。分别为 [2, 6, 7, 3] ，[6, 7, 3, 1] 和 [7, 3, 1, 7] 。这些子数组中，和最大的是 [2, 6, 7, 3] ，和为 18 。\n示例 2：\n输入：nums = [5,9,9,2,4,5,4], m = 1, k = 3\n输出：23\n解释：总共有 5 个长度为 k = 3 的几乎唯一子数组。分别为 [5, 9, 9] ，[9, 9, 2] ，[9, 2, 4] ，[2, 4, 5] 和 [4, 5, 4] 。这些子数组中，和最大的是 [5, 9, 9] ，和为 23 。\n示例 3：\n输入：nums = [1,2,1,2,1,2,1], m = 3, k = 3\n输出：0\n解释：输入数组中不存在长度为 k = 3 的子数组含有至少 m = 3 个互不相同元素的子数组。所以不存在几乎唯一子数组，最大和为 0 。\n提示：\n1 &lt;= nums.length &lt;= 2 * 10^4\n1 &lt;= m &lt;= k &lt;= nums.length\n1 &lt;= nums[i] &lt;= 10^9\n\n\n思路说明\n从这道题开始引入一个变量，开始对窗口中元素的数量进行控制\n对数量的统计和控制可以通过引入哈希表实现，在golang中，我们可以使用map[type]type 来表示哈希表\n通过map[num]可以统计num的数量，通过len(map)可以控制元素的种类，这也是最常用的两种方式\n在本题中，我们要把len(map)控制在m以内\n然后其他的逻辑都是固定的\n\n\n题解\n\n// 2841.几乎唯一子数组的最大和\npackage main\n\nimport \"fmt\"\n\nfunc maxSum(nums []int, m, k int) int64 {\n    mp := make(map[int]int)\n    var ans, cnt int64\n    for i, num := range nums {\n        cnt += int64(num)\n        mp[num] += 1\n\n        if i &gt;= k {\n            cnt -= int64(nums[i-k])\n            mp[nums[i-k]] -= 1\n            if mp[nums[i-k]] == 0 {\n                delete(mp, nums[i-k])\n            }\n        }\n\n        if i &gt;= k-1 && len(mp) &gt;= m {\n            ans = max(ans, cnt)\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        nums []int\n        m    int\n        k    int\n    }{\n        {[]int{2, 6, 7, 3, 1, 7}, 3, 4},\n        {[]int{5, 9, 9, 2, 4, 5, 4}, 1, 3},\n        {[]int{1, 2, 1, 2, 1, 2, 1}, 3, 3},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(maxSum(testCase.nums, testCase.m, testCase.k))\n    }\n}\n\n\n\n\n\n2461. 长度为 K 子数组中的最大和\n\n题面\n给你一个整数数组 nums 和一个整数 k 。请你从 nums 中满足下述条件的全部子数组中找出最大子数组和：\n子数组的长度是 k，且\n子数组中的所有元素 各不相同 。\n返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 0 。\n子数组 是数组中一段连续非空的元素序列。\n示例 1：\n输入：nums = [1,5,4,2,9,9,9], k = 3\n输出：15\n解释：nums 中长度为 3 的子数组是： - [1,5,4] 满足全部条件，和为 10 。 - [5,4,2] 满足全部条件，和为 11 。 - [4,2,9] 满足全部条件，和为 15 。 - [2,9,9] 不满足全部条件，因为元素 9 出现重复。 - [9,9,9] 不满足全部条件，因为元素 9 出现重复。\n因为 15 是满足全部条件的所有子数组中的最大子数组和，所以返回 15 。\n示例 2：\n输入：nums = [4,4,4], k = 3\n输出：0\n解释：nums 中长度为 3 的子数组是： - [4,4,4] 不满足全部条件，因为元素 4 出现重复。\n因为不存在满足全部条件的子数组，所以返回 0 。\n提示：\n1 &lt;= k &lt;= nums.length &lt;= 10^5\n1 &lt;= nums[i] &lt;= 10^5\n\n\n思路说明\n通过哈希表大小控制所有元素各不相同的要求，通过滑动窗口控制字数组的长度k\n\n\n题解\n\n// 2461.长度为K子数组中的最大和\npackage main\n\nimport \"fmt\"\n\nfunc maximumSubarraySum(nums []int, k int) int64 {\n    mp := make(map[int]int)\n    var ans, cnt int64\n\n    for i, num := range nums {\n        cnt += int64(num)\n        mp[num] += 1\n\n        if i &gt;= k {\n            cnt -= int64(nums[i-k])\n            mp[nums[i-k]] -= 1\n            if mp[nums[i-k]] == 0 {\n                delete(mp, nums[i-k])\n            }\n\n        }\n\n        if i &gt;= k-1 && len(mp) == k {\n            ans = max(ans, cnt)\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        nums []int\n        k    int\n    }{\n        {[]int{1, 5, 4, 2, 9, 9, 9}, 3},\n        {[]int{4, 4, 4}, 3},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(maximumSubarraySum(testCase.nums, testCase.k))\n    }\n}\n\n\n\n\n1423. 可获得的最大点数\n\n题面\n几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。\n每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。\n你的点数就是你拿到手中的所有卡牌的点数之和。\n给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。\n示例 1：\n输入：cardPoints = [1,2,3,4,5,6,1], k = 3\n输出：12\n解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。\n示例 2：\n输入：cardPoints = [2,2,2], k = 2\n输出：4\n解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。\n示例 3：\n输入：cardPoints = [9,7,7,9,7,7,9], k = 7\n输出：55\n解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。\n示例 4：\n输入：cardPoints = [1,1000,1], k = 1\n输出：1\n解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。\n示例 5：\n输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3\n输出：202\n提示：\n1 &lt;= cardPoints.length &lt;= 10^5\n1 &lt;= cardPoints[i] &lt;= 10^4\n1 &lt;= k &lt;= cardPoints.length\n\n\n思路说明\n这道题同样归类于滑动窗口，它是首尾构成一个滑动窗口\n我的做法现在数组首部构建一个长度为k的滑动窗口\n然后移动窗口开始尾部移动，直到尾部移动k\n\n\n题解\n\n// 1423.可获得的最大点数\npackage main\n\nimport \"fmt\"\n\nfunc maxScore(cardPoints []int, k int) int {\n    left := k - 1\n    ans, cnt := 0, 0\n\n    for i := 0; i &lt; k; i++ {\n        cnt += cardPoints[i]\n    }\n\n    ans = cnt\n\n    for i := len(cardPoints) - 1; i &gt;= len(cardPoints)-k; i-- {\n        cnt -= cardPoints[left]\n        left -= 1\n        cnt += cardPoints[i]\n\n        ans = max(ans, cnt)\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        nums []int\n        k    int\n    }{\n        {[]int{1, 2, 3, 4, 5, 6, 1}, 3},\n        {[]int{2, 2, 2}, 2},\n        {[]int{9, 7, 7, 9, 7, 7, 9}, 7},\n        {[]int{1, 1000, 1}, 1},\n        {[]int{1, 79, 80, 1, 1, 1, 200, 1}, 3},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(maxSore(testCase.nums, testCase.k))\n    }\n}\n\n\n\n\n\n1176. 健身计划评估\n\n题面\n你的好友是一位健身爱好者。前段日子，他给自己制定了一份健身计划。现在想请你帮他评估一下这份计划是否合理。\n他会有一份计划消耗的卡路里表，其中 calories[i] 给出了你的这位好友在第 i 天需要消耗的卡路里总量。\n为了更好地评估这份计划，对于卡路里表中的每一天，你都需要计算他 「这一天以及之后的连续几天」 （共 k 天）内消耗的总卡路里 T：\n如果 T &lt; lower，那么这份计划相对糟糕，并失去 1 分；\n如果 T &gt; upper，那么这份计划相对优秀，并获得 1 分；\n否则，这份计划普普通通，分值不做变动。\n请返回统计完所有 calories.length 天后得到的总分作为评估结果。\n注意：总分可能是负数。\n示例 1：\n输入：calories = [1,2,3,4,5], k = 1, lower = 3, upper = 3\n输出：0\n解释：calories[0], calories[1] &lt; lower 而 calories[3], calories[4] &gt; upper, 总分 = 0.\n示例 2：\n输入：calories = [3,2], k = 2, lower = 0, upper = 1\n输出：1\n解释：calories[0] + calories[1] &gt; upper, 总分 = 1.\n示例 3：\n输入：calories = [6,5,0,0], k = 2, lower = 1, upper = 5\n输出：0\n解释：calories[0] + calories[1] &gt; upper, calories[2] + calories[3] &lt; lower, 总分 = 0.\n提示：\n1 &lt;= k &lt;= calories.length &lt;= 10^5\n0 &lt;= calories[i] &lt;= 20000\n0 &lt;= lower &lt;= upper\n\n\n思路说明\n构建滑动窗口，统计窗口中消耗的卡路里，然后判断\n基本思路还是按照之前的步骤\n\n\n题解\n\n// 1176.健身计划评估\npackage main\n\nimport \"fmt\"\n\nfunc dietPlanPerformance(calories []int, k, lower, upper int) int {\n    ans, cnt := 0, 0\n\n    for i, calorie := range calories {\n        cnt += calorie\n\n        if i &gt;= k {\n            cnt -= calories[i-k]\n        }\n\n        if i &gt;= k-1 {\n            if cnt &gt; upper {\n                ans += 1\n            }\n\n            if cnt &lt; lower {\n                ans -= 1\n            }\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        calories []int\n        k        int\n        lower    int\n        upper    int\n    }{\n        {[]int{1, 2, 3, 4, 5}, 1, 3, 3},\n        {[]int{3, 2}, 2, 0, 1},\n        {[]int{6, 5, 0, 0}, 2, 1, 5},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(dietPlanPerformance(testCase.calories, testCase.k, testCase.lower, testCase.upper))\n    }\n}\n\n\n\n\n1100. 长度为 K 的无重复字符子串\n\n题面\n给你一个字符串 S，找出所有长度为 K 且不含重复字符的子串，请你返回全部满足要求的子串的 数目。\n示例 1：\n输入：S = “havefunonleetcode”, K = 5\n输出：6\n解释： 这里有 6 个满足题意的子串，分别是：‘havef’,‘avefu’,‘vefun’,‘efuno’,‘etcod’,‘tcode’。\n示例 2：\n输入：S = “home”, K = 5\n输出：0\n解释： 注意：K 可能会大于 S 的长度。在这种情况下，就无法找到任何长度为 K 的子串。\n提示：\n1 &lt;= S.length &lt;= 10^4\nS 中的所有字符均为小写英文字母\n1 &lt;= K &lt;= 10^4\n\n\n思路说明\n使用哈希表控制字符串是否重复\n使用滑动窗口构建长度为k的子串\n\n\n题解\n\n// 1100.长度为K的无重复字符子串\npackage main\n\nimport \"fmt\"\n\nfunc numKLenSubstrNoRepeats(s string, k int) int {\n    mp := make(map[byte]int)\n    ans := 0\n\n    for i := 0; i &lt; len(s); i++ {\n        mp[s[i]] += 1\n\n        if i &gt;= k {\n            mp[s[i-k]] -= 1\n            if mp[s[i-k]] == 0 {\n                delete(mp, s[i-k])\n            }\n        }\n\n        if i &gt;= k-1 && len(mp) == k {\n            ans += 1\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        s string\n        k int\n    }{\n        {\"havefunonleetcode\", 5},\n        {\"home\", 5},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(numKLenSubstrNoRepeats(testCase.s, testCase.k))\n    }\n}\n\n\n\n\n1852. 每个子数组的数字种类数\n\n题面\n给你一个长度为 n 的整数数组 nums 与一个整数 k。你的任务是找到 nums 所有 长度为 k 的子数组中 不同 元素的数量。\n返回一个数组 ans，其中 ans[i] 是对于每个索引 0 &lt;= i &lt; n - k，nums[i..(i + k - 1)] 中不同元素的数量。\n示例 1:\n输入: nums = [1,2,3,2,2,1,3], k = 3\n输出: [3,2,2,2,3]\n解释：每个子数组的数字种类计算方法如下： - nums[0..2] = [1,2,3] 所以 ans[0] = 3 - nums[1..3] = [2,3,2] 所以 ans[1] = 2 - nums[2..4] = [3,2,2] 所以 ans[2] = 2 - nums[3..5] = [2,2,1] 所以 ans[3] = 2 - nums[4..6] = [2,1,3] 所以 ans[4] = 3\n示例 2:\n输入: nums = [1,1,1,1,2,3,4], k = 4\n输出: [1,2,3,4]\n解释: 每个子数组的数字种类计算方法如下： - nums[0..3] = [1,1,1,1] 所以 ans[0] = 1 - nums[1..4] = [1,1,1,2] 所以 ans[1] = 2 - nums[2..5] = [1,1,2,3] 所以 ans[2] = 3 - nums[3..6] = [1,2,3,4] 所以 ans[3] = 4\n提示:\n1 &lt;= k &lt;= nums.length &lt;= 10^5\n1 &lt;= nums[i] &lt;= 10^5\n\n\n思路说明\n构建滑动窗口，长度固定为k\n使用哈希表记录一下窗口内数字的种类，并实时更新\n\n\n题解\n\n// 1852.每个子数组的数字种类数\npackage main\n\nimport \"fmt\"\n\nfunc distinctNumbers(nums []int, k int) []int {\n    mp := make(map[int]int)\n    ans := make([]int, len(nums)-k+1)\n\n    for i, num := range nums {\n        mp[num] += 1\n\n        if i &gt;= k {\n            mp[nums[i-k]] -= 1\n            if mp[nums[i-k]] == 0 {\n                delete(mp, nums[i-k])\n            }\n        }\n\n        if i &gt;= k-1 {\n            ans[i-k+1] = len(mp)\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        nums []int\n        k    int\n    }{\n        {[]int{1, 2, 3, 2, 2, 1, 3}, 3},\n        {[]int{1, 1, 1, 1, 2, 3, 4}, 4},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(distinctNumbers(testCase.nums, testCase.k))\n    }\n}\n\n\n\n\n1151. 最少交换次数来组合所有的 1\n\n题面\n给出一个二进制数组 data，你需要通过交换位置，将数组中 任何位置 上的 1 组合到一起，并返回所有可能中所需 最少的交换次数。\n示例 1:\n输入: data = [1,0,1,0,1]\n输出: 1\n解释:\n有三种可能的方法可以把所有的 1 组合在一起：\n[1,1,1,0,0]，交换 1 次；\n[0,1,1,1,0]，交换 2 次；\n[0,0,1,1,1]，交换 1 次。\n所以最少的交换次数为 1。\n示例 2:\n输入：data = [0,0,0,1,0]\n输出：0\n解释：\n由于数组中只有一个 1，所以不需要交换。\n示例 3:\n输入：data = [1,0,1,0,1,0,0,1,1,0,1]\n输出：3\n解释：\n交换 3 次，一种可行的只用 3 次交换的解决方案是 [0,0,0,0,0,1,1,1,1,1,1]。\n示例 4:\n输入: data = [1,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,0,1]\n输出: 8\n提示:\n1 &lt;= data.length &lt;= 10^5\ndata[i] == 0 or 1.\n\n\n思路说明\n题目的要求是把所有的1都组合在一起，并返回所需要的最少交换次数\n我们首先需要知道数组中1的个数，将这个数量作为滑动窗口的大小\n我们已经得到滑动窗口的大小，然后统计窗口中最大的1的数量，用窗口大小减去这个最大值，就是我们需要的最少交换次数\n\n\n题解\n\n// 1151.最少交换次数来组合所有的1\npackage main\n\nimport \"fmt\"\n\nfunc minSwaps(data []int) int {\n    k := 0 // 滑动窗口的大小\n    for _, val := range data {\n        k += val\n    }\n\n    ans, cnt := 0, 0\n\n    for i, val := range data {\n        cnt += val\n\n        if i &gt;= k {\n            cnt -= data[i-k]\n        }\n\n        if i &gt;= k-1 {\n            ans = max(ans, cnt)\n        }\n    }\n\n    return k - ans\n}\n\nfunc main() {\n    testCases := [][]int{\n        []int{1, 0, 1, 0, 1},\n        []int{0, 0, 0, 1, 0},\n        []int{1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1},\n        []int{1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(minSwaps(testCase))\n    }\n}\n\n\n\n\n2107. 分享 K 个糖果后独特口味的数量\n\n题面\n您将获得一个 从0开始的 整数数组 candies ，其中 candies[i] 表示第 i 个糖果的味道。你妈妈想让你和你妹妹分享这些糖果，给她 k 个 连续 的糖果，但你想保留尽可能多的糖果口味。\n在与妹妹分享后，返回 最多 可保留的 独特 口味的糖果。\n示例 1：\n输入: candies = [1,2,2,3,4,3], k = 3\n输出: 3\n解释: 将[1,3]（含[2,2,3]）范围内的糖果加入[2,2,3]口味。 你可以吃各种口味的糖果[1,4,3]。 有3种独特的口味，所以返回3。\n示例 2:\n输入: candies = [2,2,2,2,3,3], k = 2\n输出: 2\n解释: 在[3,4]范围内（含[2,3]）的糖果中加入[2,3]口味。 你可以吃各种口味的糖果[2,2,2,3]。 有两种独特的口味，所以返回2。 请注意，你也可以分享口味为[2,2]的糖果，吃口味为[2,2,3,3]的糖果。\n示例 3:\n输入: candies = [2,4,5], k = 0\n输出: 3\n解释: 你不必给任何糖果。 你可以吃各种口味的糖果[2,4,5]。 有3种独特的口味，所以返回3。\n提示:\n0 &lt;= candies.length &lt;= 10^5\n1 &lt;= candies[i] &lt;= 10^5\n0 &lt;= k &lt;= candies.length\n\n\n思路说明\n这个题目比较特殊，是要构建一个连续数组，数组长度为k，删除这个数组后剩余的数字种类尽量多\n这样就使用哈希表存储剩余种类和对应数量即可\n还是按照三步进行即可\n\n\n题解\n\n// 2107.分享K个糖果后独特口味的数量\npackage main\n\nimport \"fmt\"\n\nfunc shareCandies(candies []int, k int) int {\n    mp := make(map[int]int)\n    ans := 0\n\n    for _, candie := range candies {\n        mp[candie] += 1\n    }\n\n    for i, candie := range candies {\n        mp[candie] -= 1\n\n        if mp[candie] == 0 {\n            delete(mp, candie)\n        }\n\n        if i &gt;= k {\n            mp[candies[i-k]] += 1\n        }\n\n        if i &gt;= k-1 {\n            ans = max(ans, len(mp))\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        candies []int\n        k       int\n    }{\n        {[]int{1, 2, 2, 3, 4, 3}, 3},\n        {[]int{2, 2, 2, 2, 3, 3}, 2},\n        {[]int{2, 4, 5}, 0},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(shareCandies(testCase.candies, testCase.k))\n    }\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（10）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（10）.html",
    "title": "golang学习记录（10）",
    "section": "",
    "text": "指针是一个变量，其值为另一个变量的地址，即，内存地址。\n指针类型的数据大小为固定值，32位系统为4字节，64位系统为8字节。\n\n\n\n\n取址符号：&\n指针：*\n传过去一个地址，通过指针进行接收\n\n定义一个指针：\nvar a int = 10\nvar p *int = &a\n// 定义了一个指针，p的类型为*int，p指向a的地址\n\n//通过指针修改值\n*p = 20\nfmt.Println(a) //20\n\n不同于C/C++语言中的指针，go语言中的指针限制了指针的运算，不能通过修改指针运算的方式访问其他内存的值\n但是go语言在unsafe包中提供了一些方法，可以通过指针运算的方式访问其他内存的值，但是这种方式是不安全的，不建议使用。\n\n\n\n\n\n指针未初始化时，默认值为nil\n在定义指针时需要进行初始化\n\n指针初始化方式：\nvar a int = 10\n\nvar p *int = &a\n\nvar p2 = new(int) //new函数返回一个指针，指向一个新的int类型的值，值为0\n\n// 如果是结构体还能用下面的方式\np := &Person{}\n\n指针的初始化最好使用new的方式\nmap、slice、channel的初始化最好使用make方式\n指针必须要初始化\nmap必须初始化\n\n\n\n\nfunc swap(a, b *int) {\n    t := *a\n    *a = *b\n    *b = t\n}\n\nfunc main() {\n    var a int = 10\n    var b int = 20\n    swap(&a, &b)\n    fmt.Println(a, b) //20 10\n}\n\n\n\n\n在go中nil代表某一些数据类型中的零值，不同类型数据中的零值是不一样的\n在结构体中nil代表结构体的零值，即所有字段都为零值，他是一个集合体，同时结构体可以通过 == 进行比较，比较的是结构体中的所有字段是否相等。\nnil的slice本质上还是一个结构体，他是slice类型的零值，各个字段都是自己的零值。在make之后地址不是空值，而是指向一个地址（很重要）\nnil的slice不能通过append进行添加元素，否则会报错，因为其地址元素为空。empty的slice可以通过append进行添加元素。（很重要）"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（10）.html#指针的定义和使用",
    "href": "content/learning-notes/golang/entries/golang学习记录（10）.html#指针的定义和使用",
    "title": "golang学习记录（10）",
    "section": "",
    "text": "取址符号：&\n指针：*\n传过去一个地址，通过指针进行接收\n\n定义一个指针：\nvar a int = 10\nvar p *int = &a\n// 定义了一个指针，p的类型为*int，p指向a的地址\n\n//通过指针修改值\n*p = 20\nfmt.Println(a) //20\n\n不同于C/C++语言中的指针，go语言中的指针限制了指针的运算，不能通过修改指针运算的方式访问其他内存的值\n但是go语言在unsafe包中提供了一些方法，可以通过指针运算的方式访问其他内存的值，但是这种方式是不安全的，不建议使用。"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（10）.html#指针的初始化",
    "href": "content/learning-notes/golang/entries/golang学习记录（10）.html#指针的初始化",
    "title": "golang学习记录（10）",
    "section": "",
    "text": "指针未初始化时，默认值为nil\n在定义指针时需要进行初始化\n\n指针初始化方式：\nvar a int = 10\n\nvar p *int = &a\n\nvar p2 = new(int) //new函数返回一个指针，指向一个新的int类型的值，值为0\n\n// 如果是结构体还能用下面的方式\np := &Person{}\n\n指针的初始化最好使用new的方式\nmap、slice、channel的初始化最好使用make方式\n指针必须要初始化\nmap必须初始化"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（10）.html#swap与指针",
    "href": "content/learning-notes/golang/entries/golang学习记录（10）.html#swap与指针",
    "title": "golang学习记录（10）",
    "section": "",
    "text": "func swap(a, b *int) {\n    t := *a\n    *a = *b\n    *b = t\n}\n\nfunc main() {\n    var a int = 10\n    var b int = 20\n    swap(&a, &b)\n    fmt.Println(a, b) //20 10\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（10）.html#go中的nil",
    "href": "content/learning-notes/golang/entries/golang学习记录（10）.html#go中的nil",
    "title": "golang学习记录（10）",
    "section": "",
    "text": "在go中nil代表某一些数据类型中的零值，不同类型数据中的零值是不一样的\n在结构体中nil代表结构体的零值，即所有字段都为零值，他是一个集合体，同时结构体可以通过 == 进行比较，比较的是结构体中的所有字段是否相等。\nnil的slice本质上还是一个结构体，他是slice类型的零值，各个字段都是自己的零值。在make之后地址不是空值，而是指向一个地址（很重要）\nnil的slice不能通过append进行添加元素，否则会报错，因为其地址元素为空。empty的slice可以通过append进行添加元素。（很重要）"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（12）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（12）.html",
    "title": "golang学习记录（12）",
    "section": "",
    "text": "在go中，package是一个非常重要的概念，它是go语言中的一个基本单位，它可以包含多个.go文件，每个.go文件都必须属于一个package，这也是代码复用的基础，其中fmt、os、io等都是一个包\n每个源码文件的第一行都是package xxx，xxx就是这个文件所属的包名\n同一目录之下的源码可以直接使用，不需要import\n\n\n\n\n\n1、import “路径名称”\n2、import 别名 “路径名称”\n3、import .”路径名称”\n\n注意包名称不能重复\n\n\n\n\n1、go.mod是go语言中的一个文件，它是go语言的一个依赖管理文件，它的作用是管理go语言的依赖关系\n2、这个文件的内容是自动维护的\n3、go.mod维护内容下载到一个固定位置中\n\n\n\n\n\n在命令行中设置成国内镜像即可\n\n\n\n\n\n\ngo get 指令用于下载包，它会自动下载包的依赖包\ngo get 依赖地址\ngo get - u 指令用于更新包，它会自动更新包的依赖包\ngo get -u=patch 指令用于更新包到修订版本\n\n\ngo mod help查看能使用的指令，如下：\n\n\n\ngo mod tidy\n\n\n\n\n\ngo mod replace 指令用于替换包，它会自动替换包的依赖包"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（12）.html#package的定义和导入",
    "href": "content/learning-notes/golang/entries/golang学习记录（12）.html#package的定义和导入",
    "title": "golang学习记录（12）",
    "section": "",
    "text": "在go中，package是一个非常重要的概念，它是go语言中的一个基本单位，它可以包含多个.go文件，每个.go文件都必须属于一个package，这也是代码复用的基础，其中fmt、os、io等都是一个包\n每个源码文件的第一行都是package xxx，xxx就是这个文件所属的包名\n同一目录之下的源码可以直接使用，不需要import"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（12）.html#import的方式",
    "href": "content/learning-notes/golang/entries/golang学习记录（12）.html#import的方式",
    "title": "golang学习记录（12）",
    "section": "",
    "text": "1、import “路径名称”\n2、import 别名 “路径名称”\n3、import .”路径名称”\n\n注意包名称不能重复"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（12）.html#go.mod",
    "href": "content/learning-notes/golang/entries/golang学习记录（12）.html#go.mod",
    "title": "golang学习记录（12）",
    "section": "",
    "text": "1、go.mod是go语言中的一个文件，它是go语言的一个依赖管理文件，它的作用是管理go语言的依赖关系\n2、这个文件的内容是自动维护的\n3、go.mod维护内容下载到一个固定位置中"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（12）.html#设置goproxy的国内镜像",
    "href": "content/learning-notes/golang/entries/golang学习记录（12）.html#设置goproxy的国内镜像",
    "title": "golang学习记录（12）",
    "section": "",
    "text": "在命令行中设置成国内镜像即可"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（12）.html#goget与gomod相关指令",
    "href": "content/learning-notes/golang/entries/golang学习记录（12）.html#goget与gomod相关指令",
    "title": "golang学习记录（12）",
    "section": "",
    "text": "go get 指令用于下载包，它会自动下载包的依赖包\ngo get 依赖地址\ngo get - u 指令用于更新包，它会自动更新包的依赖包\ngo get -u=patch 指令用于更新包到修订版本\n\n\ngo mod help查看能使用的指令，如下：\n\n\n\ngo mod tidy"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（12）.html#gomodreplace",
    "href": "content/learning-notes/golang/entries/golang学习记录（12）.html#gomodreplace",
    "title": "golang学习记录（12）",
    "section": "",
    "text": "go mod replace 指令用于替换包，它会自动替换包的依赖包"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（1）-在win搭建go环境.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（1）-在win搭建go环境.html",
    "title": "golang学习记录（1）-在win搭建go环境",
    "section": "",
    "text": "SDK（Soft Development Kit, 软件开发工具包）：是一套工具得集合，方便开发者在特定的编程语言环境下进行开发\n工具通常包含库、框架、文档和使用指导……\n\n\n\n工具包下载网址\n根据自己的需要可以选择不同的工具包，我的是Windows10 64位，选择下载“go1.17.3.windows-arm64.zip” \n下载完成后，在电脑中选择一个地方解压文件即可，尽量解压在D盘中，解压后安装包删除即可，节省空间。\n解压后的目录是下面这样，其中最重要的是bin目录下的“go.exe”，在我们的程序写完之后，需要通过它来编译运行. \n进入到bin目录下，在上方输入cmd，回车进入命令行模式，输入指令,查看go的版本\ngo version\n如果能够正常显示版本号，就表示安装成功 \n\n\n\n\n在安装成功后还需要进行环境变量的配置\n在我的电脑，右击选择属性，之后点击右侧的高级系统设置，点击下方的环境变量，进入环境变量配置\n\ngo需要进行三个环境变量的配置，如下表\n\n\n\n环境变量名称\n作用\n\n\n\n\nGOROOT\n表明go安装的位置\n\n\nPath\n表明go.exe的位置\n\n\nGOPATH\n表明go项目的位置\n\n\n\n配置示例如下：\nGOROOT \nPath \nGOPATH \n测试环境变量是否配置成功： win+R 输入cmd，打开命令行，输入命令查看\ngo version\n 如果能够正常显示版本号，就表示环境变量配置成功。\n\n\n这是我们使用的是“宇宙最强IDE”–VsCode 直接在插件市场选择插件就行，这里我们安装了下面几个： \n在这了我们使用ctrl+shift+p，输入Go: install/update tools后回车即可自动安装。"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（1）-在win搭建go环境.html#golong环境搭建",
    "href": "content/learning-notes/golang/entries/golang学习记录（1）-在win搭建go环境.html#golong环境搭建",
    "title": "golang学习记录（1）-在win搭建go环境",
    "section": "",
    "text": "SDK（Soft Development Kit, 软件开发工具包）：是一套工具得集合，方便开发者在特定的编程语言环境下进行开发\n工具通常包含库、框架、文档和使用指导……\n\n\n\n工具包下载网址\n根据自己的需要可以选择不同的工具包，我的是Windows10 64位，选择下载“go1.17.3.windows-arm64.zip” \n下载完成后，在电脑中选择一个地方解压文件即可，尽量解压在D盘中，解压后安装包删除即可，节省空间。\n解压后的目录是下面这样，其中最重要的是bin目录下的“go.exe”，在我们的程序写完之后，需要通过它来编译运行. \n进入到bin目录下，在上方输入cmd，回车进入命令行模式，输入指令,查看go的版本\ngo version\n如果能够正常显示版本号，就表示安装成功 \n\n\n\n\n在安装成功后还需要进行环境变量的配置\n在我的电脑，右击选择属性，之后点击右侧的高级系统设置，点击下方的环境变量，进入环境变量配置\n\ngo需要进行三个环境变量的配置，如下表\n\n\n\n环境变量名称\n作用\n\n\n\n\nGOROOT\n表明go安装的位置\n\n\nPath\n表明go.exe的位置\n\n\nGOPATH\n表明go项目的位置\n\n\n\n配置示例如下：\nGOROOT \nPath \nGOPATH \n测试环境变量是否配置成功： win+R 输入cmd，打开命令行，输入命令查看\ngo version\n 如果能够正常显示版本号，就表示环境变量配置成功。\n\n\n这是我们使用的是“宇宙最强IDE”–VsCode 直接在插件市场选择插件就行，这里我们安装了下面几个： \n在这了我们使用ctrl+shift+p，输入Go: install/update tools后回车即可自动安装。"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（3）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（3）.html",
    "title": "golang学习记录（3）",
    "section": "",
    "text": "go是一种静态语言，变量的类型是在编译阶段确定的。 &gt; 变量必须先定义后使用 &gt; &gt; 变量必须要有类型 &gt; &gt; 变量类型定下来后不能改变\n\n\n\n\n// 第一种\nvar age int (string bool 等)\nage = 10\n// 第二种\nvar age = 10\n// 第三种\nage := 10\n\n\n\n\n全局变量：在函数外部定义的变量，作用域为整个包\n局部变量：在函数内部定义的变量，作用域为函数内部\n\n注：全局变量定义之后可以不使用，但是局部变量定义之后必须要使用\n\n\n\n// 第一种\nvar user1, user2, user3 string\n// 第二种\nvar user1, user2, user3 = \"user1\", 1, true\n// 第三种\nvar (\n    user1 string\n    user2 int\n    user3 bool\n)\n\n\n\n1、变量必须事先定义 2、公式静态语言，要求变量类型和赋值类型一致 3、变量名不能冲突 4、简介变量定义不能作为全局变量（age := 1） 5、变量有零值，也就是默认值\nvar age int //age默认为0\nvar name string //name默认为\"\"\nvar isOk bool //isOk默认为false\n6、全局变量定义之后可以不使用，但是局部变量定义之后必须要使用，否则会报错\n\n\n\n\n\n常量，是在定义的时候就指定的值，不能修改\n在go语言中，常量定义的时候尽量全部大写，便于区分 ### 2.1、定义常量的方式\n\n// 第一种\nconst PI float32 = 3.1415926 //显示定义\nconst PI = 3.1415926 //隐式定义\n// 之后PI不能改变\nPI = 3.1415926 //报错\n\n\n变量在成组进行定义是也有多种方式\nconst(\n    PI float32 = 3.1415926\n    PI2 = 'a'\n    PI3 = 3\n)\n特别的：\ncosnt(\n    x int  = 1p\n    y\n    s = 'a'\n    z\n    m\n)\n\n\n\n\n1、常量类型只能是bool、数值和字符串 2、常量没有强制使用的要求，定义之后可以选择不使用 3、显示指定类型的时候，必须保证常量左右值类型一致\n\n\n\n\n\n一种能够被编译器修改的特殊常量\n\n\n\n//写法1\nconst (\n    ERR0 = iota\n    ERR1 = iota\n    ERR2 = iota\n    ERR3 = iota\n    ERR4 = iota\n)\n// 输出为：0、1、2、3、4\n//写法2\nconst (\n    ERR0 = iota\n    ERR1\n    ERR2\n    ERR3\n    ERR4\n)\n// 输出也为0、1、2、3、4\n有关iota的计数器特性，如下图 \n\niota内部有同一个计数器，自己递增，不受赋值的影响\n出现新的const时，iota会归零 ### 3.2、注意事项 1、如果中断了iota必须显示恢复，后续会自动递增 2、iota默认类型是int型 3、iota能简化const类型的定义 4、每次出现新的const之后iota会归0\n\n\n\n\n\n用下划线进行标识，不使用不会报错\n如：var _ int = 10\n在go语言中，匿名变量是指没有名字的变量。匿名变量在函数中经常被用作占位符，用于接收函数返回的多个值中的一部分。 下面是一个应用场景的举例： \n\n\n\n\n\n\n在函数外部定义的变量，作用域为整个包。\n\n\n\n在函数内部定义的变量，作用域为函数内部。\n有严格限制，在使用的时候需要注意。"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（3）.html#变量",
    "href": "content/learning-notes/golang/entries/golang学习记录（3）.html#变量",
    "title": "golang学习记录（3）",
    "section": "",
    "text": "// 第一种\nvar age int (string bool 等)\nage = 10\n// 第二种\nvar age = 10\n// 第三种\nage := 10\n\n\n\n\n全局变量：在函数外部定义的变量，作用域为整个包\n局部变量：在函数内部定义的变量，作用域为函数内部\n\n注：全局变量定义之后可以不使用，但是局部变量定义之后必须要使用\n\n\n\n// 第一种\nvar user1, user2, user3 string\n// 第二种\nvar user1, user2, user3 = \"user1\", 1, true\n// 第三种\nvar (\n    user1 string\n    user2 int\n    user3 bool\n)\n\n\n\n1、变量必须事先定义 2、公式静态语言，要求变量类型和赋值类型一致 3、变量名不能冲突 4、简介变量定义不能作为全局变量（age := 1） 5、变量有零值，也就是默认值\nvar age int //age默认为0\nvar name string //name默认为\"\"\nvar isOk bool //isOk默认为false\n6、全局变量定义之后可以不使用，但是局部变量定义之后必须要使用，否则会报错"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（3）.html#常量",
    "href": "content/learning-notes/golang/entries/golang学习记录（3）.html#常量",
    "title": "golang学习记录（3）",
    "section": "",
    "text": "常量，是在定义的时候就指定的值，不能修改\n在go语言中，常量定义的时候尽量全部大写，便于区分 ### 2.1、定义常量的方式\n\n// 第一种\nconst PI float32 = 3.1415926 //显示定义\nconst PI = 3.1415926 //隐式定义\n// 之后PI不能改变\nPI = 3.1415926 //报错\n\n\n变量在成组进行定义是也有多种方式\nconst(\n    PI float32 = 3.1415926\n    PI2 = 'a'\n    PI3 = 3\n)\n特别的：\ncosnt(\n    x int  = 1p\n    y\n    s = 'a'\n    z\n    m\n)\n\n\n\n\n1、常量类型只能是bool、数值和字符串 2、常量没有强制使用的要求，定义之后可以选择不使用 3、显示指定类型的时候，必须保证常量左右值类型一致"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（3）.html#iota",
    "href": "content/learning-notes/golang/entries/golang学习记录（3）.html#iota",
    "title": "golang学习记录（3）",
    "section": "",
    "text": "一种能够被编译器修改的特殊常量\n\n\n\n//写法1\nconst (\n    ERR0 = iota\n    ERR1 = iota\n    ERR2 = iota\n    ERR3 = iota\n    ERR4 = iota\n)\n// 输出为：0、1、2、3、4\n//写法2\nconst (\n    ERR0 = iota\n    ERR1\n    ERR2\n    ERR3\n    ERR4\n)\n// 输出也为0、1、2、3、4\n有关iota的计数器特性，如下图 \n\niota内部有同一个计数器，自己递增，不受赋值的影响\n出现新的const时，iota会归零 ### 3.2、注意事项 1、如果中断了iota必须显示恢复，后续会自动递增 2、iota默认类型是int型 3、iota能简化const类型的定义 4、每次出现新的const之后iota会归0"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（3）.html#匿名变量",
    "href": "content/learning-notes/golang/entries/golang学习记录（3）.html#匿名变量",
    "title": "golang学习记录（3）",
    "section": "",
    "text": "用下划线进行标识，不使用不会报错\n如：var _ int = 10\n在go语言中，匿名变量是指没有名字的变量。匿名变量在函数中经常被用作占位符，用于接收函数返回的多个值中的一部分。 下面是一个应用场景的举例："
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（3）.html#变量的作用域",
    "href": "content/learning-notes/golang/entries/golang学习记录（3）.html#变量的作用域",
    "title": "golang学习记录（3）",
    "section": "",
    "text": "在函数外部定义的变量，作用域为整个包。\n\n\n\n在函数内部定义的变量，作用域为函数内部。\n有严格限制，在使用的时候需要注意。"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（5）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（5）.html",
    "title": "golang学习记录（5）",
    "section": "",
    "text": "通常在各种语言中转义符都是同一个：，千万不要写反\n\n举例：\nname := \"你可真是个\\\"小机灵鬼\\\"\"\n//在这里直接使用\"小机灵鬼\"会报错，因为双引号是字符串的标志，所以需要使用转义符来表示引号：\\\"\n\n\n\n在golang中常用的转义符如下：\n\n\n\n\n\nPrintln:表示输出换行 Print:表示输出不换行 ### 2.1、基本使用\n通常情况下使用平凑方法进行输出非常麻烦： \n使用格式化输出的方法–Printf:\nfmt.Printf(\"用户名：%s， 年龄：%d，地址：%s， 电话：%s\\r\\n\",username, age, address, mobile )\n\n\n优点：易读易维护\n缺点：性能相对较低\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n计算字符串的长度也有很多种情况\n\n\nname := \"hello world\"\nfmt.Println(len(name))\n\n\n\nname := \"hello 世界\"\nbytes := []byte(name)\nfmt.Println(len(bytes))\n\n\n\n\n\n\nusername := \"user\" + \"name\"\n\n\n\nfmt.Printf(\"用户名：%s， 年龄：%d，地址：%s， 电话：%s\\r\\n\",username, age, address, mobile )\n\n\n\n\n这是一种高性能的方式\n\nvar builder strings.Builder\nbuilder.WriteString(\"hello\")\nbuilder.WriteString(\"world\")\nresult := builder.String()\nfmt.Println(result)\n\n\n\n\n//等于\na := \"hello\"\nb := \"hello\"\nfmt.Println(a == b)\n\n//不等于\na = \"hello\"\nb = \"world\"\nfmt.Println(a != b)\n\n//大于\na = \"hello\"\nb = \"world\"\nfmt.Println(a &gt; b)\n\n//小于\na = \"hello\"\nb = \"world\"\nfmt.Println(a &lt; b)\n\n//大于等于\n//小于等于\n//……\n\n\n\n\n\nimport {\n    \"fmt\"\n    \"strings\"\n}\n\n\n\n(1)、是否包含指定字符串\nstrings.Contains(\"hello world\", \"world\")\n(2)、字符串的长度\nname := \"hello world\"\nlen(name)\n(3)、查询字串出现的次数\nstrings.Count(\"hello world\", \"l\")\n(4)、分割字符串\n//以空格为分隔符进行分割\nstrings.Split(\"hello world\", \" \")\n(5)、字符串是否包含前后缀\n//前缀\nstrings.HasPrefix(\"hello world\", \"he\")\n\n//后缀\nstrings.HasSuffix(\"hello world\", \"ld\")\n(6)、查询字串出现的位置\n//英文\nstrings.Index(\"hello world\", \"lo\")\n(7)、字串替换\n//把字符串里的所有l替换成a，替换前2个\n//-1表示全部替换\nstrings.Replace(\"hello world\", \"l\", \"a\", 2)\n(8)、大小写转换\n//全转成小写\nstrings.ToLower(\"HELLO WORLD\")\n\n//全转成大写\nstrings.ToUpper(\"hello world\")\n(9)、去掉特殊字符\n//去掉左右两边指定的字符，指定的字符可以是多个，比如空格，#，*等\nstrings.Trim(\"#hello #world#\", \"#\")\n//得到的结果是：hello #world\n\n//左边的特殊字符\nstrings.TrimLeft(\"#hello #world#\", \"#\")\n//得到的结果是：hello #world#\n\n//右边的特殊字符\nstrings.TrimRight(\"#hello #world#\", \"#\")\n//得到的结果是：#hello #world\n\n更多方法可以查看源码，在ide中点击显示的函数可以直接转换到源码"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（5）.html#转义符",
    "href": "content/learning-notes/golang/entries/golang学习记录（5）.html#转义符",
    "title": "golang学习记录（5）",
    "section": "",
    "text": "通常在各种语言中转义符都是同一个：，千万不要写反\n\n举例：\nname := \"你可真是个\\\"小机灵鬼\\\"\"\n//在这里直接使用\"小机灵鬼\"会报错，因为双引号是字符串的标志，所以需要使用转义符来表示引号：\\\"\n\n\n\n在golang中常用的转义符如下："
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（5）.html#格式化输出",
    "href": "content/learning-notes/golang/entries/golang学习记录（5）.html#格式化输出",
    "title": "golang学习记录（5）",
    "section": "",
    "text": "Println:表示输出换行 Print:表示输出不换行 ### 2.1、基本使用\n通常情况下使用平凑方法进行输出非常麻烦： \n使用格式化输出的方法–Printf:\nfmt.Printf(\"用户名：%s， 年龄：%d，地址：%s， 电话：%s\\r\\n\",username, age, address, mobile )\n\n\n优点：易读易维护\n缺点：性能相对较低"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（5）.html#字符串操作常用方法",
    "href": "content/learning-notes/golang/entries/golang学习记录（5）.html#字符串操作常用方法",
    "title": "golang学习记录（5）",
    "section": "",
    "text": "计算字符串的长度也有很多种情况\n\n\nname := \"hello world\"\nfmt.Println(len(name))\n\n\n\nname := \"hello 世界\"\nbytes := []byte(name)\nfmt.Println(len(bytes))\n\n\n\n\n\n\nusername := \"user\" + \"name\"\n\n\n\nfmt.Printf(\"用户名：%s， 年龄：%d，地址：%s， 电话：%s\\r\\n\",username, age, address, mobile )\n\n\n\n\n这是一种高性能的方式\n\nvar builder strings.Builder\nbuilder.WriteString(\"hello\")\nbuilder.WriteString(\"world\")\nresult := builder.String()\nfmt.Println(result)\n\n\n\n\n//等于\na := \"hello\"\nb := \"hello\"\nfmt.Println(a == b)\n\n//不等于\na = \"hello\"\nb = \"world\"\nfmt.Println(a != b)\n\n//大于\na = \"hello\"\nb = \"world\"\nfmt.Println(a &gt; b)\n\n//小于\na = \"hello\"\nb = \"world\"\nfmt.Println(a &lt; b)\n\n//大于等于\n//小于等于\n//……\n\n\n\n\n\nimport {\n    \"fmt\"\n    \"strings\"\n}\n\n\n\n(1)、是否包含指定字符串\nstrings.Contains(\"hello world\", \"world\")\n(2)、字符串的长度\nname := \"hello world\"\nlen(name)\n(3)、查询字串出现的次数\nstrings.Count(\"hello world\", \"l\")\n(4)、分割字符串\n//以空格为分隔符进行分割\nstrings.Split(\"hello world\", \" \")\n(5)、字符串是否包含前后缀\n//前缀\nstrings.HasPrefix(\"hello world\", \"he\")\n\n//后缀\nstrings.HasSuffix(\"hello world\", \"ld\")\n(6)、查询字串出现的位置\n//英文\nstrings.Index(\"hello world\", \"lo\")\n(7)、字串替换\n//把字符串里的所有l替换成a，替换前2个\n//-1表示全部替换\nstrings.Replace(\"hello world\", \"l\", \"a\", 2)\n(8)、大小写转换\n//全转成小写\nstrings.ToLower(\"HELLO WORLD\")\n\n//全转成大写\nstrings.ToUpper(\"hello world\")\n(9)、去掉特殊字符\n//去掉左右两边指定的字符，指定的字符可以是多个，比如空格，#，*等\nstrings.Trim(\"#hello #world#\", \"#\")\n//得到的结果是：hello #world\n\n//左边的特殊字符\nstrings.TrimLeft(\"#hello #world#\", \"#\")\n//得到的结果是：hello #world#\n\n//右边的特殊字符\nstrings.TrimRight(\"#hello #world#\", \"#\")\n//得到的结果是：#hello #world\n\n更多方法可以查看源码，在ide中点击显示的函数可以直接转换到源码"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（7）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（7）.html",
    "title": "golang学习记录（7）",
    "section": "",
    "text": "数组的定义： var name [length] type\n举个例子： var name [5] int\n当中括号内没有length，就表示数组的长度是不确定的，这种数组叫做切片。\n\n\n\n\nfmt.Println(name)，可以打印数组的所有元素\n数组的长度是固定的\n\n数组的遍历：\nfor _, value := range name{\n    fmt.Prinntln(value)\n}\n\n\n\n//多种初始化方式\nvar name [5] int = [5]int{1, 2, 3, 4, 5}\nvar name = [5]int{1, 2, 3, 4, 5}\nname := [5]int{1, 2, 3, 4, 5}\n\n//只初始化部分元素\nname := [3]int{2:3}\n//前面的都为0，name[2] = 3\n\n//数组的长度是不确定的\nname := [...]int{1, 2, 3, 4, 5}\nname := [...]int{1, 2, 3}\n\n相同类型，长度相同的数据可以相互赋值，字符串类型的可以相互比较\n\n\n\n\n//基本定义方式\nvar name [3][4] string\nname[0] = [4]string{\"a\", \"b\", \"c\", \"d\"}\nname[0][0] = \"a\"\n\n\n\n\n\n切片就是没有长度的数组，切片的长度是不固定的，切片是数组的一个引用，切片是引用类型。\n\n\n\n\n\nvar name []string\nfmt.Printf(%T, name)\n//输出结果为[]string，本质是切片\n\n\n\n// 使用append来增加元素，注意书写的格式\nname = append(name, \"a\")\n\n\n\n\n\n初始化一共有三种方式\n1、数组直接创建\n2、使用string{}\n3、使用make\n\n// 第一种\nallName := [5]string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\nnameSlice := allName[0:2] // \"左闭右开，包含0，不包含2\"\n\n//第二种\nallName := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\n//在切片上也可以进行切片创建\n\n//第三种\n//第一个参数是切片的类型，第二个参数是预分配的空间（长度）\nallName := make([]string, 5)\n\n\n\nallName := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\n\nsliceName := allName[start:end] //左闭右开\n//如果没有end，默认是到最后一个元素\n//没有start,有end，默认是从第一个元素开始到end之前的元素\n//冒号一定存在\n\n\n\n\n再append得使用过程中，添加的元素可以是多个\n可以通过直接添加元素的方式加入\n也可以通过使用数组或者切片加省略号的方式加入（通过加入省略号将原来的元素打散）\n// 直接列出元素的情况\nname := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\nname = append(name, \"fff\", \"ggg\", \"hhh\")\n\n// 通过切片加入的情况\nname := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\nname2 := []string{\"fff\", \"ggg\", \"hhh\"}\nname = append(name, name2...)\n\n// 通过数组加入的情况\nname := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\nname2 := [3]string{\"fff\", \"ggg\", \"hhh\"}\nname = append(name, name2[:]...)\n\n\n\n\n\n\n切片的删除操作是append或者其他重新生成slice的方式进行\n\n// 切片的删除操作\nname := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\n// 删除一个中间的元素\nnewName = append(name[:2], name[3:]...)\n\n// 删除后面的元素\nnewName := name[:3]\nnewName = append(name[:3])\n\n\n\n\n拷贝也有多种方式\n\nname := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\n\n// 第一种切片赋值\nname2 := name[:]\n\n// 第二种使用copy函数\nvar name3 = make([]string, len(name))\ncopy(name3, name)\n\n不同切片复制的方式会有不同的效果\n\n示例如下： \n从图中可以看出，改变原来的切片，切片赋值的方式，会改变新的切片，而copy函数的方式，不会改变新的切片。\n本质上是因为切片赋值的方式，是将原来的切片的地址赋值给了新的切片，而copy函数的方式，是将原来的切片的元素复制到了新的切片中（地址是新分配的）。\n\n\n\n\n\ngo的slice在函数参数传递的时候是值传递还是引用传递\n本质上是值传递，但是呈现出引用的效果，这涉及slice的底层原理\n在go中，slice的底层是一个结构体，结构体中有三个字段，分别是指向底层数组的指针，切片的长度和切片的容量\n\n\n\n// slice的底层结构如下：\ntype slice struct {\n    array unsafe.Pointer   //用来存储实际数据的数组指针只想一块连续的内存\n    len int                //切片中元素的数量\n    cap int                //array数组的长度\n}\n\n\n\n刚开始的时候slice会申请一个较大的容量，扩容是一个非常麻烦的过程：\n\n扩容的时候刚开始是成倍的扩容，等到空间变大时扩容会减缓\n\n\n\n\n在参数传递的时候会将原来的结构体整体复制一份，多以指向数组的指针也复制了，指针指向原来切片指向的位置\n之后随着元素的加入会发生扩容，会将原来的数组复制到一个新的数组中，然后将原来的数组的指针指向新的数组，然后将原来的数组的长度和容量都改为原来的两倍。这个时候指针的位置发生变化\n所以参数传递后能改变原来切片的元素，但是不能改变原来切片的长度和容量。参数传递扩容后不会改变原来切片的元素。 {: .prompt-tip }\n\n下面是一个例子：\n\n\n\n\n\n\n\n\nmap是一个key-value的无序集合，主要是为了查询方便，时间复杂度为O(1)\nmap中的key是唯一的，value可以重复\nmap中key的类型可以是bool、数字、string、指针、channel、还可以是只包含前面几个类型的接口、结构体、数组，但是不能是slice、map、function，value可以是任意类型\n\n\n\n举个例子：\nvar courseMap map[string]string{\n    \"courseName\": \"golang\",\n    \"courseType\": \"backend\",\n}\n// 其中基本格式是map[key_type] value_type\n\n\n\nmap类型想要使用必须先要初始化，不然map为nil(空指针)，会报错，不能使用\n初始化的方式主要有两种，一种是在定义的时候直接赋值，第二种是使用make函数进行初始化，分配空间，创建一个空的map\n\n// 第一种初始化方式\nvar courseMap map[string]string{\n    \"courseName\": \"golang\",\n    \"courseType\": \"backend\",\n}\n\n// 第二种初始化方式\nvar courseMap = make(map[string] string, 10)//make是一个内置函数\ncoueseMap[\"courseName\"] = \"golang\"\n相比之下，slice可以不进行初始化\n\n\n\n\nmap的获取元素的方式是通过key来获取value\n如果key不存在，会返回value的零值\n\nvar courseMap map[string]string{\n    \"courseName\": \"golang\",\n    \"courseType\": \"backend\",\n}\nfmt.Println(courseMap[\"courseName\"])\n\n// 第二种获取元素的方式\nvalue, ok := courseMap[\"courseName\"]\nif ok{\n    fmt.Println(value)\n}else{\n    fmt.Println(\"key不存在\")\n}\n\nif value, ok := courseMap[\"courseName\"]; ok{\n    fmt.Println(value)\n}else{\n    fmt.Println(\"key不存在\")\n}\n\n\n\n\nmap有一个内置的delete函数，用来删除map中的元素\n如果删除的元素不存在也不会报错\n\ndelete(courseMap, \"courseName\")\n//delete(map_name, key)\n\n\n\n\n\nmap的遍历是通过for-range的方式进行遍历\nmap是无序的，所以遍历的顺序是不确定的，每次打印的顺序可能不一样\n\n//第一种遍历方式，两个参数\nfor _, value := range courseMap{\n    fmt.Println(value)\n}\n\n// 第二种遍历方式，一个参数，key，然后通过key访问value\nfor key := range courseMap{\n    fmt.Println(key, courseMap[key])\n}\n\n\n\n\n\n\n\nlist是一个”双向链表”，是一个有序的集合，主要是为了插入和删除方便，利用不连续空间\nlist占用空间比较多，会额外存储指针，指向前后的元素\n列表插入和删除比较方便，查询比较麻烦，时间复杂度为O(n)\n\n\n\n\nvar mylist list.List\nmylist.PushBack(\"go\")\nmylist.PushBack(\"java\")\nmylist.PushBack(\"python\")\n\n// 遍历list(正向)\nfor i := mylist.Front(); i!= nil; i = i.Next(){\n    fmt.Println(i.Value)\n}\n\n// 反向遍历\nfor i:= mtlist.Back(); i != nil; i = i.Prev(){\n    fmt.Println(i.Value)\n}\n\nmylist.PushFront(\"c++\")//头部插入元素\nmylist.PushBack(\"c\")//尾部插入元素\nmylist.InsertAfter(\"c#\", mylist.Front())//在指定元素后面插入元素\nmylist.InsertBefore(\"c#\", mylist.Back())//在指定元素前面插入元素\n\nmylist.Remove(mylist.Front())//删除头部元素\nmylist.Remove(mylist.Back())//删除尾部元素\\\nmylist.Remove(i))//删除指定元素"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（7）.html#数组",
    "href": "content/learning-notes/golang/entries/golang学习记录（7）.html#数组",
    "title": "golang学习记录（7）",
    "section": "",
    "text": "数组的定义： var name [length] type\n举个例子： var name [5] int\n当中括号内没有length，就表示数组的长度是不确定的，这种数组叫做切片。\n\n\n\n\nfmt.Println(name)，可以打印数组的所有元素\n数组的长度是固定的\n\n数组的遍历：\nfor _, value := range name{\n    fmt.Prinntln(value)\n}\n\n\n\n//多种初始化方式\nvar name [5] int = [5]int{1, 2, 3, 4, 5}\nvar name = [5]int{1, 2, 3, 4, 5}\nname := [5]int{1, 2, 3, 4, 5}\n\n//只初始化部分元素\nname := [3]int{2:3}\n//前面的都为0，name[2] = 3\n\n//数组的长度是不确定的\nname := [...]int{1, 2, 3, 4, 5}\nname := [...]int{1, 2, 3}\n\n相同类型，长度相同的数据可以相互赋值，字符串类型的可以相互比较\n\n\n\n\n//基本定义方式\nvar name [3][4] string\nname[0] = [4]string{\"a\", \"b\", \"c\", \"d\"}\nname[0][0] = \"a\""
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（7）.html#切片",
    "href": "content/learning-notes/golang/entries/golang学习记录（7）.html#切片",
    "title": "golang学习记录（7）",
    "section": "",
    "text": "切片就是没有长度的数组，切片的长度是不固定的，切片是数组的一个引用，切片是引用类型。\n\n\n\n\n\nvar name []string\nfmt.Printf(%T, name)\n//输出结果为[]string，本质是切片\n\n\n\n// 使用append来增加元素，注意书写的格式\nname = append(name, \"a\")\n\n\n\n\n\n初始化一共有三种方式\n1、数组直接创建\n2、使用string{}\n3、使用make\n\n// 第一种\nallName := [5]string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\nnameSlice := allName[0:2] // \"左闭右开，包含0，不包含2\"\n\n//第二种\nallName := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\n//在切片上也可以进行切片创建\n\n//第三种\n//第一个参数是切片的类型，第二个参数是预分配的空间（长度）\nallName := make([]string, 5)\n\n\n\nallName := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\n\nsliceName := allName[start:end] //左闭右开\n//如果没有end，默认是到最后一个元素\n//没有start,有end，默认是从第一个元素开始到end之前的元素\n//冒号一定存在\n\n\n\n\n再append得使用过程中，添加的元素可以是多个\n可以通过直接添加元素的方式加入\n也可以通过使用数组或者切片加省略号的方式加入（通过加入省略号将原来的元素打散）\n// 直接列出元素的情况\nname := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\nname = append(name, \"fff\", \"ggg\", \"hhh\")\n\n// 通过切片加入的情况\nname := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\nname2 := []string{\"fff\", \"ggg\", \"hhh\"}\nname = append(name, name2...)\n\n// 通过数组加入的情况\nname := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\nname2 := [3]string{\"fff\", \"ggg\", \"hhh\"}\nname = append(name, name2[:]...)\n\n\n\n\n\n\n切片的删除操作是append或者其他重新生成slice的方式进行\n\n// 切片的删除操作\nname := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\n// 删除一个中间的元素\nnewName = append(name[:2], name[3:]...)\n\n// 删除后面的元素\nnewName := name[:3]\nnewName = append(name[:3])\n\n\n\n\n拷贝也有多种方式\n\nname := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\n\n// 第一种切片赋值\nname2 := name[:]\n\n// 第二种使用copy函数\nvar name3 = make([]string, len(name))\ncopy(name3, name)\n\n不同切片复制的方式会有不同的效果\n\n示例如下： \n从图中可以看出，改变原来的切片，切片赋值的方式，会改变新的切片，而copy函数的方式，不会改变新的切片。\n本质上是因为切片赋值的方式，是将原来的切片的地址赋值给了新的切片，而copy函数的方式，是将原来的切片的元素复制到了新的切片中（地址是新分配的）。\n\n\n\n\n\ngo的slice在函数参数传递的时候是值传递还是引用传递\n本质上是值传递，但是呈现出引用的效果，这涉及slice的底层原理\n在go中，slice的底层是一个结构体，结构体中有三个字段，分别是指向底层数组的指针，切片的长度和切片的容量\n\n\n\n// slice的底层结构如下：\ntype slice struct {\n    array unsafe.Pointer   //用来存储实际数据的数组指针只想一块连续的内存\n    len int                //切片中元素的数量\n    cap int                //array数组的长度\n}\n\n\n\n刚开始的时候slice会申请一个较大的容量，扩容是一个非常麻烦的过程：\n\n扩容的时候刚开始是成倍的扩容，等到空间变大时扩容会减缓\n\n\n\n\n在参数传递的时候会将原来的结构体整体复制一份，多以指向数组的指针也复制了，指针指向原来切片指向的位置\n之后随着元素的加入会发生扩容，会将原来的数组复制到一个新的数组中，然后将原来的数组的指针指向新的数组，然后将原来的数组的长度和容量都改为原来的两倍。这个时候指针的位置发生变化\n所以参数传递后能改变原来切片的元素，但是不能改变原来切片的长度和容量。参数传递扩容后不会改变原来切片的元素。 {: .prompt-tip }\n\n下面是一个例子："
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（7）.html#map",
    "href": "content/learning-notes/golang/entries/golang学习记录（7）.html#map",
    "title": "golang学习记录（7）",
    "section": "",
    "text": "map是一个key-value的无序集合，主要是为了查询方便，时间复杂度为O(1)\nmap中的key是唯一的，value可以重复\nmap中key的类型可以是bool、数字、string、指针、channel、还可以是只包含前面几个类型的接口、结构体、数组，但是不能是slice、map、function，value可以是任意类型\n\n\n\n举个例子：\nvar courseMap map[string]string{\n    \"courseName\": \"golang\",\n    \"courseType\": \"backend\",\n}\n// 其中基本格式是map[key_type] value_type\n\n\n\nmap类型想要使用必须先要初始化，不然map为nil(空指针)，会报错，不能使用\n初始化的方式主要有两种，一种是在定义的时候直接赋值，第二种是使用make函数进行初始化，分配空间，创建一个空的map\n\n// 第一种初始化方式\nvar courseMap map[string]string{\n    \"courseName\": \"golang\",\n    \"courseType\": \"backend\",\n}\n\n// 第二种初始化方式\nvar courseMap = make(map[string] string, 10)//make是一个内置函数\ncoueseMap[\"courseName\"] = \"golang\"\n相比之下，slice可以不进行初始化\n\n\n\n\nmap的获取元素的方式是通过key来获取value\n如果key不存在，会返回value的零值\n\nvar courseMap map[string]string{\n    \"courseName\": \"golang\",\n    \"courseType\": \"backend\",\n}\nfmt.Println(courseMap[\"courseName\"])\n\n// 第二种获取元素的方式\nvalue, ok := courseMap[\"courseName\"]\nif ok{\n    fmt.Println(value)\n}else{\n    fmt.Println(\"key不存在\")\n}\n\nif value, ok := courseMap[\"courseName\"]; ok{\n    fmt.Println(value)\n}else{\n    fmt.Println(\"key不存在\")\n}\n\n\n\n\nmap有一个内置的delete函数，用来删除map中的元素\n如果删除的元素不存在也不会报错\n\ndelete(courseMap, \"courseName\")\n//delete(map_name, key)\n\n\n\n\n\nmap的遍历是通过for-range的方式进行遍历\nmap是无序的，所以遍历的顺序是不确定的，每次打印的顺序可能不一样\n\n//第一种遍历方式，两个参数\nfor _, value := range courseMap{\n    fmt.Println(value)\n}\n\n// 第二种遍历方式，一个参数，key，然后通过key访问value\nfor key := range courseMap{\n    fmt.Println(key, courseMap[key])\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（7）.html#list",
    "href": "content/learning-notes/golang/entries/golang学习记录（7）.html#list",
    "title": "golang学习记录（7）",
    "section": "",
    "text": "list是一个”双向链表”，是一个有序的集合，主要是为了插入和删除方便，利用不连续空间\nlist占用空间比较多，会额外存储指针，指向前后的元素\n列表插入和删除比较方便，查询比较麻烦，时间复杂度为O(n)\n\n\n\n\nvar mylist list.List\nmylist.PushBack(\"go\")\nmylist.PushBack(\"java\")\nmylist.PushBack(\"python\")\n\n// 遍历list(正向)\nfor i := mylist.Front(); i!= nil; i = i.Next(){\n    fmt.Println(i.Value)\n}\n\n// 反向遍历\nfor i:= mtlist.Back(); i != nil; i = i.Prev(){\n    fmt.Println(i.Value)\n}\n\nmylist.PushFront(\"c++\")//头部插入元素\nmylist.PushBack(\"c\")//尾部插入元素\nmylist.InsertAfter(\"c#\", mylist.Front())//在指定元素后面插入元素\nmylist.InsertBefore(\"c#\", mylist.Back())//在指定元素前面插入元素\n\nmylist.Remove(mylist.Front())//删除头部元素\nmylist.Remove(mylist.Back())//删除尾部元素\\\nmylist.Remove(i))//删除指定元素"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（9）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（9）.html",
    "title": "golang学习记录（9）",
    "section": "",
    "text": "type关键字常用于\n定义结构体\n定义接口\n定义类型别名\n类型定义\n类型判断\n\n\n\n\n别名可以让使用者更好理解代码，提高代码的可读性和可维护性，在编译的时候，会将别名编译为原来的类型\n\n//以定义int的别名举例\ntype MyInt = int\nvar i MyInt\nfmt.Println(\"%T\\n\", i)\n//上面代码输出的结果为int，相当一给int取了一个小名，MyInt本质上还是int\n\n\n\n\n自定义类型是一种新的数据类型，它是基于已有的类型（如int、string等）创建的，它可以包含多个字段，每个字段都有自己的名称和类型。自定义类型可以用于创建更复杂的数据结构，以满足特定的需求。\n\ntype MyInt int // 相比于类型别名，没有等号\nvar i MyInt\nfmt.Println(\"%T\\n\", i)\n//上面代码输出的结果为xxxx.MyInt\n自定义类型有什么意义？\n可以给数据类型增加方法，使用更加灵活\nfunc (mi MyInt) string() string{\n    return strconv.Itoa(int(mi))\n}\n\nfunc main(){\n    var i MyInt = 10\n    fmt.Println(i.string())\n}\n// 上面的代码给MyInt增加了一个string方法，这样就可以将MyInt类型转换为string类型\n\n\n\n\n\ngo中的结构体借鉴了面向对象的特性和C语言结构体的简洁性\n\n假设要设计一个结构体存储个人信息，包括name、age、address、mobile等，那么可以使用如下方式定义结构体：\ntype Person struct{\n    name string\n    age int\n    address string\n    mobile string\n}\n\nfunc main(){\n    //结构体的初始化方式\n    p1 := Person{\"小明\", 18, \"北京\", \"13812345678\"} //省略写法每个元素都要写\n    p2 := Person{name: \"小红\", age: 19, address: \"上海\", mobile: \"13812345679\"} //能够填部分元素，更灵活\n    var p3 Person\n    p3.name = \"小刚\"\n\n    var persons []Person\n    persons = append(persons, p1)\n    persons = append(persons, Person{\"小刚\", 20, \"广州\", \"13812345680\"})\n}\n\n\n\n\n定义临时的一次性的结构体\n\naddress := struct{\n    province string\n    city string\n    district string\n}{\n    \"北京\",\n     \"北京\", \n     \"海淀区\"\n}\nfmt.Println(address.city)\n\n\n\n\n结构体可以在一个结构体中嵌套另一个结构体\n\ntype Person struct{\n    name string\n    age int\n}\n// 可以不用重复定义\ntype Student struct{\n    // 第一种嵌套方式\n    p Person\n    score float32\n}\n\nfunc main() {\n    // 第一种初始化方式\n    s := Student{\n        p: Person{\n            name: \"小明\",\n            age: 18,\n        },\n        score: 90,\n    }\n    fmt.Println(s.p.name)\n\n    // 第二种初始化方式\n    s := Student{}\n    s.p.name = \"小明\"\n}\n匿名嵌套\ntype Person struct{\n    name string\n    age int\n}\n// 可以不用重复定义\ntype Student struct{\n    // 第二种嵌套方式--匿名嵌套\n    Person\n    score float32\n}\n\nfunc main() {\n    // 初始化方式\n    s.name = \"小明\"\n}\n\n\n\n\n给结构体定义一个方法\n在go中定义结构体的方法是在结构体外进行定义的\n\ntype Person struct{\n    name string\n    age int\n}\n\nfunc (p Person) print(){\n    fmt.Printf(\"姓名：%s， 年龄：%d\\r\\n\", p.name, p.age)\n}\n\nfunc main() {\n    p := Person{\n        name: \"小明\",\n        age: 18,\n    }\n    p.print()\n}\n想要在结构体方法中修改结构体的属性，需要使用指针类型的结构体\ntype Person struct{\n    name string\n    age int\n}\n\nfunc (p *Person) print(){\n    p.age = 19\n    fmt.Printf(\"姓名：%s， 年龄：%d\\r\\n\", p.name, p.age)\n}\n\nfunc main() {\n    p := Person{\n        name: \"小明\",\n        age: 18,\n    }\n    p.print()\n}\n//此时输出的结果为：姓名：小明， 年龄：19"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（9）.html#type关键字",
    "href": "content/learning-notes/golang/entries/golang学习记录（9）.html#type关键字",
    "title": "golang学习记录（9）",
    "section": "",
    "text": "type关键字常用于\n定义结构体\n定义接口\n定义类型别名\n类型定义\n类型判断\n\n\n\n\n别名可以让使用者更好理解代码，提高代码的可读性和可维护性，在编译的时候，会将别名编译为原来的类型\n\n//以定义int的别名举例\ntype MyInt = int\nvar i MyInt\nfmt.Println(\"%T\\n\", i)\n//上面代码输出的结果为int，相当一给int取了一个小名，MyInt本质上还是int\n\n\n\n\n自定义类型是一种新的数据类型，它是基于已有的类型（如int、string等）创建的，它可以包含多个字段，每个字段都有自己的名称和类型。自定义类型可以用于创建更复杂的数据结构，以满足特定的需求。\n\ntype MyInt int // 相比于类型别名，没有等号\nvar i MyInt\nfmt.Println(\"%T\\n\", i)\n//上面代码输出的结果为xxxx.MyInt\n自定义类型有什么意义？\n可以给数据类型增加方法，使用更加灵活\nfunc (mi MyInt) string() string{\n    return strconv.Itoa(int(mi))\n}\n\nfunc main(){\n    var i MyInt = 10\n    fmt.Println(i.string())\n}\n// 上面的代码给MyInt增加了一个string方法，这样就可以将MyInt类型转换为string类型"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（9）.html#结构体的定义和初始化",
    "href": "content/learning-notes/golang/entries/golang学习记录（9）.html#结构体的定义和初始化",
    "title": "golang学习记录（9）",
    "section": "",
    "text": "go中的结构体借鉴了面向对象的特性和C语言结构体的简洁性\n\n假设要设计一个结构体存储个人信息，包括name、age、address、mobile等，那么可以使用如下方式定义结构体：\ntype Person struct{\n    name string\n    age int\n    address string\n    mobile string\n}\n\nfunc main(){\n    //结构体的初始化方式\n    p1 := Person{\"小明\", 18, \"北京\", \"13812345678\"} //省略写法每个元素都要写\n    p2 := Person{name: \"小红\", age: 19, address: \"上海\", mobile: \"13812345679\"} //能够填部分元素，更灵活\n    var p3 Person\n    p3.name = \"小刚\"\n\n    var persons []Person\n    persons = append(persons, p1)\n    persons = append(persons, Person{\"小刚\", 20, \"广州\", \"13812345680\"})\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（9）.html#匿名结构体",
    "href": "content/learning-notes/golang/entries/golang学习记录（9）.html#匿名结构体",
    "title": "golang学习记录（9）",
    "section": "",
    "text": "定义临时的一次性的结构体\n\naddress := struct{\n    province string\n    city string\n    district string\n}{\n    \"北京\",\n     \"北京\", \n     \"海淀区\"\n}\nfmt.Println(address.city)"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（9）.html#结构体嵌套",
    "href": "content/learning-notes/golang/entries/golang学习记录（9）.html#结构体嵌套",
    "title": "golang学习记录（9）",
    "section": "",
    "text": "结构体可以在一个结构体中嵌套另一个结构体\n\ntype Person struct{\n    name string\n    age int\n}\n// 可以不用重复定义\ntype Student struct{\n    // 第一种嵌套方式\n    p Person\n    score float32\n}\n\nfunc main() {\n    // 第一种初始化方式\n    s := Student{\n        p: Person{\n            name: \"小明\",\n            age: 18,\n        },\n        score: 90,\n    }\n    fmt.Println(s.p.name)\n\n    // 第二种初始化方式\n    s := Student{}\n    s.p.name = \"小明\"\n}\n匿名嵌套\ntype Person struct{\n    name string\n    age int\n}\n// 可以不用重复定义\ntype Student struct{\n    // 第二种嵌套方式--匿名嵌套\n    Person\n    score float32\n}\n\nfunc main() {\n    // 初始化方式\n    s.name = \"小明\"\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（9）.html#结构体-定义-方法",
    "href": "content/learning-notes/golang/entries/golang学习记录（9）.html#结构体-定义-方法",
    "title": "golang学习记录（9）",
    "section": "",
    "text": "给结构体定义一个方法\n在go中定义结构体的方法是在结构体外进行定义的\n\ntype Person struct{\n    name string\n    age int\n}\n\nfunc (p Person) print(){\n    fmt.Printf(\"姓名：%s， 年龄：%d\\r\\n\", p.name, p.age)\n}\n\nfunc main() {\n    p := Person{\n        name: \"小明\",\n        age: 18,\n    }\n    p.print()\n}\n想要在结构体方法中修改结构体的属性，需要使用指针类型的结构体\ntype Person struct{\n    name string\n    age int\n}\n\nfunc (p *Person) print(){\n    p.age = 19\n    fmt.Printf(\"姓名：%s， 年龄：%d\\r\\n\", p.name, p.age)\n}\n\nfunc main() {\n    p := Person{\n        name: \"小明\",\n        age: 18,\n    }\n    p.print()\n}\n//此时输出的结果为：姓名：小明， 年龄：19"
  },
  {
    "objectID": "content/learning-notes/infrastructure/entries/Consul.html",
    "href": "content/learning-notes/infrastructure/entries/Consul.html",
    "title": "Consul",
    "section": "",
    "text": "Consul 是 HashiCorp 开发的一款基于 Go 语言的开源基础设施，旨在为微服务架构提供一站式的服务治理能力。"
  },
  {
    "objectID": "content/learning-notes/infrastructure/entries/Consul.html#简介",
    "href": "content/learning-notes/infrastructure/entries/Consul.html#简介",
    "title": "Consul",
    "section": "简介",
    "text": "简介\nConsul 是 HashiCorp 开发的一款基于 Go 语言的开源基础设施，旨在为微服务架构提供一站式的服务治理能力：它通过服务发现机制实现了服务实例的自动注册与动态查找（DNS/HTTP），并结合实时的健康检查自动隔离故障节点，确保流量的高可用性；同时，它内置了分布式的 Key/Value 存储，可直接作为动态配置中心使用；此外，其原生支持的多数据中心架构，使其能够轻松打通跨机房或跨云环境的服务连接，是云原生生态中极具竞争力的基础设施组件。"
  },
  {
    "objectID": "content/learning-notes/infrastructure/entries/Consul.html#安装和启动",
    "href": "content/learning-notes/infrastructure/entries/Consul.html#安装和启动",
    "title": "Consul",
    "section": "安装和启动",
    "text": "安装和启动\n我在使用的时候选择通过docker安装和启动，下面是相关的指令\n# 安装\ndocker pull hashicorp/consul:latest\n\n# 启动\ndocker run -d \\\n  --name=dev-consul \\\n  -p 8500:8500 \\\n  hashicorp/consul:latest agent -dev -client=0.0.0.0\n\n之后在localhost:8500就可以进行访问"
  },
  {
    "objectID": "content/learning-notes/infrastructure/entries/Consul.html#在golang中使用consul",
    "href": "content/learning-notes/infrastructure/entries/Consul.html#在golang中使用consul",
    "title": "Consul",
    "section": "在golang中使用consul",
    "text": "在golang中使用consul\n官方提供相应的接口和库供开发人员调用: Hashicorp/consul\nimport \"github.com/hashicorp/consul/api\""
  },
  {
    "objectID": "content/learning-notes/infrastructure/entries/Consul.html#参考文献",
    "href": "content/learning-notes/infrastructure/entries/Consul.html#参考文献",
    "title": "Consul",
    "section": "参考文献",
    "text": "参考文献"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/Kratos.html",
    "href": "content/learning-notes/microservices/entries/Kratos.html",
    "title": "Kratos 微服务框架",
    "section": "",
    "text": "Kratos: An elegant toolkit for Go microservices.\nKratos是一个基于golang实现的面向微服务的治理框架，它提供了便捷的功能，帮助你从零开始快速构建一个可靠的应用。\n他是 B 站开源的一个 golang 微服务框架，也是主流的微服务框架之一。\n名字来源于:《战神》游戏以希腊神话为背景，讲述奎托斯（Kratos）由凡人成为战神并展开弑神屠杀的冒险经历。"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/Kratos.html#简介",
    "href": "content/learning-notes/microservices/entries/Kratos.html#简介",
    "title": "Kratos 微服务框架",
    "section": "简介",
    "text": "简介\n项目地址\n文档地址"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/Kratos.html#安装和简单使用",
    "href": "content/learning-notes/microservices/entries/Kratos.html#安装和简单使用",
    "title": "Kratos 微服务框架",
    "section": "安装和简单使用",
    "text": "安装和简单使用\n\n安装\n安装前置\n\ngo\nprotoc\nprotoc-gen-go\n\n安装指令\ngo install github.com/go-kratos/kratos/cmd/kratos/v2@latest\nkratos upgrade\ngo install github.com/google/wire/cmd/wire@latest\n安装之后查看相关操作\n(base) ➜  GoFramwork git:(main) kratos -h     \nKratos: An elegant toolkit for Go microservices.\n\nUsage:\n  kratos [command]\n\nAvailable Commands:\n  changelog   生成 Kratos 变更 log\n  completion  为指定的Shell生成自动补全脚本\n  help        帮助指令\n  new         生成一个服务模板\n  proto       生成 proto 文件\n  run         运行项目\n  upgrade     升级 Kratos 工具\n\nFlags:\n  -h, --help      help for kratos\n  -v, --version   version for kratos\n\nUse \"kratos [command] --help\" for more information about a command.\n\n\nDemo\n根据官方的提示创建一个Kratos HelloWord\n首先使用 new 创建项目\nkratos new helloworld\nnew 完成后我们发现可以选择不同的模板，这里我们选择第一个service\n\n等待生成完成，这是生成的项目结构\n.\n├── api  # API 定义层 (Protocol Buffers)\n│   └── helloworld\n│       └── v1\n│           ├── error_reason.pb.go   # [生成] 错误原因的 Go 代码\n│           ├── error_reason.proto   # 定义业务错误原因 (Enum)\n│           ├── greeter_grpc.pb.go   # [生成] gRPC 服务端和客户端代码\n│           ├── greeter_http.pb.go   # [生成] Kratos HTTP 服务代码 (路由、编解码)\n│           ├── greeter.pb.go        # [生成] 请求/响应消息的 Go 结构体\n│           └── greeter.proto        # 定义服务接口 (RPC) 和消息结构 (Message)\n├── cmd  # 程序入口 (Entry Point)\n│   └── helloworld\n│       ├── main.go      # 主程序入口：负责初始化资源、依赖注入、启动服务、监听退出信号\n│       ├── wire_gen.go  # [生成] Wire 依赖注入生成的具体代码 (不要手动修改)\n│       └── wire.go      # Wire 依赖注入的声明文件，定义 ProviderSet\n├── configs  # 配置文件\n│   └── config.yaml      # 具体的配置内容 (如数据库地址、端口、日志级别等)\n├── Dockerfile           # 容器化构建脚本\n├── go.mod               # Go 模块依赖定义\n├── go.sum               # Go 模块依赖校验和\n├── internal  # 内部业务逻辑 (Go 规范：外部项目无法 import 此目录内容)\n│   ├── biz   # [业务逻辑层 / 领域层] (Domain Layer)\n│   │   ├── biz.go       # 定义 biz 层的 ProviderSet\n│   │   ├── greeter.go   # 定义领域对象 (Entity) 和 业务接口 (Repo Interface)，不依赖具体实现\n│   │   └── README.md\n│   ├── conf  # [配置定义层]\n│   │   ├── conf.pb.go   # [生成] 配置文件的 Go 结构体\n│   │   └── conf.proto   # 定义配置文件的结构 (将 YAML 映射为强类型 struct)\n│   ├── data  # [数据访问层 / 基础设施层] (Infrastructure Layer)\n│   │   ├── data.go      # 初始化数据库/Redis 连接，定义 data 层的 ProviderSet\n│   │   ├── greeter.go   # 实现 biz 层定义的 Repo 接口 (数据库 CRUD、缓存、RPC 调用)\n│   │   └── README.md\n│   ├── server # [服务实例层]\n│   │   ├── grpc.go      # 初始化 gRPC Server\n│   │   ├── http.go      # 初始化 HTTP Server\n│   │   └── server.go    # 定义 server 层的 ProviderSet\n│   └── service # [应用服务层] (Application Layer)\n│       ├── greeter.go   # 实现 api 定义的 protobuf 接口，负责 DTO -&gt; DO 转换，编排 biz 逻辑\n│       ├── README.md\n│       └── service.go   # 定义 service 层的 ProviderSet\n├── LICENSE              # 许可证文件\n├── Makefile             # 项目管理脚本 (生成 API、编译、运行、测试等命令)\n├── openapi.yaml         # [生成] OpenAPI/Swagger 接口文档\n├── README.md            # 项目说明文档\n└── third_party  # 第三方依赖的 Proto 文件 (用于生成代码)\n    ├── errors           # Kratos 错误模型定义\n    │   └── errors.proto\n    ├── google           # Google 官方 Proto (API 注解、HTTP 映射、通用类型等)\n    │   ├── api\n    │   │   ├── ...\n    │   └── protobuf\n    │       ├── ...\n    ├── openapi          # OpenAPI 生成相关的 Proto 定义\n    │   └── v3\n    │       ├── ...\n    ├── README.md\n    └── validate         # 参数校验规则 Proto 定义\n        ├── README.md\n        └── validate.proto\n之后我们进入目录，运行依赖下载指令\ncd helloworld\ngo mod download\n我们也可以自己编写proto源码、wire等等，通过 Kratos 生成相应的代码\ngo generate ./...\n然后是运行项目\nkratos run"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/Kratos.html#参考资料",
    "href": "content/learning-notes/microservices/entries/Kratos.html#参考资料",
    "title": "Kratos 微服务框架",
    "section": "参考资料",
    "text": "参考资料\nKratos\nKratos 文档"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-kit.html",
    "href": "content/learning-notes/microservices/entries/go-kit.html",
    "title": "Go-Kit 微服务框架",
    "section": "",
    "text": "相关代码的GitHub地址：GoKitAddSrv，不同文件夹代表不同章节，直接go run .可运行\n写得比较简单，能跑就行，一些bug和规范问题见谅！"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-kit.html#简介",
    "href": "content/learning-notes/microservices/entries/go-kit.html#简介",
    "title": "Go-Kit 微服务框架",
    "section": "简介",
    "text": "简介\ngo-kit严格意义上并不算是一个完整的框架，更像是一个工具箱或者库的集合，官方描述它为一组包和最佳实践的集合。\n\n它提供了构建微服务所有的标准组件，并且采用整洁架构和洋葱结构。它不追求开发的速度，而是采用强制三层架构，严格分成业务逻辑层（Service）、作为适配器的端点层（Endpoint）和进行协议处理的传输层（Transport），将业务逻辑和网络通信完全解耦。"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-kit.html#核心结构-三层模型",
    "href": "content/learning-notes/microservices/entries/go-kit.html#核心结构-三层模型",
    "title": "Go-Kit 微服务框架",
    "section": "核心结构-三层模型",
    "text": "核心结构-三层模型\n\n\nTransport\n这是最外层的结构，负责处理具体的网络协议，通常是http和rpc，主要功能就是进行编解码，将外部传来的请求，比如Json解析成Endpoint能够读懂的golang结构体，然后调用Endpoint层，再将从Endpoint层获取的结果进行编码，传输发送给客户端。\n\n\nEndpoint\n这是连接业务和网络的中间一层，它负责将Service层中的各种方法强制封装成一个统一的标准函数签名，然后交给Transport层调用\n// Endpoint定义\ntype Endpoint func(ctx context.Context, request interface{}) (response interface{}, err error)\n在这一层，所有的调用都会被统一抽象成同一种形式，通常在这一层进行中间件的挂载。实现一套中间件能应用于所有的接口。\n\n\nService\n业务逻辑层Service只考虑具体业务逻辑的实现，定义并实现接口即可，不用考虑协议和网络服务。"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-kit.html#demo-实现一个简单加法器",
    "href": "content/learning-notes/microservices/entries/go-kit.html#demo-实现一个简单加法器",
    "title": "Go-Kit 微服务框架",
    "section": "Demo-实现一个简单加法器",
    "text": "Demo-实现一个简单加法器\n\nHTTP\n\n说明\n\n在Service层定义接口，包含两个方法\n\nAdd实现int类型的的加法\nConcat实现string类型的加法\n基本流程就是定义接口，实现接口\n\n在Endpoint层，定义请求和响应数据的结构体，将Service层的方法进行封装\n\n接本流程就是定义结构体，封装方法\n\n在Transport层，进行具体协议处理和响应\n\n实现编解码\n实现Handler\n定义路由和端口\n……\n\n\n\n\n测试\n使用Postman进行测试\n\n\n\n\n\nRPC\n这里使用gRpc\n\n说明\n\n实现proto文件\n\n定义proto文件夹\n在文件夹中编写proto文件，定义service和message\n执行protoc指令，生成golang文件\nprotoc -I=proto --go_out=proto --go_opt=paths=source_relative --go-grpc_out=proto --go-grpc_opt=paths=source_relative proto/addsrv.proto\n\n在Service层定义接口，包含两个方法\n\nAdd实现int类型的的加法\nConcat实现string类型的加法\n基本流程就是定义接口，实现接口\n\n在Endpoint层，定义请求和响应数据的结构体，将Service层的方法进行封装\n\n接本流程就是定义结构体，封装方法\n\n在Transport层，进行具体协议处理和响应\n\n实现rpc编解码\n实现Handler\n实现protobuf接口\n……\n\n\n\n\n测试\n使用Postman进行测试"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-kit.html#项目结构拆分",
    "href": "content/learning-notes/microservices/entries/go-kit.html#项目结构拆分",
    "title": "Go-Kit 微服务框架",
    "section": "项目结构拆分",
    "text": "项目结构拆分\n根据go-kit设计好的三层结构，我们对原本单独的三个文件夹进行分层实现，下面是具体的目录结构"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-kit.html#中间件",
    "href": "content/learning-notes/microservices/entries/go-kit.html#中间件",
    "title": "Go-Kit 微服务框架",
    "section": "中间件",
    "text": "中间件\n\n日志\n\n全局创建日志\n在接口实现的时候传入日志\n定义日志接口，在接口中加入应用接口+日志，然后再实现方法\n\n// go-kit官方设计\ntype logMiddleware struct {\n    logger log.Logger\n    next   AddService\n}\n在项目中加入日志中间件，简单实现示意\n\n\n\n限流\n加入限流中间件，1秒钟只能请求一次\n在实际业务场景中可以针对单个用户进行更加细粒度的限制\n\n在项目中加入限流中间件，简单实现示意\n\n\n\n指标采集\n使用metrics包来记录关于服务运行时行为的统计信息，比如计算已处理作业的数量、记录请求完成后的持续时间以及跟踪正在执行的操作的数量等等。\n在项目中加入指标采集中间件，简单实现示意"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-kit.html#服务调用",
    "href": "content/learning-notes/microservices/entries/go-kit.html#服务调用",
    "title": "Go-Kit 微服务框架",
    "section": "服务调用",
    "text": "服务调用\n通过构建结构体，加入当前服务和被调用服务（被设置为endpoint.Endpoint类型）实现调用\n\n简单实现示意"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-kit.html#服务发现和负载均衡",
    "href": "content/learning-notes/microservices/entries/go-kit.html#服务发现和负载均衡",
    "title": "Go-Kit 微服务框架",
    "section": "服务发现和负载均衡",
    "text": "服务发现和负载均衡\n关于concul的安装和使用可以见：concul\ngo-kit提供服务发现和负载均衡的相应机制\n\nGo kit 提供了工厂函数Factory， 它是一个将实例字符串(例如host:port)转换为特定端点的函数。提供多个端点的实例需要多个工厂函数。工厂函数还返回一个当实例消失并需要清理时调用的io.Closer。\nGo kit 提供了基本的负载均衡器，也可以自己实现。\n重试策略包装负载均衡器，并返回可用的端点。重试策略将重试失败的请求，直到达到最大尝试或超时为止。\n\n// 工厂函数\ntype Factory func(instance string) (endpoint.Endpoint, io.Closer, error)\n\n//  负载均衡\nimport \"github.com/go-kit/kit/sd/lb\"\nbalancer := lb.NewRoundRobin(endpointer)\n\n// 重试\nfunc Retry(max int, timeout time.Duration, lb Balancer) endpoint.Endpoint\nimport \"github.com/go-kit/kit/sd/lb\"\nretry := lb.Retry(3, 500*time.Millisecond, balancer)\n下面是简单实现\n开了两个trim_service分别在两个终端，调用的时候会自动轮询"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-kit.html#参考资料",
    "href": "content/learning-notes/microservices/entries/go-kit.html#参考资料",
    "title": "Go-Kit 微服务框架",
    "section": "参考资料",
    "text": "参考资料\nGo-kit\nGemini老师\nGo kit教程01——基础示例\nGo kit教程02——gRPC\nGo kit教程03——代码分层\nGo kit教程04——中间件和日志\nGo kit教程05——调用其他服务\nGo kit教程06——服务发现和负载均衡"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/protobuf.html",
    "href": "content/learning-notes/microservices/entries/protobuf.html",
    "title": "Protobuf",
    "section": "",
    "text": "Protobuf(Protocal Buffer)，是谷歌开源的一种和语言、平台无关的，能进行扩展的，用于序列化结构化数据的协议\n可用于数据的通信、数据存储，只需要定义一次数据结构，就可以使用生成的源代码，从各种数据流或者语言中写入和读取结构化数据。\nProtobuf用于微服务的通信协议"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/protobuf.html#基本语法",
    "href": "content/learning-notes/microservices/entries/protobuf.html#基本语法",
    "title": "Protobuf",
    "section": "基本语法",
    "text": "基本语法\n\n基本框架\nsyntax = \"proto3\";\n\npackage xxx.xxx;\n\noption gp_package = \"./xxx/xxx/xxx; xxx\";\n\n// 一共有三个部分\n// 第一行是版本声明\n// 第二个是包的声明，防止不同项目同名消息的冲突\n// 第三个手生成文件路径和生成的Go的包名\n\n\n定义服务\n说明\n\nservice表示这是一个服务（接口），关于他的命名规则，考虑到golang中通过首字母的大小写来进行区别私有和公共，所以必须大写，让其他文件能够调用，同时以后缀Service结尾，表示这是一个服务\nrpc，必须写，只能有这一个，表示使用rpc远程过程调用\nstream，流式，用于大文件传输，聊天场景或者打字机效果等等\n\n一问多答，问完之后，回答按照严格顺序返回\n多问一答，严格顺序输入请求，等待一个响应\n多问多答，完全异步的两根管子，互补阻塞\n\n模式1，一问一答，像打乒乓球一样\n模式2，像你和你暧昧对象聊天一样，你发10条，ta会一条，或者反过来都有可能，请求和响应走不通的通道\n这样的话，在golang中需要通过goroutine进行实现\n\n\n\nservice TestService {\n        rpc IndexDocument (IndexRequest) returns (IndexResponse)\n        rpc Chat (ChatRequest) returns (stream ChatReponse) // 一问多答\n        rpc UploadFile (stream FileChunk) returns (UploadStatus) // 多问一答\n        rpc LiveChat (stream VoiceData) returns (stream VoiceData) // 变问边答\n}\n\n\n定义消息\nmessage 相当于 golang中的struct\n基本语法格式：类型 字段名 = 唯一编号;\n下面是一个demo\nmessage IndexRequest {\n        string library_id = 1; // 字符串\n        int32 file_size = 2; // 整数类型int32\n        bytes file_content = 3; // 文件内容使用二进制\n        bool is_public = 4; // 布尔值\n}\n注意事项，唯一编号的的问题，它相当于字段的一个身份认证，在进行RPC的时候为了省流量，不传输原本的变量名，直接传输编号，为了防止编号混乱，上线之后就不要修改已有的编号，正确做法，如果编号废弃之后就空着不要用了，用新的字段值\nmessage和Go类型对比\n\n消息中比较高级的数据结构\n\n数组(slice)\n使用repeated关键字\nmessage ChatResponse {\n        repeated string sources = 1;\n}\n\n\n字典(map)\nmap也就是键值对\n使用map作为关键字\nmessage IndexRequest {\n        // Metadata map[string]string\n        map&lt;string, string&gt; metasata = 2;\n}\n\n\n枚举(enum)\n使用enum作为关键字，枚举必须从0开始，通常是默认值或者是未知值\nenum只能作为message一部分使用，不能进行单独传输\n// 定义枚举 (必须从 0 开始)\nenum DocType {\n  UNKNOWN = 0; // 规范：第一个必须是 0，通常作为默认/未知值\n  PDF = 1;\n  IMAGE = 2;\n  WORD = 3;\n}\n\nmessage Document {\n  string name = 1;\n  DocType type = 2; // 使用上面定义的枚举\n}\n\n\n嵌套消息(nested)\nmessage Author {\n        string name = 1;\n}\n\nmessage Book {\n        string title = 1;\n        Author author = 2;\n}\n\n\n\n\n语法规范\n\n消息名 (Message Name)：使用 大驼峰 (ChatRequest)。\n字段名 (Field Name)：使用 下划线蛇形 (library_id, file_name)。\n\n为什么？ 因为生成的 Go 代码会自动帮你转成驼峰 (LibraryId, FileName)，但在 Proto 文件里看下划线更清晰。\n\n服务名 (Service Name)：使用 大驼峰 (OmniRAGService)。"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/protobuf.html#安装protobuf",
    "href": "content/learning-notes/microservices/entries/protobuf.html#安装protobuf",
    "title": "Protobuf",
    "section": "安装protobuf",
    "text": "安装protobuf\n\nMac安装\n直接通过下面的指令进行安装即可\nbrew install protobuf\n\nprotoc --version\n\n# 1. 安装生成数据结构的插件\ngo install google.golang.org/protobuf/cmd/protoc-gen-go@latest\n\n# 2. 安装生成 gRPC 服务的插件\ngo install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest\n\n\nWin安装\n在 Windows 上安装 Protobuf 和 Go 插件，主要分为 安装编译器核心 (protoc) 和 安装 Go 语言插件 两步。\n由于 Windows 没有像 Homebrew 那样统一的默认包管理器，我们需要手动下载并配置环境变量。请按照以下步骤操作：\n第一步：安装编译器核心 (protoc)\n这是 Google 提供的核心工具，负责读取 .proto 文件。\n\n下载压缩包：\n\n访问 GitHub 发布页：Protocol Buffers Releases\n找到最新版本（例如 v25.x 或更高）。\n在 “Assets” 列表中，下载 protoc-xx.x-win64.zip (注意选 win64)。\n\n解压：\n\n将压缩包解压到一个你不会删除的地方，建议放在 C:。\n解压后，你应该能看到 bin 文件夹，里面有一个 protoc.exe。\n\n配置环境变量 (Path) —— 最关键的一步：\n\n按 Win 键，搜索 “编辑系统环境变量” 并打开。\n点击右下角的 “环境变量” 按钮。\n在下方的 “系统变量” 区域，找到 Path​，选中它，点击 “编辑”。\n点击右侧的 “新建”。\n输入你刚才解压的 bin 目录路径，例如：C:。\n一路点击 “确定” 保存。\n\n验证：\n\n打开一个新的 CMD 或 PowerShell 窗口。\n输入：protoc –version\n如果显示版本号（如 libprotoc 25.1​），说明核心安装成功！\n\n\n第二步：安装 Go 语言插件\n你需要安装两个 Go 插件，这样 protoc 才能生成 Go 代码。\n\n打开 PowerShell 或 CMD，执行以下两条命令：\n\n# 1. 安装生成数据结构的插件\ngo install google.golang.org/protobuf/cmd/protoc-gen-go@latest\n\n# 2. 安装生成 gRPC 服务的插件\ngo install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest\n\n检查 Go 的环境变量：\n\ngo install 会把插件下载到你的 $GOPATH/bin 目录下（通常是 C:​）。\n你需要确保这个路径也在你的 系统环境变量 Path 里。\n验证方法：在终端输入 protoc-gen-go –version。\n\n如果报错“不是内部或外部命令”，请重复“第一步”中的配置环境变量步骤，把 %USERPROFILE%(即你的 go bin 目录) 加到 Path 里。"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/protobuf.html#protobuf使用",
    "href": "content/learning-notes/microservices/entries/protobuf.html#protobuf使用",
    "title": "Protobuf",
    "section": "protobuf使用",
    "text": "protobuf使用\n\n使用示例\nprotoc --proto_path=. \\\n       --go_out=paths=source_relative:. \\\n       --go-grpc_out=paths=source_relative:. \\\n       api/omnirag/v1/omnirag.proto\n\n\n使用说明\n\n--proto_path=.: 告诉编译器，从当前目录（根目录）开始寻找 import 的文件。\n--go_out=paths=source_relative:.:\n\n生成 .pb.go 文件（数据结构）。\npaths=source_relative: 表示生成的文件路径与 proto 文件同级（即生成在 api/omnirag/v1/ 下），而不是按照包名乱跑。\n:.: 输出到当前目录。\n\n--go-grpc_out=paths=source_relative:.:\n\n生成 _grpc.pb.go 文件（服务接口）。\n配置同上。\n\napi/omnirag/v1/omnirag.proto: 目标文件的路径。"
  },
  {
    "objectID": "content/projects/entries/Daily-Log-Maker.html",
    "href": "content/projects/entries/Daily-Log-Maker.html",
    "title": "Daily Log Maker",
    "section": "",
    "text": "一个开箱即用的轻量级网页工具，帮助你把每日复盘、待办、工作/学习总结，快速排版成精致的长图海报并保存为高清 PNG。\n\n\n\n可视化编辑：左侧面板实时修改日期、主标题、每日一句，右侧画布同步预览。\n文本格式化工具栏：支持加粗、项目符号列表、五色高亮标记、灰底块、红色删除线等。\n主题卡片：选择主题色、输入 Emoji 与模块标题，一键添加到画布，内容可直接编辑。\n高清长图导出：解决内容超出屏幕被截断的问题，生成完整、透明背景的高清 PNG。\n零依赖运行：双击 HTML 即用；通过 CDN 自动加载 html2canvas 与字体资源。\n\n\n\n\n\n用任意现代浏览器（推荐 Chrome/Edge）打开项目根目录中的 Daily Log Maker.html。\n在左侧面板填写：日期、主标题、每日一句；内容会实时展示在右侧画布。\n添加模块：\n\n选择一个主题色；\n输入 Emoji 与模块标题；\n点击“+ 添加到画布”；在卡片正文中直接编辑内容，支持格式化。\n\n点击左侧的“保存图片”按钮，自动生成并下载长图（文件名形如 每日记录_Long_YYYY.MM.DD.png）。\n\n\n\n\n\n选中文本后再点击工具栏按钮，可应用加粗/高亮/删除线等格式。\n列表支持快捷输入：在正文中输入多行文本后，点击“列表”按钮即可批量转为项目符号。\n画布右上角的“✕”只会删除对应卡片，不影响其他内容。\n导出为透明背景的 PNG，适合拼接到社交平台或文档中。\n\n\n\n\n\n截图实现：通过 html2canvas（CDN 引入）对画布节点进行截图，采用“克隆节点 + 自然撑高”的方式，确保超长内容完整保留并避免阴影等干扰。\n清晰度：截图时设置 scale = 2.5，在常见屏幕下可获得良好清晰度与文件大小平衡。\n内容编辑：模块正文使用 contenteditable，配合基础命令实现常见富文本操作。\n\n\n\n\n如果需要完全离线： - 将 html2canvas 的 CDN 改为本地文件，并把 Google Fonts 替换为系统字体或本地字体文件； - 保持页面结构不变即可使用导出功能。\n\n\n\n\n推荐使用最新版 Chrome/Edge/Firefox。\n在极端超长内容下，截图耗时与内存占用会增加；如遇问题，可尝试降低 scale 值或分段导出。"
  },
  {
    "objectID": "content/projects/entries/Daily-Log-Maker.html#功能亮点",
    "href": "content/projects/entries/Daily-Log-Maker.html#功能亮点",
    "title": "Daily Log Maker",
    "section": "",
    "text": "可视化编辑：左侧面板实时修改日期、主标题、每日一句，右侧画布同步预览。\n文本格式化工具栏：支持加粗、项目符号列表、五色高亮标记、灰底块、红色删除线等。\n主题卡片：选择主题色、输入 Emoji 与模块标题，一键添加到画布，内容可直接编辑。\n高清长图导出：解决内容超出屏幕被截断的问题，生成完整、透明背景的高清 PNG。\n零依赖运行：双击 HTML 即用；通过 CDN 自动加载 html2canvas 与字体资源。"
  },
  {
    "objectID": "content/projects/entries/Daily-Log-Maker.html#快速开始",
    "href": "content/projects/entries/Daily-Log-Maker.html#快速开始",
    "title": "Daily Log Maker",
    "section": "",
    "text": "用任意现代浏览器（推荐 Chrome/Edge）打开项目根目录中的 Daily Log Maker.html。\n在左侧面板填写：日期、主标题、每日一句；内容会实时展示在右侧画布。\n添加模块：\n\n选择一个主题色；\n输入 Emoji 与模块标题；\n点击“+ 添加到画布”；在卡片正文中直接编辑内容，支持格式化。\n\n点击左侧的“保存图片”按钮，自动生成并下载长图（文件名形如 每日记录_Long_YYYY.MM.DD.png）。"
  },
  {
    "objectID": "content/projects/entries/Daily-Log-Maker.html#使用技巧",
    "href": "content/projects/entries/Daily-Log-Maker.html#使用技巧",
    "title": "Daily Log Maker",
    "section": "",
    "text": "选中文本后再点击工具栏按钮，可应用加粗/高亮/删除线等格式。\n列表支持快捷输入：在正文中输入多行文本后，点击“列表”按钮即可批量转为项目符号。\n画布右上角的“✕”只会删除对应卡片，不影响其他内容。\n导出为透明背景的 PNG，适合拼接到社交平台或文档中。"
  },
  {
    "objectID": "content/projects/entries/Daily-Log-Maker.html#技术说明",
    "href": "content/projects/entries/Daily-Log-Maker.html#技术说明",
    "title": "Daily Log Maker",
    "section": "",
    "text": "截图实现：通过 html2canvas（CDN 引入）对画布节点进行截图，采用“克隆节点 + 自然撑高”的方式，确保超长内容完整保留并避免阴影等干扰。\n清晰度：截图时设置 scale = 2.5，在常见屏幕下可获得良好清晰度与文件大小平衡。\n内容编辑：模块正文使用 contenteditable，配合基础命令实现常见富文本操作。"
  },
  {
    "objectID": "content/projects/entries/Daily-Log-Maker.html#离线使用",
    "href": "content/projects/entries/Daily-Log-Maker.html#离线使用",
    "title": "Daily Log Maker",
    "section": "",
    "text": "如果需要完全离线： - 将 html2canvas 的 CDN 改为本地文件，并把 Google Fonts 替换为系统字体或本地字体文件； - 保持页面结构不变即可使用导出功能。"
  },
  {
    "objectID": "content/projects/entries/Daily-Log-Maker.html#浏览器兼容",
    "href": "content/projects/entries/Daily-Log-Maker.html#浏览器兼容",
    "title": "Daily Log Maker",
    "section": "",
    "text": "推荐使用最新版 Chrome/Edge/Firefox。\n在极端超长内容下，截图耗时与内存占用会增加；如遇问题，可尝试降低 scale 值或分段导出。"
  },
  {
    "objectID": "content/projects/entries/Go-Zero-Service-Demo.html#项目设计",
    "href": "content/projects/entries/Go-Zero-Service-Demo.html#项目设计",
    "title": "go-zero-demo",
    "section": "项目设计",
    "text": "项目设计\n\n说明\n项目是通过 zo-zero 框架实现一个简单的用户订单系统，包括两个微服务用户服务和订单服务，通过 API 接口能够分别调用两个服务的接口，用户服务暴露 RPC 服务接口供订单服务进行调用。下面截图是我的操作过程\n\n\n\n\nAPI\ngoctl指令\ngoctl api go -api user.api -dir . -style goZero  \ngoctl api go -api order.api -dir . -style goZero\nUser\nsyntax = \"v1\"\n\n// 进行项目的简单说明\ninfo (\n    title:   \"实现简单的用户服务\"\n    author:  \"aorangehc\"\n    date:    \"2025年 11 月 11 日\"\n    version: \"v1\"\n)\n\n// 注册需要用户名、密码、手机号码，要做唯一性检测\ntype RegisterReq {\n    UserName   string `json:\"username\"`\n    Password   string `json:\"password\"`\n    Repassword string `json:\"re_password\"`\n    Mobile     string `json:\"mobile\"`\n    Gender     int    `json:\"gender,options=0|1|2,default=0\"` // male|female|unknown\n    NickName   string `json:\"nickname\"`\n}\n\ntype RegisterResp {\n    success bool   `json:\"success\"` // 注册是否成功\n    Message string `json:\"message\"` // 注册报错信息\n    Id      int64  `json:\"id\"` // 成功注册返回的 id\n}\n\ntype LoginReq {\n    UserName string `json:\"username\"`\n    Password string `json:\"password\"`\n}\n\ntype LoginResp {\n    Message      string `json:\"message\"`\n    AccessToken  string `json:\"accessToken\"`\n    AccessExpire int64  `json:\"accessExpire\"`\n    RefreshAfter int64  `json:\"refreshAfter\"`\n}\n\ntype UserInfoReq {\n    Id int64 `json:\"id\"`\n}\n\ntype UserInfoResp {\n    Id       int64  `json:\"id\"`\n    Token    string `json:\"token\"`\n    UserName string `json:\"username\"`\n    Mobile   string `json:\"mobile\"`\n    Gender   int    `json:\"gender,options=0|1|2,default=0\"` // male|female|unknown\n    NickName string `json:\"nickname\"`\n    CreateAt string `json:\"createAt\"` // 注册时间\n    UpdateAt string `json:\"updateAt\"` // 最后更新时间\n}\n\n// 用户信息更新\ntype UserUpdateReq {\n    Id       int64  `json:\"id\"`\n    UserName string `json:\"username\"`\n    Password string `json:\"password\"`\n    Mobile   string `json:\"mobile\"`\n    Gender   int    `json:\"gender,options=0|1|2,default=0\"` // male|female|unknown\n    NickName string `json:\"nickname\"`\n}\n\ntype UserUpdateResp {\n    success bool   `json:\"success\"`\n    Message string `json:\"message\"` // 更新报错信息\n}\n\n// 定义用户服务的 Api\n@server (\n    prefix: api\n)\nservice user-api {\n    @handler register\n    post /user/register (RegisterReq) returns (RegisterResp)\n\n    @handler login\n    post /user/login (LoginReq) returns (LoginResp)\n}\n\n@server (\n    prefix: api\n    jwt:    Auth\n)\nservice user-api {\n    @handler userInfo // 获取用户信息\n    get /user/:id (UserInfoReq) returns (UserInfoResp)\n}\nOrder\nsyntax = \"v1\"\n\ninfo (\n    title:   \"订单服务简单 demo\"\n    author:  \"aorangehc\"\n    date:    \"2025年 11 月 11 日\"\n    version: \"v1\"\n)\n\n// 创建订单\ntype CreateReq {\n    UserId  int64 `json:\"userId\"`\n    GoodsId int64 `json:\"goodsId\"`\n    Num     int64 `json:\"num\"`\n    Amount  int64 `json:\"amount\"`\n}\n\ntype CreateResp {\n    OrderSn string `json:\"orderSn\"`\n}\n\n// 查看订单详情\ntype DetailReq {\n    OrderSn string `json:\"orderSn\"`\n}\n\ntype DetailResp {\n    OrderSn  string `json:\"orderSn\"`\n    UserId   int64  `json:\"userId\"`\n    GoodsId  int64  `json:\"goodsid\"`\n    Num      int64  `json:\"num\"`\n    Amount   int64  `json:\"amount\"`\n    Status   int64  `json:\"status\"`\n    CreateAt string `json:\"createAt\"`\n}\n\n// 删除订单\ntype DeleteReq {\n    userId  int64  `json:\"userId\"`\n    OrderSn string `json:\"orderSn\"`\n}\n\ntype DeleteResp {\n    success bool   `json:\"success\"`\n    Message string `json:\"message\"`\n}\n\nservice order-api {\n    @handler create\n    post /api/order/create (CreateReq) returns (CreateResp)\n\n    @handler detail\n    get /api/order/:orderSn (DetailReq) returns (DetailResp)\n\n    @handler delete\n    delete /api/order/delete (DeleteReq) returns (DeleteResp)\n}\n\n\nRPC\ngoctl指令\ngoctl rpc protoc user.proto --go_out=. --go-grpc_out=. --zrpc_out=.\nUser\n// 暴露一个 user 服务对外接口，获取用户信息\n\nsyntax = \"proto3\";\n\noption go_package = \"./user\";\n\n// 定义请求结构体\nmessage GetUserInfoRequest {\n    int64 user_id = 1; // 用户ID\n}\n\n// 定义响应结构体\nmessage GetUserInfoResponse {\n    int64 user_id = 1; // 用户ID\n    string user_name = 2; // 用户名\n    int64 gender = 3; // 用户性别\n}\n\n// 定义 UserService 服务\nservice UserService {\n    // 获取用户信息\n    rpc GetUserInfo(GetUserInfoRequest) returns (GetUserInfoResponse); \n}\n\n\nMySQL\ngoctl指令\ngoctl model mysql ddl -src=\"./user.sql\" -dir=\"./sql/model\"\ngoctl model mysql ddl -src=\"./order.sql\" --dir=\"./sql/model\"\nUser\nCREATE TABLE user (\n    id bigint AUTO_INCREMENT,\n    name varchar(255) NULL COMMENT '用户名',\n    password varchar(255) NOT NULL DEFAULT '' COMMENT '密码',\n    mobile varchar(255) NOT NULL DEFAULT '' COMMENT '手机号码',\n    gender char(10) NOT NULL DEFAULT 'male' COMMENT '性别,male|female|unknown',\n    nickname varchar(255) NULL DEFAULT '' COMMENT '昵称',\n    type tinyint(1) NULL DEFAULT 0 COMMENT '用户类型, 0:普通用户,1:VIP用户,用于测试golang关键字',\n    create_at timestamp NULL,\n    update_at timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    UNIQUE mobile_index (mobile),\n    UNIQUE name_index (name),\n    PRIMARY KEY (id)\n) ENGINE = InnoDB COLLATE utf8mb4_general_ci COMMENT '用户表';\nOrder\nCREATE TABLE `order` (\n    `order_sn` VARCHAR(64) NOT NULL COMMENT '订单号',\n    `user_id` BIGINT NOT NULL DEFAULT 0 COMMENT '用户ID',\n    `goods_id` BIGINT NOT NULL DEFAULT 0 COMMENT '商品ID',\n    `num` BIGINT NOT NULL DEFAULT 0 COMMENT '数量',\n    `amount` BIGINT NOT NULL DEFAULT 0 COMMENT '金额',\n    `status` INT NOT NULL DEFAULT 0 COMMENT '状态',\n    `create_at` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    `delete_at` DATETIME DEFAULT NULL COMMENT '删除时间',\n    PRIMARY KEY (`order_sn`)\n) ENGINE=InnoDB COLLATE utf8mb4_general_ci COMMENT='订单表';"
  },
  {
    "objectID": "content/projects/entries/Go-Zero-Service-Demo.html#mysql配置和model操作",
    "href": "content/projects/entries/Go-Zero-Service-Demo.html#mysql配置和model操作",
    "title": "go-zero-demo",
    "section": "MySQL配置和model操作",
    "text": "MySQL配置和model操作\n已经完成了项目结构的初步搭建，下一步我们进行数据库的配置，这里我们从头开始，使用 docker 创建表。下面是相关的指令。\n\n创建 MySQL 数据库和表\n# 使用 docker 拉取 docekr 的镜像\ndocker pull mysql:8.0 \n\n# 使用镜像创建容器\ndocker run -d --name testMySQl \\ # 容器名称\n  -e MYSQL_ROOT_PASSWORD=123456 \\ # 数据库密码\n  -e MYSQL_DATABASE=goframework \\ # 数据库名称\n  -p 3307:3306 \\ # 容器内 3306 端口映射到 3307，因为我的 3306 被占用了\n  -v $PWD/mysql-data:/var/lib/mysql \\ # 将存储映射到外部\n  mysql:8.0 --default-authentication-plugin=mysql_native_password\n\n# 进入容器\ndocker exec -it testMySQl /bin/sh\n\n# 进入数据库\nmysql -uroot -p123456\n\n# 看一下已有的数据库\nshow databases;\n\n# 创建一个数据库\ncreate database user_order;\n\n# 使用数据库\nuse user_order;;\n\n# 看一下表\nshow tables;\n\n# 创建一个用户表\nCREATE TABLE `user` (\n    id bigint AUTO_INCREMENT,\n    name varchar(255) NULL COMMENT '用户名',\n    password varchar(255) NOT NULL DEFAULT '' COMMENT '密码',\n    mobile varchar(255) NOT NULL DEFAULT '' COMMENT '手机号码',\n    gender char(10) NOT NULL DEFAULT 'male' COMMENT '性别,male|female|unknown',\n    nickname varchar(255) NULL DEFAULT '' COMMENT '昵称',\n    type tinyint(1) NULL DEFAULT 0 COMMENT '用户类型, 0:普通用户,1:VIP用户,用于测试golang关键字',\n    create_at timestamp NULL,\n    update_at timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n    UNIQUE mobile_index (mobile),\n    UNIQUE name_index (name),\n    PRIMARY KEY (id)\n) ENGINE = InnoDB COLLATE utf8mb4_general_ci COMMENT '用户表';\n\n# 创建订单表\nCREATE TABLE `order` (\n    `order_sn` VARCHAR(64) NOT NULL COMMENT '订单号',\n    `user_id` BIGINT NOT NULL DEFAULT 0 COMMENT '用户ID',\n    `goods_id` BIGINT NOT NULL DEFAULT 0 COMMENT '商品ID',\n    `num` BIGINT NOT NULL DEFAULT 0 COMMENT '数量',\n    `amount` BIGINT NOT NULL DEFAULT 0 COMMENT '金额',\n    `status` INT NOT NULL DEFAULT 0 COMMENT '状态',\n    `create_at` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    `delete_at` DATETIME DEFAULT NULL COMMENT '删除时间',\n    PRIMARY KEY (`order_sn`)\n) ENGINE=InnoDB COLLATE utf8mb4_general_ci COMMENT='订单表';\n\n\n\n项目连接数据库\n\n先修改配置文件，在配置中增加数据库相关配置\n\nroot:123456@tcp(127.0.0.1:3307)/user_order?charset=utf8mb4&parseTime=True&loc=Local\n├─┘└──┘└┘└────┘└──┘└─────┘└───────┘└───────┘└────┘\n 用户名 密码  协议    主机地址    端口   数据库名    字符集        时间解析     时区\n\n然后修改 yaml文件中的配置信息，写入具体配置\n在 servicecontext 中增加数据库相关配置，并连接数据库表\n在注册逻辑中进行实现，增加数据写入逻辑\n\n之后进行测试，数据写入"
  },
  {
    "objectID": "content/projects/entries/Go-Zero-Service-Demo.html#注册",
    "href": "content/projects/entries/Go-Zero-Service-Demo.html#注册",
    "title": "go-zero-demo",
    "section": "注册",
    "text": "注册\n之前我们实现了简单的数据库操作，现在开始我们实现一个简单的注册功能\n\n参数校验（校验参数合法性，判断一下是不是空，还有两次密码认证—）\n数据唯一性确认（检查数据库中是否存在已有数据）\n加密加盐（使用 md5 进行加密加盐）\n\n// 加密加盐\n    h := md5.New()\n    h.Write([]byte(req.Password))\n    h.Write(secret)\n    passwordStr := hex.EncodeToString(h.Sum(nil))\n下面是效果验证"
  },
  {
    "objectID": "content/projects/entries/Go-Zero-Service-Demo.html#缓存",
    "href": "content/projects/entries/Go-Zero-Service-Demo.html#缓存",
    "title": "go-zero-demo",
    "section": "缓存",
    "text": "缓存\n\ngo-zero缓存\n首先讲一下缓存，简单来说缓存就是把下次可能用到的数据先存下来，这样下次需要的时候就不用再慢慢去找，能有效提升加载速度和用户体验。\n在我们日常生活中使用浏览器加载网页一般都会进行缓存，所以一般第一次加载都会很慢，我之前遇到过一个情况，部署在 GitHub Page 的网页会一直缓存着第一次加载的数据，很奇怪，要在浏览器进行单独设置后才会解决这个问题\n在电商场景或者是应用场景下，会将读得特别多、计算成本高、不经常变化的数据或者是需要快速响应的数据进行缓存，既是为了降低成本，也是为了提升效率。\n缓存最常用的数据库就是 Redis，Redis 也在逐渐迭代，适配更多的缓存场景。\n在 go-zero中，可以通过”-c”参数设置缓存的使用，我们在目前的用户订单系统进行简单的缓存实现，首先使用下面指令，生成缓存相关代码\ngoctl model mysql ddl -src=\"./user.sql\" --dir=\"./sql/cachemodel\" -c\n下面是有无缓存代码的对比\n// 有缓存\nfunc (m *defaultUserModel) FindOneByMobile(ctx context.Context, mobile string) (*User, error) {\n    userMobileKey := fmt.Sprintf(\"%s%v\", cacheUserMobilePrefix, mobile)\n    var resp User\n    err := m.QueryRowIndexCtx(ctx, &resp, userMobileKey, m.formatPrimary, func(ctx context.Context, conn sqlx.SqlConn, v any) (i any, e error) {\n        query := fmt.Sprintf(\"select %s from %s where `mobile` = ? limit 1\", userRows, m.table)\n        if err := conn.QueryRowCtx(ctx, &resp, query, mobile); err != nil {\n            return nil, err\n        }\n        return resp.Id, nil\n    }, m.queryPrimary)\n    switch err {\n    case nil:\n        return &resp, nil\n    case sqlc.ErrNotFound:\n        return nil, ErrNotFound\n    default:\n        return nil, err\n    }\n}\n\n//无缓存\nfunc (m *defaultUserModel) FindOneByMobile(ctx context.Context, mobile string) (*User, error) {\n    var resp User\n    query := fmt.Sprintf(\"select %s from %s where `mobile` = ? limit 1\", userRows, m.table)\n    err := m.conn.QueryRowCtx(ctx, &resp, query, mobile)\n    switch err {\n    case nil:\n        return &resp, nil\n    case sqlx.ErrNotFound:\n        return nil, ErrNotFound\n    default:\n        return nil, err\n    }\n}\n有了缓存需求之后，我们就要配置缓存数据库了\n\n先看生成的带缓存的usermodel.go文件并深入查看数据结构的设计，我们能发现需要的新版的配置类型是cache.CacheConf，深入发现需要的参数在RedisConf中，这是我们需要在 yaml 文件中设置的内容。\n\n// NewUserModel returns a model for the database table.\nfunc NewUserModel(conn sqlx.SqlConn, c cache.CacheConf, opts ...cache.Option) UserModel {\n    return &customUserModel{\n        defaultUserModel: newUserModel(conn, c, opts...),\n    }\n}\n\n\ntype (\n    // A ClusterConf is the config of a redis cluster that used as cache.\n    ClusterConf []NodeConf\n\n    // A NodeConf is the config of a redis node that used as cache.\n    NodeConf struct {\n        redis.RedisConf\n        Weight int `json:\",default=100\"`\n    }\n)\n\ntype (\n    // A RedisConf is a redis config.\n    RedisConf struct {\n        Host     string\n        Type     string `json:\",default=node,options=node|cluster\"`\n        User     string `json:\",optional\"`\n        Pass     string `json:\",optional\"`\n        Tls      bool   `json:\",optional\"`\n        NonBlock bool   `json:\",default=true\"`\n        // PingTimeout is the timeout for ping redis.\n        PingTimeout time.Duration `json:\",default=1s\"`\n    }\n\n    // A RedisKeyConf is a redis config with key.\n    RedisKeyConf struct {\n        RedisConf\n        Key string\n    }\n)\n\n然后修改 config.go和 yaml 文件我们简单配置\n然后就结束了，剩下的框架都给你实现了。\n\n\n\ndocker使用 redis\n# 拉取镜像\ndocker pull redis:8\n# 创建容器\ndocker run -d --name testRedis -p 6379:6379 redis:8\n# 进入容器\ndocker exec -it testRedis redis-cli \n# 看一下keys\nkeys cache:user:name:*\n# 退出\nexit\n\n\n测试\n通过结合 postman测试发现会逐渐将搜索加入缓存\n\n这只是一个简单的使用，实际 redis的功能和应用范围非常广泛"
  },
  {
    "objectID": "content/projects/entries/Go-Zero-Service-Demo.html#日志",
    "href": "content/projects/entries/Go-Zero-Service-Demo.html#日志",
    "title": "go-zero-demo",
    "section": "日志",
    "text": "日志\n在 config默认的结构体中嵌入了 go-zero的log配置项，下面是他的完整设计，我们在 yaml文件中创建 Log并进行下面参数的配置\n# 配置\nLog:\n  ServiceName: user-api-srv\n  Mode: file\n  Encoding: json\n  Path: logs\n  Level: info\n  Stat: true\ntype (\n    // A LogConf is a logging config.\n    LogConf struct {\n        // ServiceName represents the service name.\n        ServiceName string `json:\",optional\"`\n        // Mode represents the logging mode, default is `console`.\n        // console: log to console.\n        // file: log to file.\n        // volume: used in k8s, prepend the hostname to the log file name.\n        Mode string `json:\",default=console,options=[console,file,volume]\"`\n        // Encoding represents the encoding type, default is `json`.\n        // json: json encoding.\n        // plain: plain text encoding, typically used in development.\n        Encoding string `json:\",default=json,options=[json,plain]\"`\n        // TimeFormat represents the time format, default is `2006-01-02T15:04:05.000Z07:00`.\n        TimeFormat string `json:\",optional\"`\n        // Path represents the log file path, default is `logs`.\n        Path string `json:\",default=logs\"`\n        // Level represents the log level, default is `info`.\n        Level string `json:\",default=info,options=[debug,info,error,severe]\"`\n        // MaxContentLength represents the max content bytes, default is no limit.\n        MaxContentLength uint32 `json:\",optional\"`\n        // Compress represents whether to compress the log file, default is `false`.\n        Compress bool `json:\",optional\"`\n        // Stat represents whether to log statistics, default is `true`.\n        Stat bool `json:\",default=true\"`\n        // KeepDays represents how many days the log files will be kept. Default to keep all files.\n        // Only take effect when Mode is `file` or `volume`, both work when Rotation is `daily` or `size`.\n        KeepDays int `json:\",optional\"`\n        // StackCooldownMillis represents the cooldown time for stack logging, default is 100ms.\n        StackCooldownMillis int `json:\",default=100\"`\n        // MaxBackups represents how many backup log files will be kept. 0 means all files will be kept forever.\n        // Only take effect when RotationRuleType is `size`.\n        // Even though `MaxBackups` sets 0, log files will still be removed\n        // if the `KeepDays` limitation is reached.\n        MaxBackups int `json:\",default=0\"`\n        // MaxSize represents how much space the writing log file takes up. 0 means no limit. The unit is `MB`.\n        // Only take effect when RotationRuleType is `size`\n        MaxSize int `json:\",default=0\"`\n        // Rotation represents the type of log rotation rule. Default is `daily`.\n        // daily: daily rotation.\n        // size: size limited rotation.\n        Rotation string `json:\",default=daily,options=[daily,size]\"`\n        // FileTimeFormat represents the time format for file name, default is `2006-01-02T15:04:05.000Z07:00`.\n        FileTimeFormat string `json:\",optional\"`\n        // FieldKeys represents the field keys.\n        FieldKeys fieldKeyConf `json:\",optional\"`\n    }\n\n    fieldKeyConf struct {\n        // CallerKey represents the caller key.\n        CallerKey string `json:\",default=caller\"`\n        // ContentKey represents the content key.\n        ContentKey string `json:\",default=content\"`\n        // DurationKey represents the duration key.\n        DurationKey string `json:\",default=duration\"`\n        // LevelKey represents the level key.\n        LevelKey string `json:\",default=level\"`\n        // SpanKey represents the span key.\n        SpanKey string `json:\",default=span\"`\n        // TimestampKey represents the timestamp key.\n        TimestampKey string `json:\",default=@timestamp\"`\n        // TraceKey represents the trace key.\n        TraceKey string `json:\",default=trace\"`\n        // TruncatedKey represents the truncated key.\n        TruncatedKey string `json:\",default=truncated\"`\n    }\n)\n可以使用下面的接口，进行日志的记录\ntype Logger interface {\n    Debug(...any)\n    Debugf(string, ...any)\n    Debugv(any)\n    Debugw(string, ...LogField)\n    Error(...any)\n    Errorf(string, ...any)\n    Errorv(any)\n    Errorw(string, ...LogField)\n    Info(...any)\n    Infof(string, ...any)\n    Infov(any)\n    Infow(string, ...LogField)\n    Slow(...any)\n    Slowf(string, ...any)\n    Slowv(any)\n    Sloww(string, ...LogField)\n    WithCallerSkip(skip int) Logger\n    WithContext(ctx context.Context) Logger\n    WithDuration(d time.Duration) Logger\n    WithFields(fields ...LogField) Logger\n}\n简单测试"
  },
  {
    "objectID": "content/projects/entries/Go-Zero-Service-Demo.html#login-和userinfo接口",
    "href": "content/projects/entries/Go-Zero-Service-Demo.html#login-和userinfo接口",
    "title": "go-zero-demo",
    "section": "login 和userInfo接口",
    "text": "login 和userInfo接口\n主要进行这两个文件中逻辑的完善\n\n在项目中进行简单实现，具体参照项目代码，点击直达\n下面是测试：\n\n\n\n不过项目中还有很多错误，比如 id的写入出现问题，涉及到数据库配置的问题。"
  },
  {
    "objectID": "content/projects/entries/Go-Zero-Service-Demo.html#jwt-鉴权",
    "href": "content/projects/entries/Go-Zero-Service-Demo.html#jwt-鉴权",
    "title": "go-zero-demo",
    "section": "JWT 鉴权",
    "text": "JWT 鉴权\n\nJWT的主要流程\n用户详情接口需要登陆之后才能进行访问\n\n用户登录成功之后-&gt;JSON Web Token(JWT)-&gt;前端会把token保存起来，每次后端调用的时候都会带上，继续验证。\n后端需要鉴权接口，通常是做成中间件的形式进行鉴权，对请求头中的token进行解析\n解析成功就是登录用户\n解析失败就是未登录用户或者是失效用户\nRefresh token\n\n\n\n简单实现和测试\n借助github.com/golang-jwt/jwt/v4实现 jwt 认证\n还有一个比较重要的问题，jwt token存到哪里了，存到项目的 context 中了，我们从 context 中就能取到值。\ntoken := l.ctx.Value(\"userId\")\n生成 token\n\n 测试没加 token 和加入 token 之后的人一个结果，注意会超时，因为之前设置了 60 秒。"
  },
  {
    "objectID": "content/projects/entries/Go-Zero-Service-Demo.html#中间件",
    "href": "content/projects/entries/Go-Zero-Service-Demo.html#中间件",
    "title": "go-zero-demo",
    "section": "中间件",
    "text": "中间件\n路由中间件：只给部分路由添加中间件，比如鉴权，性能检测等等\n全局中间件：全部都要使用\n也能通过闭包调用其他服务中的中间件\n\n中间件定义\n我们可以直接在 api文件中进行定义，通过 middleware 中间件\nsyntax = \"v1\"\n\n// 进行项目的简单说明\ninfo (\n    title:   \"实现简单的用户服务\"\n    author:  \"aorangehc\"\n    date:    \"2025年 11 月 11 日\"\n    version: \"v1\"\n)\n\n// 注册需要用户名、密码、手机号码，要做唯一性检测\ntype RegisterReq {\n    UserName   string `json:\"username\"`\n    Password   string `json:\"password\"`\n    Repassword string `json:\"re_password\"`\n    Mobile     string `json:\"mobile\"`\n    Gender     int    `json:\"gender,options=0|1|2,default=0\"` // male|female|unknown\n    NickName   string `json:\"nickname\"`\n}\n\ntype RegisterResp {\n    success bool   `json:\"success\"` // 注册是否成功\n    Message string `json:\"message\"` // 注册报错信息\n    Id      int64  `json:\"id\"` // 成功注册返回的 id\n}\n\ntype LoginReq {\n    UserName string `json:\"username\"`\n    Password string `json:\"password\"`\n}\n\ntype LoginResp {\n    Message      string `json:\"message\"`\n    AccessToken  string `json:\"accessToken\"`\n    AccessExpire int64  `json:\"accessExpire\"`\n    RefreshAfter int64  `json:\"refreshAfter\"`\n}\n\ntype UserInfoReq {\n    Id int64 `json:\"id\"`\n}\n\ntype UserInfoResp {\n    Id       int64  `json:\"id\"`\n    Token    string `json:\"token\"`\n    UserName string `json:\"username\"`\n    Mobile   string `json:\"mobile\"`\n    Gender   int    `json:\"gender,options=0|1|2,default=0\"` // male|female|unknown\n    NickName string `json:\"nickname\"`\n    CreateAt string `json:\"createAt\"` // 注册时间\n    UpdateAt string `json:\"updateAt\"` // 最后更新时间\n}\n\n// 用户信息更新\ntype UserUpdateReq {\n    Id       int64  `json:\"id\"`\n    UserName string `json:\"username\"`\n    Password string `json:\"password\"`\n    Mobile   string `json:\"mobile\"`\n    Gender   int    `json:\"gender,options=0|1|2,default=0\"` // male|female|unknown\n    NickName string `json:\"nickname\"`\n}\n\ntype UserUpdateResp {\n    success bool   `json:\"success\"`\n    Message string `json:\"message\"` // 更新报错信息\n}\n\n// 定义用户服务的 Api\n@server (\n    prefix: api\n)\nservice user-api {\n    @handler register\n    post /user/register (RegisterReq) returns (RegisterResp)\n\n    @handler login\n    post /user/login (LoginReq) returns (LoginResp)\n}\n\n@server (\n    prefix:     api\n    jwt:        Auth\n    middleware: Cost // 耗时统计的一个中间件\n)\nservice user-api {\n    @handler userInfo // 获取用户信息\n    get /user/:id (UserInfoReq) returns (UserInfoResp)\n\n    @handler userUpdate // 更新用户信息\n    post /user/update (UserUpdateReq) returns (UserUpdateResp)\n}\n\n\nDemo 和测试\n更新完成 api文件之后，通过 goctl更新项目，然后完善\nGoZeroDemo/serviceDemo/user/api/internal/middleware/costMiddleware.go中的 Handle 方法\nGoZeroDemo/serviceDemo/user/api/internal/svc/serviceContext.go中增加 Cost的注册\n之后我们运行项目进行测试，打印出耗时\n\n\n实现一个简单的全局中间件"
  },
  {
    "objectID": "content/projects/entries/Go-Zero-Service-Demo.html#rpc服务和调用",
    "href": "content/projects/entries/Go-Zero-Service-Demo.html#rpc服务和调用",
    "title": "go-zero-demo",
    "section": "RPC服务和调用",
    "text": "RPC服务和调用\n\nRPC 服务实现流程\n\n编写 rpc文件\ngoctl生成项目文件\n修改配置结构体和相关的文件\n完善项目内容\n\n修改 context 文件\n完善 RPC 业务逻辑\n\n测试，使用 postman 测试功能\n\n\n\n\nRPC 调用\n在 go-zero中进行rpc调用基本要进行以下流程\n\n首先配置 yaml 文件和config 文件\n然后在 context 文件中进行数据库连接和 RPC 的配置\n之后再 logic 文件中进行 RPC 的调用\n\n下面是测试结果\n创建订单 \n\n测试订单删除功能 \n\n\n获取订单信息"
  },
  {
    "objectID": "content/projects/entries/Go-Zero-Service-Demo.html#注册中心-consul",
    "href": "content/projects/entries/Go-Zero-Service-Demo.html#注册中心-consul",
    "title": "go-zero-demo",
    "section": "注册中心-consul",
    "text": "注册中心-consul\n原本使用 Etcd 作为 注册中心，要改成 consul，docker 启动 consul\n\n修改配置文件 yaml 和 config.go，注释掉原来的 etcd\n将服务注册到 consul，在启动服务的时候\n服务发现方也需要修改配置\n\n之后启动服务进行测试，测试成功"
  },
  {
    "objectID": "content/projects/entries/Go-Zero-Service-Demo.html#rpc-调用传递-metadata",
    "href": "content/projects/entries/Go-Zero-Service-Demo.html#rpc-调用传递-metadata",
    "title": "go-zero-demo",
    "section": "RPC 调用传递 metadata",
    "text": "RPC 调用传递 metadata\nmetadata（元数据）= 快递单（贴在包裹上的信息：谁寄的、寄给谁、是否易碎）。可以包含：\n\n认证令牌 (Token)： JWT Token，用来证明你是谁。\n链路追踪 ID (Trace ID)： 用来追踪这个请求经过了哪几个微服务（例如 x-request-id）。\n客户端信息： 比如 User-Agent，或者客户端版本号。\n超时控制： 告诉服务端，如果 1 秒没处理完就别处理了。"
  },
  {
    "objectID": "content/projects/entries/Go-Zero-Service-Demo.html#rpc-拦截器",
    "href": "content/projects/entries/Go-Zero-Service-Demo.html#rpc-拦截器",
    "title": "go-zero-demo",
    "section": "RPC 拦截器",
    "text": "RPC 拦截器\n拦截器 = 安检员/分拣中心（在包裹真正到达收件人手里之前，先检查一下快递单，或者对包裹做个消毒）\n装“上下文”信息\n它是一种钩子机制（Hook）。它允许你在请求发送出去之前（客户端）或者请求被处理之前/之后（服务端），插入一段通用的逻辑代码。\n它的核心目的是把通用逻辑从业务代码中剥离出来（AOP 面向切面编程的思想）。可以进行：\n\n身份认证： 在进入业务逻辑前，检查 Metadata 里有没有 Token，Token 对不对。如果不对应，直接拦截退回，业务逻辑根本不用写判断代码。\n日志记录： 记录“谁在什么时间调了哪个接口，耗时多少”。\n错误处理： 统一捕获异常，转换成标准错误码。\n限流/熔断： 检查请求是不是太多了，如果太多直接拦截。\n\n\n客户端拦截器\n在 context 文件中编写拦截器，之后加到 rpc发现服务中\n需要注意：\n\n什么时候存储metadata\n怎么存\n拦截器怎么通过 context 传值\n\n\n\n服务端拦截器\n在启动 RPC 服务之前进行拦截器的注册\n拦截器的业务逻辑实现\n服务端怎么从 metadata 中取到数据\n测试 \n经过简单测试，服务端收到来客户端的元数据并进行安正"
  },
  {
    "objectID": "content/projects/entries/Go-Zero-Service-Demo.html#错误处理",
    "href": "content/projects/entries/Go-Zero-Service-Demo.html#错误处理",
    "title": "go-zero-demo",
    "section": "错误处理",
    "text": "错误处理\n可以自定义错误类型，输出更加全面\n\n定义自定义格式错误\n业务代码中按需使用定义的错误\n告诉 go-zero框架我们自定义了错误类型要进行处理\n\n下面是测试结果"
  },
  {
    "objectID": "content/projects/entries/Go-Zero-Service-Demo.html#修改模板生成自定义代码",
    "href": "content/projects/entries/Go-Zero-Service-Demo.html#修改模板生成自定义代码",
    "title": "go-zero-demo",
    "section": "修改模板生成自定义代码",
    "text": "修改模板生成自定义代码\n参照模板定制化 goctl template\n模版的作用：生成项目代码，goctl指令生成代码的时候就是根据模板来生成代码的\n修改模版的主要指令\ngoctl template clean # 用于删除持久化在本地的模板文件。\ngoctl template init # 用于初始化模板，会将模板文件存储到本地。\ngoctl template revert # 用于回滚某个分类下的指定的模板文件。\ngoctl template update # 用于更新某个分类下的所有模板文件。\n这样在指定目录下就能看到.goctl文件夹，里面存储 tpl文件，我们可以修改文件内容，实现生成项目文件的自动定义"
  },
  {
    "objectID": "content/projects/entries/Go-Zero-Service-Demo.html#参考资料",
    "href": "content/projects/entries/Go-Zero-Service-Demo.html#参考资料",
    "title": "go-zero-demo",
    "section": "参考资料",
    "text": "参考资料\ngo-zero\n七米老师课程"
  },
  {
    "objectID": "content/projects/entries/GoList.html",
    "href": "content/projects/entries/GoList.html",
    "title": "GoList",
    "section": "",
    "text": "一个基于 Go-Kratos 实现的本地任务清单记录项目(只有后端)"
  },
  {
    "objectID": "content/projects/entries/GoList.html#简介",
    "href": "content/projects/entries/GoList.html#简介",
    "title": "GoList",
    "section": "简介",
    "text": "简介\n通过一个小清单工具的实现，完成 Kratos 主要功能的学习和实践\n小清单操作逻辑主要是增删改查，主要是拿来练手用的。\n项目地址：golist。"
  },
  {
    "objectID": "content/projects/entries/GoList.html#初始化",
    "href": "content/projects/entries/GoList.html#初始化",
    "title": "GoList",
    "section": "初始化",
    "text": "初始化\n使用 Kratos 初始化项目并下载相关的依赖\nkratos new golist\ngo mod tidy"
  },
  {
    "objectID": "content/projects/entries/GoList.html#定义api生成代码",
    "href": "content/projects/entries/GoList.html#定义api生成代码",
    "title": "GoList",
    "section": "定义API生成代码",
    "text": "定义API生成代码\n通过定义 protobuf 实现 RPC API 和 Http API 的相关代码。\n使用注释指定 HTTP/JSON 到gRPC 的转换\n注意在生成代码的时候会有对 go版本的需求\n\n在项目中增加新的 API\n使用 kratos proto add指令，在指定位置增加新的 proto文件，这里使用 vx实现版本控制，目前是 v1 版本。\nkratos proto add api/golist/v1/todo.proto\n之后生成的 protobuf 文件并不是空的，而是一个固定的模板，我们可以通过这个模板实现我们自己的服务设计\nproto模板 \nsyntax = \"proto3\";\n\npackage api.golist.v1;\n\noption go_package = \"golist/api/golist/v1;v1\";\noption java_multiple_files = true;\noption java_package = \"api.golist.v1\";\n\nservice Todo {\n    rpc CreateTodo (CreateTodoRequest) returns (CreateTodoReply);\n    rpc UpdateTodo (UpdateTodoRequest) returns (UpdateTodoReply);\n    rpc DeleteTodo (DeleteTodoRequest) returns (DeleteTodoReply);\n    rpc GetTodo (GetTodoRequest) returns (GetTodoReply);\n    rpc ListTodo (ListTodoRequest) returns (ListTodoReply);\n}\n\nmessage CreateTodoRequest {}\nmessage CreateTodoReply {}\n\nmessage UpdateTodoRequest {}\nmessage UpdateTodoReply {}\n\nmessage DeleteTodoRequest {}\nmessage DeleteTodoReply {}\n\nmessage GetTodoRequest {}\nmessage GetTodoReply {}\n\nmessage ListTodoRequest {}\nmessage ListTodoReply {}\n实现 todo 的 proto \nsyntax = \"proto3\";\n\npackage api.golist.v1;\n\nimport \"google/api/annotations.proto\";\n\noption go_package = \"golist/api/golist/v1;v1\";\noption java_multiple_files = true;\noption java_package = \"api.golist.v1\";\n\nservice Todo {\n    rpc CreateTodo (CreateTodoRequest) returns (CreateTodoReply) {\n        option (google.api.http) = {\n            post: \"/v1/todo\",\n            body: \"*\"\n        };\n    };\n    rpc UpdateTodo (UpdateTodoRequest) returns (UpdateTodoReply) {\n        option (google.api.http) =  {\n            put: \"/v1/todo/{id}\",\n            body: \"*\"\n        };\n    };\n    rpc DeleteTodo (DeleteTodoRequest) returns (DeleteTodoReply) {\n        option (google.api.http) =  {\n            delete: \"/v1/todo/{id}\"\n        };\n    };\n    rpc GetTodo (GetTodoRequest) returns (GetTodoReply) {\n        option (google.api.http) =  {\n            get: \"/v1/todo/{id}\",\n        };\n    };\n    rpc ListTodo (ListTodoRequest) returns (ListTodoReply) {\n        option (google.api.http) =  {\n            get: \"/v1/todos\",\n        };\n    };\n}\n\nmessage CreateTodoRequest {\n    string title = 1;\n}\nmessage CreateTodoReply {\n    int64 id = 1;\n    string title = 2;\n    bool status = 3;\n}\n\nmessage UpdateTodoRequest {\n    int64 id = 1;\n    string title = 2;\n    bool status = 3;\n}\nmessage UpdateTodoReply {}\n\nmessage DeleteTodoRequest {\n    int64 id = 1;\n}\nmessage DeleteTodoReply {}\n\nmessage GetTodoRequest {\n    int64 id = 1;\n}\nmessage GetTodoReply {\n    int64 id = 1;\n    string title = 2;\n    bool status = 3;\n}\n\nmessage ListTodoRequest {\n\n}\n\nmessage todo {\n    int64 id = 1;\n    string title = 2;\n    bool status = 3;\n}\n\nmessage ListTodoReply {\n    repeated todo data = 1;\n}\n\n\n生成proto代码\nkratos proto client api/golist/v1/todo.proto\n\n\n生成server 代码\nkratos proto server api/golist/v1/todo.proto -t internal/service"
  },
  {
    "objectID": "content/projects/entries/GoList.html#修改项目结构",
    "href": "content/projects/entries/GoList.html#修改项目结构",
    "title": "GoList",
    "section": "修改项目结构",
    "text": "修改项目结构\n之前生成的基础 kratos会有跟我们实际的业务代码不同的文件，我们可以删除之前的 helloworld代码，修改成我们自己的代码。\n下面是一张图，介绍了 Kratos 的项目结构，非常细致清晰。"
  },
  {
    "objectID": "content/projects/entries/GoList.html#功能实现",
    "href": "content/projects/entries/GoList.html#功能实现",
    "title": "GoList",
    "section": "功能实现",
    "text": "功能实现\n具体代码见golist。\n\ncreate\n\n\n\n\nget\n\n\n\n\ngetAll\n\n\n\nupdate\n\n\n\n\n\ndelete"
  },
  {
    "objectID": "content/projects/entries/GoList.html#参考资料",
    "href": "content/projects/entries/GoList.html#参考资料",
    "title": "GoList",
    "section": "参考资料",
    "text": "参考资料\n七米老师课程\nKratos\nKratos 文档"
  }
]