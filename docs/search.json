[
  {
    "objectID": "content/projects/entries/Quarto-Blogs-Template.html#项目介绍",
    "href": "content/projects/entries/Quarto-Blogs-Template.html#项目介绍",
    "title": "Quarto-Blogs-Template",
    "section": "项目介绍",
    "text": "项目介绍\n这是一个基于 Quarto 构建的现代化个人博客/网站模板，专为研究人员、学生和开发者设计，用于展示研究笔记、项目成果、论文阅读心得和学习记录。\n项目链接\n\n主要特点\n\n模块化结构：支持博客、项目、论文阅读和学习笔记等多种内容类型\n中英文双语支持：内置语言切换功能，轻松实现内容国际化\n响应式设计：适配各种设备屏幕尺寸\n快速开发：提供一键脚本，简化本地预览、构建和发布流程\n自动聚合：首页自动聚合各模块最新内容\n可扩展性：支持自定义样式和内容结构"
  },
  {
    "objectID": "content/projects/entries/Quarto-Blogs-Template.html#环境要求",
    "href": "content/projects/entries/Quarto-Blogs-Template.html#环境要求",
    "title": "Quarto-Blogs-Template",
    "section": "环境要求",
    "text": "环境要求\n\nQuarto：安装指南\nBash：用于运行脚本（Windows 用户可使用 WSL 或 Git Bash）\nrsync：用于发布时的文件同步（部分脚本需要）"
  },
  {
    "objectID": "content/projects/entries/Quarto-Blogs-Template.html#快速开始",
    "href": "content/projects/entries/Quarto-Blogs-Template.html#快速开始",
    "title": "Quarto-Blogs-Template",
    "section": "快速开始",
    "text": "快速开始\n\n本地预览\n./scripts/preview.sh   # 启动本地服务器（热更新）\n\n\n构建项目\n./scripts/build.sh     # 构建网站到 site/ 目录\n\n\n发布网站\n./scripts/publish.sh   # 备份旧 docs/ 并同步 site/ -&gt; docs/"
  },
  {
    "objectID": "content/projects/entries/Quarto-Blogs-Template.html#详细使用说明",
    "href": "content/projects/entries/Quarto-Blogs-Template.html#详细使用说明",
    "title": "Quarto-Blogs-Template",
    "section": "详细使用说明",
    "text": "详细使用说明\n\n目录结构（核心）\n├── content/              # 所有可渲染内容\n│   ├── assets/           # 全站共享图片素材\n│   ├── blogs/entries/    # 博客文章\n│   ├── projects/entries/ # 项目介绍\n│   ├── papers/entries/   # 论文阅读笔记\n│   └── learning-notes/   # 学习笔记（含子模块）\n├── includes/             # 页面片段（如语言切换按钮）\n├── pages/                # 页面文件\n│   ├── index.qmd         # 默认首页（About Me）\n│   └── home.qmd          # Home 页面（聚合各模块最新内容）\n├── scripts/              # 一键脚本\n├── site/                 # 构建产物（默认输出目录）\n├── docs/                 # 发布目录（GitHub Pages）\n├── styles.css            # 全站样式\n└── _quarto.yml           # 项目配置文件\n\n\n新增内容\n\n1. 新增博客文章\n\n进入博客文章目录：content/blogs/entries/\n新建文件，例如 my-blog-post.qmd\n添加 YAML 头部并开始写作：\n\n---\ntitle: \"我的博客文章\"\ndate: 2026-01-13\ncategories: [blogs]\ndescription: \"这是一篇示例博客文章\"\n---\n\n插入图片（使用相对路径）：\n\n![示例图片](../../assets/image.png)\n\n\n2. 新增项目\n\n进入项目目录：content/projects/entries/\n新建文件，例如 my-project.qmd\n按照上述博客文章的格式编写内容\n\n\n\n3. 新增论文阅读笔记\n\n进入论文目录：content/papers/entries/\n新建文件，例如 paper-review.qmd\n按照上述格式编写内容\n\n\n\n4. 新增学习笔记\n\n进入学习笔记目录：content/learning-notes/\n可以创建新的子模块（如 lesson4/）并在其中添加 entries/ 目录\n或者在现有子模块中添加新笔记\n\n\n\n\n语言切换功能\n项目支持中英文双语内容切换，使用方法如下：\n::: {.lang-zh}\n这是中文内容\n:::\n\n::: {.lang-en}\nThis is English content\n:::\n在导航栏和页面标题中也可以使用 HTML 标签实现语言切换：\n&lt;span class=\"lang-en\"&gt;About Me&lt;/span&gt;&lt;span class=\"lang-zh\"&gt;关于我&lt;/span&gt;\n\n\n自定义样式\n\n修改 styles.css 文件可以自定义全站样式\n支持自定义主题颜色、字体大小、布局等"
  },
  {
    "objectID": "content/projects/entries/Quarto-Blogs-Template.html#脚本说明",
    "href": "content/projects/entries/Quarto-Blogs-Template.html#脚本说明",
    "title": "Quarto-Blogs-Template",
    "section": "脚本说明",
    "text": "脚本说明\n\n1. 本地预览脚本 (preview.sh)\n\n启动 Quarto 本地服务器\n支持热更新，修改内容后自动刷新页面\n默认端口：4321\n\n\n\n2. 构建脚本 (build.sh)\n\n构建网站到 site/ 目录\n生成静态 HTML 文件\n\n\n\n3. 发布脚本 (publish.sh)\n\n备份旧的 docs/ 目录到 backup/\n构建网站\n将构建产物从 site/ 同步到 docs/（GitHub Pages 发布目录）\n自动清理旧备份（默认保留最近 3 个备份）\n\n\n\n4. 渲染后清理脚本 (post-render-clean.sh)\n\n在项目渲染后自动执行\n清理嵌套目录结构\n优化文件组织\n\n\n\n5. 备份清理脚本 (prune-backups.sh)\n\n清理旧的备份文件\n可以手动运行以释放存储空间"
  },
  {
    "objectID": "content/projects/entries/Quarto-Blogs-Template.html#配置文件说明",
    "href": "content/projects/entries/Quarto-Blogs-Template.html#配置文件说明",
    "title": "Quarto-Blogs-Template",
    "section": "配置文件说明",
    "text": "配置文件说明\n\n_quarto.yml\n主要配置文件，包含： - 项目类型和输出目录 - 渲染规则和资源管理 - 网站导航栏和页脚设置 - 主题和格式配置\n\n\n渲染规则\nrender:\n  - pages/index.qmd\n  - pages/home.qmd\n  - content/**/index.qmd\n  - content/**/entries/**/*.qmd\n  - content/**/entries/**/*.md\n\n\n资源管理\nresources:\n  - assets/**\n  - content/assets/**"
  },
  {
    "objectID": "content/projects/entries/Quarto-Blogs-Template.html#部署",
    "href": "content/projects/entries/Quarto-Blogs-Template.html#部署",
    "title": "Quarto-Blogs-Template",
    "section": "部署",
    "text": "部署\n\nGitHub Pages\n\n将项目推送到 GitHub 仓库\n配置 GitHub Pages 从 docs/ 目录部署\n运行 ./scripts/publish.sh 构建并发布网站\n\n\n\n其他静态网站托管\n\n运行 ./scripts/build.sh 构建网站\n将 site/ 目录中的内容部署到你的托管服务"
  },
  {
    "objectID": "content/projects/entries/Quarto-Blogs-Template.html#注意事项",
    "href": "content/projects/entries/Quarto-Blogs-Template.html#注意事项",
    "title": "Quarto-Blogs-Template",
    "section": "注意事项",
    "text": "注意事项\n\ntmp/ 目录用于存放草稿，不会被渲染和提交到 Git\nbackup/ 目录存放发布备份，可随时清理\n确保所有内容文件都有正确的 YAML 头部\n使用相对路径引用图片和其他资源"
  },
  {
    "objectID": "content/projects/entries/Quarto-Blogs-Template.html#许可证",
    "href": "content/projects/entries/Quarto-Blogs-Template.html#许可证",
    "title": "Quarto-Blogs-Template",
    "section": "许可证",
    "text": "许可证\nApache License"
  },
  {
    "objectID": "content/projects/entries/Quarto-Blogs-Template.html#贡献",
    "href": "content/projects/entries/Quarto-Blogs-Template.html#贡献",
    "title": "Quarto-Blogs-Template",
    "section": "贡献",
    "text": "贡献\n欢迎提交 Issues 和 Pull Requests 来改进这个模板！"
  },
  {
    "objectID": "content/projects/entries/Daily-Log-Maker.html",
    "href": "content/projects/entries/Daily-Log-Maker.html",
    "title": "Daily Log Maker",
    "section": "",
    "text": "一个开箱即用的轻量级网页工具，帮助你把每日复盘、待办、工作/学习总结，快速排版成精致的长图海报并保存为高清 PNG。\n\n\n\n可视化编辑：左侧面板实时修改日期、主标题、每日一句，右侧画布同步预览。\n文本格式化工具栏：支持加粗、项目符号列表、五色高亮标记、灰底块、红色删除线等。\n主题卡片：选择主题色、输入 Emoji 与模块标题，一键添加到画布，内容可直接编辑。\n高清长图导出：解决内容超出屏幕被截断的问题，生成完整、透明背景的高清 PNG。\n零依赖运行：双击 HTML 即用；通过 CDN 自动加载 html2canvas 与字体资源。\n\n\n\n\n\n用任意现代浏览器（推荐 Chrome/Edge）打开项目根目录中的 Daily Log Maker.html。\n在左侧面板填写：日期、主标题、每日一句；内容会实时展示在右侧画布。\n添加模块：\n\n选择一个主题色；\n输入 Emoji 与模块标题；\n点击“+ 添加到画布”；在卡片正文中直接编辑内容，支持格式化。\n\n点击左侧的“保存图片”按钮，自动生成并下载长图（文件名形如 每日记录_Long_YYYY.MM.DD.png）。\n\n\n\n\n\n选中文本后再点击工具栏按钮，可应用加粗/高亮/删除线等格式。\n列表支持快捷输入：在正文中输入多行文本后，点击“列表”按钮即可批量转为项目符号。\n画布右上角的“✕”只会删除对应卡片，不影响其他内容。\n导出为透明背景的 PNG，适合拼接到社交平台或文档中。\n\n\n\n\n\n截图实现：通过 html2canvas（CDN 引入）对画布节点进行截图，采用“克隆节点 + 自然撑高”的方式，确保超长内容完整保留并避免阴影等干扰。\n清晰度：截图时设置 scale = 2.5，在常见屏幕下可获得良好清晰度与文件大小平衡。\n内容编辑：模块正文使用 contenteditable，配合基础命令实现常见富文本操作。\n\n\n\n\n如果需要完全离线： - 将 html2canvas 的 CDN 改为本地文件，并把 Google Fonts 替换为系统字体或本地字体文件； - 保持页面结构不变即可使用导出功能。\n\n\n\n\n推荐使用最新版 Chrome/Edge/Firefox。\n在极端超长内容下，截图耗时与内存占用会增加；如遇问题，可尝试降低 scale 值或分段导出。"
  },
  {
    "objectID": "content/projects/entries/Daily-Log-Maker.html#功能亮点",
    "href": "content/projects/entries/Daily-Log-Maker.html#功能亮点",
    "title": "Daily Log Maker",
    "section": "",
    "text": "可视化编辑：左侧面板实时修改日期、主标题、每日一句，右侧画布同步预览。\n文本格式化工具栏：支持加粗、项目符号列表、五色高亮标记、灰底块、红色删除线等。\n主题卡片：选择主题色、输入 Emoji 与模块标题，一键添加到画布，内容可直接编辑。\n高清长图导出：解决内容超出屏幕被截断的问题，生成完整、透明背景的高清 PNG。\n零依赖运行：双击 HTML 即用；通过 CDN 自动加载 html2canvas 与字体资源。"
  },
  {
    "objectID": "content/projects/entries/Daily-Log-Maker.html#快速开始",
    "href": "content/projects/entries/Daily-Log-Maker.html#快速开始",
    "title": "Daily Log Maker",
    "section": "",
    "text": "用任意现代浏览器（推荐 Chrome/Edge）打开项目根目录中的 Daily Log Maker.html。\n在左侧面板填写：日期、主标题、每日一句；内容会实时展示在右侧画布。\n添加模块：\n\n选择一个主题色；\n输入 Emoji 与模块标题；\n点击“+ 添加到画布”；在卡片正文中直接编辑内容，支持格式化。\n\n点击左侧的“保存图片”按钮，自动生成并下载长图（文件名形如 每日记录_Long_YYYY.MM.DD.png）。"
  },
  {
    "objectID": "content/projects/entries/Daily-Log-Maker.html#使用技巧",
    "href": "content/projects/entries/Daily-Log-Maker.html#使用技巧",
    "title": "Daily Log Maker",
    "section": "",
    "text": "选中文本后再点击工具栏按钮，可应用加粗/高亮/删除线等格式。\n列表支持快捷输入：在正文中输入多行文本后，点击“列表”按钮即可批量转为项目符号。\n画布右上角的“✕”只会删除对应卡片，不影响其他内容。\n导出为透明背景的 PNG，适合拼接到社交平台或文档中。"
  },
  {
    "objectID": "content/projects/entries/Daily-Log-Maker.html#技术说明",
    "href": "content/projects/entries/Daily-Log-Maker.html#技术说明",
    "title": "Daily Log Maker",
    "section": "",
    "text": "截图实现：通过 html2canvas（CDN 引入）对画布节点进行截图，采用“克隆节点 + 自然撑高”的方式，确保超长内容完整保留并避免阴影等干扰。\n清晰度：截图时设置 scale = 2.5，在常见屏幕下可获得良好清晰度与文件大小平衡。\n内容编辑：模块正文使用 contenteditable，配合基础命令实现常见富文本操作。"
  },
  {
    "objectID": "content/projects/entries/Daily-Log-Maker.html#离线使用",
    "href": "content/projects/entries/Daily-Log-Maker.html#离线使用",
    "title": "Daily Log Maker",
    "section": "",
    "text": "如果需要完全离线： - 将 html2canvas 的 CDN 改为本地文件，并把 Google Fonts 替换为系统字体或本地字体文件； - 保持页面结构不变即可使用导出功能。"
  },
  {
    "objectID": "content/projects/entries/Daily-Log-Maker.html#浏览器兼容",
    "href": "content/projects/entries/Daily-Log-Maker.html#浏览器兼容",
    "title": "Daily Log Maker",
    "section": "",
    "text": "推荐使用最新版 Chrome/Edge/Firefox。\n在极端超长内容下，截图耗时与内存占用会增加；如遇问题，可尝试降低 scale 值或分段导出。"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/protobuf.html",
    "href": "content/learning-notes/microservices/entries/protobuf.html",
    "title": "Protobuf",
    "section": "",
    "text": "Protobuf(Protocal Buffer)，是谷歌开源的一种和语言、平台无关的，能进行扩展的，用于序列化结构化数据的协议\n可用于数据的通信、数据存储，只需要定义一次数据结构，就可以使用生成的源代码，从各种数据流或者语言中写入和读取结构化数据。\nProtobuf用于微服务的通信协议"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/protobuf.html#基本语法",
    "href": "content/learning-notes/microservices/entries/protobuf.html#基本语法",
    "title": "Protobuf",
    "section": "基本语法",
    "text": "基本语法\n\n基本框架\nsyntax = \"proto3\";\n\npackage xxx.xxx;\n\noption gp_package = \"./xxx/xxx/xxx; xxx\";\n\n// 一共有三个部分\n// 第一行是版本声明\n// 第二个是包的声明，防止不同项目同名消息的冲突\n// 第三个手生成文件路径和生成的Go的包名\n\n\n定义服务\n说明\n\nservice表示这是一个服务（接口），关于他的命名规则，考虑到golang中通过首字母的大小写来进行区别私有和公共，所以必须大写，让其他文件能够调用，同时以后缀Service结尾，表示这是一个服务\nrpc，必须写，只能有这一个，表示使用rpc远程过程调用\nstream，流式，用于大文件传输，聊天场景或者打字机效果等等\n\n一问多答，问完之后，回答按照严格顺序返回\n多问一答，严格顺序输入请求，等待一个响应\n多问多答，完全异步的两根管子，互补阻塞\n\n模式1，一问一答，像打乒乓球一样\n模式2，像你和你暧昧对象聊天一样，你发10条，ta会一条，或者反过来都有可能，请求和响应走不通的通道\n这样的话，在golang中需要通过goroutine进行实现\n\n\n\nservice TestService {\n        rpc IndexDocument (IndexRequest) returns (IndexResponse)\n        rpc Chat (ChatRequest) returns (stream ChatReponse) // 一问多答\n        rpc UploadFile (stream FileChunk) returns (UploadStatus) // 多问一答\n        rpc LiveChat (stream VoiceData) returns (stream VoiceData) // 变问边答\n}\n\n\n定义消息\nmessage 相当于 golang中的struct\n基本语法格式：类型 字段名 = 唯一编号;\n下面是一个demo\nmessage IndexRequest {\n        string library_id = 1; // 字符串\n        int32 file_size = 2; // 整数类型int32\n        bytes file_content = 3; // 文件内容使用二进制\n        bool is_public = 4; // 布尔值\n}\n注意事项，唯一编号的的问题，它相当于字段的一个身份认证，在进行RPC的时候为了省流量，不传输原本的变量名，直接传输编号，为了防止编号混乱，上线之后就不要修改已有的编号，正确做法，如果编号废弃之后就空着不要用了，用新的字段值\nmessage和Go类型对比\n\n消息中比较高级的数据结构\n\n数组(slice)\n使用repeated关键字\nmessage ChatResponse {\n        repeated string sources = 1;\n}\n\n\n字典(map)\nmap也就是键值对\n使用map作为关键字\nmessage IndexRequest {\n        // Metadata map[string]string\n        map&lt;string, string&gt; metasata = 2;\n}\n\n\n枚举(enum)\n使用enum作为关键字，枚举必须从0开始，通常是默认值或者是未知值\nenum只能作为message一部分使用，不能进行单独传输\n// 定义枚举 (必须从 0 开始)\nenum DocType {\n  UNKNOWN = 0; // 规范：第一个必须是 0，通常作为默认/未知值\n  PDF = 1;\n  IMAGE = 2;\n  WORD = 3;\n}\n\nmessage Document {\n  string name = 1;\n  DocType type = 2; // 使用上面定义的枚举\n}\n\n\n嵌套消息(nested)\nmessage Author {\n        string name = 1;\n}\n\nmessage Book {\n        string title = 1;\n        Author author = 2;\n}\n\n\n\n\n语法规范\n\n消息名 (Message Name)：使用 大驼峰 (ChatRequest)。\n字段名 (Field Name)：使用 下划线蛇形 (library_id, file_name)。\n\n为什么？ 因为生成的 Go 代码会自动帮你转成驼峰 (LibraryId, FileName)，但在 Proto 文件里看下划线更清晰。\n\n服务名 (Service Name)：使用 大驼峰 (OmniRAGService)。"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/protobuf.html#安装protobuf",
    "href": "content/learning-notes/microservices/entries/protobuf.html#安装protobuf",
    "title": "Protobuf",
    "section": "安装protobuf",
    "text": "安装protobuf\n\nMac安装\n直接通过下面的指令进行安装即可\nbrew install protobuf\n\nprotoc --version\n\n# 1. 安装生成数据结构的插件\ngo install google.golang.org/protobuf/cmd/protoc-gen-go@latest\n\n# 2. 安装生成 gRPC 服务的插件\ngo install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest\n\n\nWin安装\n在 Windows 上安装 Protobuf 和 Go 插件，主要分为 安装编译器核心 (protoc) 和 安装 Go 语言插件 两步。\n由于 Windows 没有像 Homebrew 那样统一的默认包管理器，我们需要手动下载并配置环境变量。请按照以下步骤操作：\n第一步：安装编译器核心 (protoc)\n这是 Google 提供的核心工具，负责读取 .proto 文件。\n\n下载压缩包：\n\n访问 GitHub 发布页：Protocol Buffers Releases\n找到最新版本（例如 v25.x 或更高）。\n在 “Assets” 列表中，下载 protoc-xx.x-win64.zip (注意选 win64)。\n\n解压：\n\n将压缩包解压到一个你不会删除的地方，建议放在 C:。\n解压后，你应该能看到 bin 文件夹，里面有一个 protoc.exe。\n\n配置环境变量 (Path) —— 最关键的一步：\n\n按 Win 键，搜索 “编辑系统环境变量” 并打开。\n点击右下角的 “环境变量” 按钮。\n在下方的 “系统变量” 区域，找到 Path​，选中它，点击 “编辑”。\n点击右侧的 “新建”。\n输入你刚才解压的 bin 目录路径，例如：C:。\n一路点击 “确定” 保存。\n\n验证：\n\n打开一个新的 CMD 或 PowerShell 窗口。\n输入：protoc –version\n如果显示版本号（如 libprotoc 25.1​），说明核心安装成功！\n\n\n第二步：安装 Go 语言插件\n你需要安装两个 Go 插件，这样 protoc 才能生成 Go 代码。\n\n打开 PowerShell 或 CMD，执行以下两条命令：\n\n# 1. 安装生成数据结构的插件\ngo install google.golang.org/protobuf/cmd/protoc-gen-go@latest\n\n# 2. 安装生成 gRPC 服务的插件\ngo install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest\n\n检查 Go 的环境变量：\n\ngo install 会把插件下载到你的 $GOPATH/bin 目录下（通常是 C:​）。\n你需要确保这个路径也在你的 系统环境变量 Path 里。\n验证方法：在终端输入 protoc-gen-go –version。\n\n如果报错“不是内部或外部命令”，请重复“第一步”中的配置环境变量步骤，把 %USERPROFILE%(即你的 go bin 目录) 加到 Path 里。"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/protobuf.html#protobuf使用",
    "href": "content/learning-notes/microservices/entries/protobuf.html#protobuf使用",
    "title": "Protobuf",
    "section": "protobuf使用",
    "text": "protobuf使用\n\n使用示例\nprotoc --proto_path=. \\\n       --go_out=paths=source_relative:. \\\n       --go-grpc_out=paths=source_relative:. \\\n       api/omnirag/v1/omnirag.proto\n\n\n使用说明\n\n--proto_path=.: 告诉编译器，从当前目录（根目录）开始寻找 import 的文件。\n--go_out=paths=source_relative:.:\n\n生成 .pb.go 文件（数据结构）。\npaths=source_relative: 表示生成的文件路径与 proto 文件同级（即生成在 api/omnirag/v1/ 下），而不是按照包名乱跑。\n:.: 输出到当前目录。\n\n--go-grpc_out=paths=source_relative:.:\n\n生成 _grpc.pb.go 文件（服务接口）。\n配置同上。\n\napi/omnirag/v1/omnirag.proto: 目标文件的路径。"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-kit.html",
    "href": "content/learning-notes/microservices/entries/go-kit.html",
    "title": "Go-Kit 微服务框架",
    "section": "",
    "text": "相关代码的GitHub地址：GoKitAddSrv，不同文件夹代表不同章节，直接go run .可运行\n写得比较简单，能跑就行，一些bug和规范问题见谅！"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-kit.html#简介",
    "href": "content/learning-notes/microservices/entries/go-kit.html#简介",
    "title": "Go-Kit 微服务框架",
    "section": "简介",
    "text": "简介\ngo-kit严格意义上并不算是一个完整的框架，更像是一个工具箱或者库的集合，官方描述它为一组包和最佳实践的集合。\n\n它提供了构建微服务所有的标准组件，并且采用整洁架构和洋葱结构。它不追求开发的速度，而是采用强制三层架构，严格分成业务逻辑层（Service）、作为适配器的端点层（Endpoint）和进行协议处理的传输层（Transport），将业务逻辑和网络通信完全解耦。"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-kit.html#核心结构-三层模型",
    "href": "content/learning-notes/microservices/entries/go-kit.html#核心结构-三层模型",
    "title": "Go-Kit 微服务框架",
    "section": "核心结构-三层模型",
    "text": "核心结构-三层模型\n\n\nTransport\n这是最外层的结构，负责处理具体的网络协议，通常是http和rpc，主要功能就是进行编解码，将外部传来的请求，比如Json解析成Endpoint能够读懂的golang结构体，然后调用Endpoint层，再将从Endpoint层获取的结果进行编码，传输发送给客户端。\n\n\nEndpoint\n这是连接业务和网络的中间一层，它负责将Service层中的各种方法强制封装成一个统一的标准函数签名，然后交给Transport层调用\n// Endpoint定义\ntype Endpoint func(ctx context.Context, request interface{}) (response interface{}, err error)\n在这一层，所有的调用都会被统一抽象成同一种形式，通常在这一层进行中间件的挂载。实现一套中间件能应用于所有的接口。\n\n\nService\n业务逻辑层Service只考虑具体业务逻辑的实现，定义并实现接口即可，不用考虑协议和网络服务。"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-kit.html#demo-实现一个简单加法器",
    "href": "content/learning-notes/microservices/entries/go-kit.html#demo-实现一个简单加法器",
    "title": "Go-Kit 微服务框架",
    "section": "Demo-实现一个简单加法器",
    "text": "Demo-实现一个简单加法器\n\nHTTP\n\n说明\n\n在Service层定义接口，包含两个方法\n\nAdd实现int类型的的加法\nConcat实现string类型的加法\n基本流程就是定义接口，实现接口\n\n在Endpoint层，定义请求和响应数据的结构体，将Service层的方法进行封装\n\n接本流程就是定义结构体，封装方法\n\n在Transport层，进行具体协议处理和响应\n\n实现编解码\n实现Handler\n定义路由和端口\n……\n\n\n\n\n测试\n使用Postman进行测试\n\n\n\n\n\nRPC\n这里使用gRpc\n\n说明\n\n实现proto文件\n\n定义proto文件夹\n在文件夹中编写proto文件，定义service和message\n执行protoc指令，生成golang文件\nprotoc -I=proto --go_out=proto --go_opt=paths=source_relative --go-grpc_out=proto --go-grpc_opt=paths=source_relative proto/addsrv.proto\n\n在Service层定义接口，包含两个方法\n\nAdd实现int类型的的加法\nConcat实现string类型的加法\n基本流程就是定义接口，实现接口\n\n在Endpoint层，定义请求和响应数据的结构体，将Service层的方法进行封装\n\n接本流程就是定义结构体，封装方法\n\n在Transport层，进行具体协议处理和响应\n\n实现rpc编解码\n实现Handler\n实现protobuf接口\n……\n\n\n\n\n测试\n使用Postman进行测试"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-kit.html#项目结构拆分",
    "href": "content/learning-notes/microservices/entries/go-kit.html#项目结构拆分",
    "title": "Go-Kit 微服务框架",
    "section": "项目结构拆分",
    "text": "项目结构拆分\n根据go-kit设计好的三层结构，我们对原本单独的三个文件夹进行分层实现，下面是具体的目录结构"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-kit.html#中间件",
    "href": "content/learning-notes/microservices/entries/go-kit.html#中间件",
    "title": "Go-Kit 微服务框架",
    "section": "中间件",
    "text": "中间件\n\n日志\n\n全局创建日志\n在接口实现的时候传入日志\n定义日志接口，在接口中加入应用接口+日志，然后再实现方法\n\n// go-kit官方设计\ntype logMiddleware struct {\n    logger log.Logger\n    next   AddService\n}\n在项目中加入日志中间件，简单实现示意\n\n\n\n限流\n加入限流中间件，1秒钟只能请求一次\n在实际业务场景中可以针对单个用户进行更加细粒度的限制\n\n在项目中加入限流中间件，简单实现示意\n\n\n\n指标采集\n使用metrics包来记录关于服务运行时行为的统计信息，比如计算已处理作业的数量、记录请求完成后的持续时间以及跟踪正在执行的操作的数量等等。\n在项目中加入指标采集中间件，简单实现示意"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-kit.html#服务调用",
    "href": "content/learning-notes/microservices/entries/go-kit.html#服务调用",
    "title": "Go-Kit 微服务框架",
    "section": "服务调用",
    "text": "服务调用\n通过构建结构体，加入当前服务和被调用服务（被设置为endpoint.Endpoint类型）实现调用\n\n简单实现示意"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-kit.html#服务发现和负载均衡",
    "href": "content/learning-notes/microservices/entries/go-kit.html#服务发现和负载均衡",
    "title": "Go-Kit 微服务框架",
    "section": "服务发现和负载均衡",
    "text": "服务发现和负载均衡\n关于concul的安装和使用可以见：concul\ngo-kit提供服务发现和负载均衡的相应机制\n\nGo kit 提供了工厂函数Factory， 它是一个将实例字符串(例如host:port)转换为特定端点的函数。提供多个端点的实例需要多个工厂函数。工厂函数还返回一个当实例消失并需要清理时调用的io.Closer。\nGo kit 提供了基本的负载均衡器，也可以自己实现。\n重试策略包装负载均衡器，并返回可用的端点。重试策略将重试失败的请求，直到达到最大尝试或超时为止。\n\n// 工厂函数\ntype Factory func(instance string) (endpoint.Endpoint, io.Closer, error)\n\n//  负载均衡\nimport \"github.com/go-kit/kit/sd/lb\"\nbalancer := lb.NewRoundRobin(endpointer)\n\n// 重试\nfunc Retry(max int, timeout time.Duration, lb Balancer) endpoint.Endpoint\nimport \"github.com/go-kit/kit/sd/lb\"\nretry := lb.Retry(3, 500*time.Millisecond, balancer)\n下面是简单实现\n开了两个trim_service分别在两个终端，调用的时候会自动轮询"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-kit.html#参考资料",
    "href": "content/learning-notes/microservices/entries/go-kit.html#参考资料",
    "title": "Go-Kit 微服务框架",
    "section": "参考资料",
    "text": "参考资料\nGo-kit\nGemini老师\nGo kit教程01——基础示例\nGo kit教程02——gRPC\nGo kit教程03——代码分层\nGo kit教程04——中间件和日志\nGo kit教程05——调用其他服务\nGo kit教程06——服务发现和负载均衡"
  },
  {
    "objectID": "content/learning-notes/golang/entries/go的版本管理工具-g的安装和使用.html",
    "href": "content/learning-notes/golang/entries/go的版本管理工具-g的安装和使用.html",
    "title": "go的版本管理工具-g的安装和使用",
    "section": "",
    "text": "最近在进行go的实践，要做go的项目，运行一些项目的时候可能要用到不同的go环境，想到go有没有和python一样的环境管理工具（做实验还是用python比较多），然后查了一下，还是有的，比如gvm、g等等，最终选择了g，感觉找到的博客不够“保姆”就自己写一遍，进行记录，供小白参考。\n\n\n\n\n\n我是用的操作系统是Windows11，安装的话使用的已经编译好的版本\ng的下载地址–&gt;点击跳转\n我选择得是当前最新的1.7.0版本，也可以选择其他版本–&gt;点击跳转\n因为是用的64位Windows操作系统，选择g1.7.0.windows-amd64,然后解压\n\n下载完成后可以解压这个压缩包，里面已有一个名字叫g的应用程序，这个就是我们要用的版本管理工具，已经编译好了\n\n\n\n\ng的使用过程中，最难的一步就是环境变量的配置\n如果在使用g之前已经安装过go，配置过环境变量，需要删相关的环境变量，不然可能会有冲突\n然后，我们开始自己的环境变量的配置 |环境变量名称 |路径 |说明| |——-|——-|——-| |G_HOME | C:.g | 这个是用于下载go安装包个安装go的目录| |GOPATH | %G_HOME%| 这个是g中配置的要使用的go版本的目录| |Path | D:-env | 这个是g.exe所在的目录| |Path | %GOROOT%| 这个是go.exe所在的目录|\n\n\n大家可以根据自己的需要进行修改：\n\n将lier改成自己的用户名 将g.exe放到自己设置的目录下\n\n\n\n\n\n\n\n可以在cmd或者power shell中使用\n打开一个新的cmd，输入g –version，查看结果\n\n\n\n\n\n\n\n查询当前可供安装的stable状态的 go 版本\n\n\n\n\n\n查询可供安装的所有 go 版本\n\n\n\n\n\n安装目标 go 版本\n\n\n\n\n\n查询已安装的 go 版本\n\n\n\n\n\n切换到另一个已安装的 go 版本\n\n\n\n\n\n卸载一个已安装的 go 版本\n\n\n\n\n\n清空 go 安装包文件缓存\n\n\n\n\n\n查看 g 版本信息\n\n\n\n\n\n更新 g 软件本身，要1.5.0及以上版本才能更新\n\n\n\n\n\n卸载 g 软件本身\n\n\n\n\n\n\n\n通过上面的步骤基本就可以顺利安装并使用g进行go的版本管理\n\n\n谢谢阅读！！！"
  },
  {
    "objectID": "content/learning-notes/golang/entries/go的版本管理工具-g的安装和使用.html#step1-g的下载和安装",
    "href": "content/learning-notes/golang/entries/go的版本管理工具-g的安装和使用.html#step1-g的下载和安装",
    "title": "go的版本管理工具-g的安装和使用",
    "section": "",
    "text": "我是用的操作系统是Windows11，安装的话使用的已经编译好的版本\ng的下载地址–&gt;点击跳转\n我选择得是当前最新的1.7.0版本，也可以选择其他版本–&gt;点击跳转\n因为是用的64位Windows操作系统，选择g1.7.0.windows-amd64,然后解压\n\n下载完成后可以解压这个压缩包，里面已有一个名字叫g的应用程序，这个就是我们要用的版本管理工具，已经编译好了\n\n\n\n\ng的使用过程中，最难的一步就是环境变量的配置\n如果在使用g之前已经安装过go，配置过环境变量，需要删相关的环境变量，不然可能会有冲突\n然后，我们开始自己的环境变量的配置 |环境变量名称 |路径 |说明| |——-|——-|——-| |G_HOME | C:.g | 这个是用于下载go安装包个安装go的目录| |GOPATH | %G_HOME%| 这个是g中配置的要使用的go版本的目录| |Path | D:-env | 这个是g.exe所在的目录| |Path | %GOROOT%| 这个是go.exe所在的目录|\n\n\n大家可以根据自己的需要进行修改：\n\n将lier改成自己的用户名 将g.exe放到自己设置的目录下"
  },
  {
    "objectID": "content/learning-notes/golang/entries/go的版本管理工具-g的安装和使用.html#step2-g的使用",
    "href": "content/learning-notes/golang/entries/go的版本管理工具-g的安装和使用.html#step2-g的使用",
    "title": "go的版本管理工具-g的安装和使用",
    "section": "",
    "text": "可以在cmd或者power shell中使用\n打开一个新的cmd，输入g –version，查看结果\n\n\n\n\n\n\n\n查询当前可供安装的stable状态的 go 版本\n\n\n\n\n\n查询可供安装的所有 go 版本\n\n\n\n\n\n安装目标 go 版本\n\n\n\n\n\n查询已安装的 go 版本\n\n\n\n\n\n切换到另一个已安装的 go 版本\n\n\n\n\n\n卸载一个已安装的 go 版本\n\n\n\n\n\n清空 go 安装包文件缓存\n\n\n\n\n\n查看 g 版本信息\n\n\n\n\n\n更新 g 软件本身，要1.5.0及以上版本才能更新\n\n\n\n\n\n卸载 g 软件本身"
  },
  {
    "objectID": "content/learning-notes/golang/entries/go的版本管理工具-g的安装和使用.html#总结",
    "href": "content/learning-notes/golang/entries/go的版本管理工具-g的安装和使用.html#总结",
    "title": "go的版本管理工具-g的安装和使用",
    "section": "",
    "text": "通过上面的步骤基本就可以顺利安装并使用g进行go的版本管理\n\n\n谢谢阅读！！！"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（8）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（8）.html",
    "title": "golang学习记录（8）",
    "section": "",
    "text": "go语言中的函数支持普通函数、匿名函数、闭包函数、方法等\n在go语言中函数是一等公民，函数可以作为参数、函数可以作为返回值、函数可以赋值给变量、函数可以作为闭包函数等\n函数可以满足接口\n\n\n\n函数的基本定义方式如下：\nfunc 函数名(参数列表) (返回值列表) {\n    函数体\n}\n\n参数列表：参数列表可以为空，也可以有多个参数，多个参数之间用逗号分隔\n返回值列表：返回值列表可以为空，也可以有多个返回值，多个返回值之间用逗号分隔，返回值列表不为空时，函数中必须有return\n\n举个简单的例子：\nfunc add(a, b int, c float32) (int, error) {\n    return a + b, nil\n}\n\n在go语言中参数的传递时值传递，即传递的是值的副本，而不是值的引用，因此在函数中修改参数的值不会影响到原变量的值\n但是关于切片的传递，由于切片的底层原理，在函数中修改切片的值会影响到原切片的值，因此在go语言中切片的传递需要注意。\n当且切片发生扩容时，会返回一个新的切片，此时在函数中修改切片的值不会影响到原切片的值\n\n除了上面讲到的函数定义的方法，还可以在返回列表中执行返回参数的名称（相当于定义一个参数名称），这个参数在函数体中不需要再进行定义\n下面是一个例子\nfunc add(a, b int) (sum int, err error) {\n    sum = a + b\n    return sum, err\n    //也可以直接写return\n}\n\n\n\n\n函数在进行参数传递的时候没可能不知道要传多少个值，因此go语言中函数的参数列表中可以使用可变参数\n\n可变参数的基本定义方式如下：\nfunc 函数名(参数列表...类型) (返回值列表) {\n    函数体\n}\n举一个简单的例子：\nfunc add(a ...int)(sum int, err error) {\n    for _, value := range a {\n        sum += value\n    }\n}\nc := 1\nd := 2\nsum, _ := add(a, b, 3, 4)\nfmt.Println(sum)\n\n其中a是一个int类型的切片，在函数中可以使用a[0]、a[1]等方式访问切片中的元，也可以通过for循环进行访问\n\n\n\n\n\n函数的一等公民特性，能够当作参数进行传递、作为返回值进行返回、赋值给变量等操作\n大大提升了函数的灵活性和复用性\n\n\n\n举个例子：\nfunc add(a ...int)(sum int, err error) {\n    for _, value := range a {\n        sum += value\n    }\n}\n\nfunc main(){\n    //这里将add函数作为参数赋值给变量funcVar\n    funcVar := add\n    c := 1\n    d := 2\n    sum, _ := funcVar(a, b, 3, 4)\n    fmt.Println(sum)\n}\n\n\n\n举个例子：\nfunc cal(op string) func(){\n    switch op {\n    case \"+\":\n        return func(){\n            fmt.Println(\"这是加法\")\n        }\n\n    case \"-\":\n        return func(){\n            fmt.Println(\"这是减法\")\n        }\n    default:\n        return func(){\n            fmt.Println(\"这不是加法也不是减法\")\n        }\n    }\n}\n\n//因为返回的是函数，所以在调用的时候需要加上()\ncal(\"+\")()\n\n\n\n举个例子（没啥意义，只是说明用法）：\nfunc add(a, b int) int{\n    fmt.Printf(\"sum is %d\\n\", a + b)\n}\nfunc cal(y int, myfunc func(int, int)) {\n    myfunc(y, 2)\n}\n\ncal(1, add)\n\n//输出结果为sum is 3\n//调用cal函数传递add函数成为myfunc， 然后1+2\n\n\n\n\n匿名函数就是没有函数名的函数，匿名函数可以作为参数进行传递，也可以作为返回值进行返回\n匿名函数是在传递或者返回的时候进行定义\n\n//匿名函数作为参数进行传递\nfunc add(a, b int) int{\n    fmt.Printf(\"sum is %d\\n\", a + b)\n}\nfunc cal(y int, myfunc func(int, int)) {\n    myfunc(y, 2)\n}\n\ncal(1, func(a, b int){\n    fmt.Printf(\"total is %d\\n\", a + b)\n})\n\n//输出结果为total is 3\n//调用cal函数传递临时定义的匿名函数函数成为myfunc， 然后1+2\n\n\n//匿名函数作为变量进行赋值\nfunc cal(y int, myfunc func(int, int)) {\n    myfunc(y, 2)\n}\nlocalFunc := func(a, b int){\n    fmt.Printf(\"local is %d\\n\", a + b)\n}\n\ncal(1, localFunc)\n\n//输出结果为local is 3\n//调用cal函数传递localFunc成为myfunc， 然后1+2，跟上边的效果是一样的\n\n\n\n\n\n有一个需求，希望有一个函数每次调用返回的结果值都是增加一次之后的值\n实现这个需求通常的方法是设置一个全局变量，每次调用函数的时候，将全局变量的值加1，然后返回全局变量的值\n\n全局变量方式实现：\nvar local int\nfunc add() int{\n    local += 1\n    return local\n}\n\nfor i := 0; i &lt; 5; i++ {\n    fmt.Println(add())\n}\n但是这种情况下会出现一个问题，想让local归零很难实现，而且被迫声明了一个全集变量\n因此go中设计了闭包的特性，下面是一个例子：\nfunc auotoAdd() func() int {\n    local := 0\n    return func() int {\n        return local\n    }\n}\n\nnextFunc := auotoAdd()\nfor i := 0; i &lt; 5; i++ {\n    fmt.Println(nextFunc())\n}\n//输出结果为0 1 2 3 4\n//想要归零的话，只需要重新调用auotoAdd()函数即可\n根据上面的例子可以得出闭包的定义：是指一个函数能够访问其外部作用域中的变量，即使外部函数已经结束执行。\n比如：在一个函数中的匿名函数能够访问这个函数中的局部变量，这个匿名函数称为闭包。\n\n\n\n\ndefer可以理解为其它语言中的finally，在函数执行完毕之后执行，通常用于释放资源、关闭文件、关闭数据库连接等操作\n连接数据库、打开文件、开始锁等场景下，无论执行是否成功都要记得进行关闭操作，否则会造成资源泄漏等问题\n\n// 一个在Java中的例子\ntry {\n    // 可能会发生异常的代码\n} catch (Exception e) {\n    // 异常处理代码\n} finally {\n    // 无论是否发生异常，都会执行的代码\n}\n在Java中try和finally之间的距离可能很远，容易忘记关闭资源，而在go中可以使用defer来解决这个问题\n在go中defer的使用方式如下：\nvar mu sync.Mutex\n\nmu.lock()\ndefer mu.unlock() //defer后面的代码会在return之前执行\ndefer语句成对出现，可以防止忘记关闭资源，机制更好用，代码更简洁\ndefer fmt.Println(\"1\")\ndefer fmt.Println(\"2\")\ndefer fmt.Println(\"3\")\nfmt.Println(\"4\")\n//输出结果为4 3 2 1\ndefer的执行顺序是先进后出的，类似于栈的概念\ndefer的应用可以修改返回值\n// 在这个例子中，defer 推迟执行的是一个匿名函数\n// deferReturn 函数被调用，准备返回值 10。\n// 在返回之前，defer 推迟执行的匿名函数被执行。\n// 匿名函数中，result 被增加 1，因此 result 的值从 10 变为 11。\n// deferReturn 函数返回修改后的 result 值，即 11。\n// 因此，尽管 deferReturn 函数的返回语句是 return 10，但由于 defer 推迟执行的函数在返回之前修改了 result 的值，所以最终的输出结果是 11。这也展示了在 Go 语言中，defer 可以修改函数的返回值。\n\n// 搞不懂就看源码\n\nfunc deferReturn() (result int){\n    defer func(){\n        result++\n    }()\n    return 10\n}\n\nret := deferReturn()\nfmt.Println(ret) //输出结果为11\n\n\n\n\n在go语言中关于出错处理最重要的概念有三个：\n1、error\n2、panic\n3、recover\n\n\ngo中关于语言错误处理的理念：不应该使用异常处理控制流程，而应该使用错误值。\n其他语言在使用异常处理控制流程时，通常会使用try catch来捕获异常，类似于包住函数 {: .prompt-tip }\n\n\n在go语言中开发函数的人需要有一个返回值告诉调用者是否成功，go的设计者要求我们必须处理这个err，在go的代码中，会大量出现”if err != nil”这样的语句\ngo的设计者认为必须处理这个err，继续防御性编程\n所以go中使用panic来处理错误，panic会中断当前的函数执行，然后在调用函数中查找是否有recover，如果有recover则会执行recover，否则会一直向上查找，直到找到recover或者程序崩溃\n\n\n\n在go中error有专门的包，下面举个例子：\nimport (\n    \"fmt\"\n    \"errors\"\n)\n\nfunc A() (int, error) {\n    return 1, errors.New(\"这是一个错误\")\n}\n\nfunc main() {\n    if _, err := A(); err!= nil {\n        fmt.Println(err)\n    }\n}\n\n\n\n\npanic是go中的内置函数，这个函数会导致程序退出，使用的场景不是很多\n\n再举个例子：\nimport (\n    \"fmt\"\n    \"errors\"\n)\n\nfunc A() (int, error) {\n    panic(\"this is a panic\")\n    fmt.Println(\"能执行到这吗？\")\n    return 1, errors.New(\"这是一个错误\")\n}\n\nfunc main() {\n    if _, err := A(); err!= nil {\n        fmt.Println(err)\n    }\n}\n\n// 在上面的例子中，panic会导致程序退出，所以fmt.Println(\"能执行到这吗？\")不会被执行，只会打印错误栈\n\npanic会导致程序的退出，注意平时开发中不能随便使用，下面是它的一些应用场景：\n在一个服务启动的过程中，开始必须要准备好一些依赖服务，日志文件是否存在、数据库是否能连接、配置文件有没有问题等等，准备好后才能启动服务\n如果在进行服务启动检查的过程中，发现任何一项需求不能被满足，就主动调用panic，让程序退出\n一旦服务器启动了，某行代码中不小心调用了panic，程序挂了就是非常严重的事故\n在go中一些地方也会被动触发panic：\n1、数组越界\n2、空指针\n……\n\n为了能够应对被动触发panic的情况，go中提供了recover函数，recover函数可以捕获panic，并且让程序继续执行，下一节介绍recover函数\npanic后会返回一个interface{}类型的值，这个值就是panic的值\n\n\n\n下面是一个recover使用的例子：\n// 在go中map的使用需要进行初始化，否则会报错，这是一个会被动触发panic的场景\n\nfunc A() {\n    defer func(){\n        if err := recover(); err!= nil {\n            fmt.Println(\"recoverd is A(): \", err)\n        }\n    }()\n    var names map[string]string\n    names[\"xiaoming\"] = \"go工程师\"\n    return 0, errors.New(\"这是一个错误\")\n}\n// 上面的代码会输出recoverd is A(): assignment to entry nil map\n\n还有一些使用的注意事项：\n1、recover只能在defer函数中使用才能生效\n2、defer需要在panic之前进行定义\n3、recover处理异常后，逻辑并不会恢复到panic的点继续执行\n4、多个defer会形成栈，后定义的defer会先执行"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（8）.html#函数的定义",
    "href": "content/learning-notes/golang/entries/golang学习记录（8）.html#函数的定义",
    "title": "golang学习记录（8）",
    "section": "",
    "text": "函数的基本定义方式如下：\nfunc 函数名(参数列表) (返回值列表) {\n    函数体\n}\n\n参数列表：参数列表可以为空，也可以有多个参数，多个参数之间用逗号分隔\n返回值列表：返回值列表可以为空，也可以有多个返回值，多个返回值之间用逗号分隔，返回值列表不为空时，函数中必须有return\n\n举个简单的例子：\nfunc add(a, b int, c float32) (int, error) {\n    return a + b, nil\n}\n\n在go语言中参数的传递时值传递，即传递的是值的副本，而不是值的引用，因此在函数中修改参数的值不会影响到原变量的值\n但是关于切片的传递，由于切片的底层原理，在函数中修改切片的值会影响到原切片的值，因此在go语言中切片的传递需要注意。\n当且切片发生扩容时，会返回一个新的切片，此时在函数中修改切片的值不会影响到原切片的值\n\n除了上面讲到的函数定义的方法，还可以在返回列表中执行返回参数的名称（相当于定义一个参数名称），这个参数在函数体中不需要再进行定义\n下面是一个例子\nfunc add(a, b int) (sum int, err error) {\n    sum = a + b\n    return sum, err\n    //也可以直接写return\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（8）.html#函数的可变参数",
    "href": "content/learning-notes/golang/entries/golang学习记录（8）.html#函数的可变参数",
    "title": "golang学习记录（8）",
    "section": "",
    "text": "函数在进行参数传递的时候没可能不知道要传多少个值，因此go语言中函数的参数列表中可以使用可变参数\n\n可变参数的基本定义方式如下：\nfunc 函数名(参数列表...类型) (返回值列表) {\n    函数体\n}\n举一个简单的例子：\nfunc add(a ...int)(sum int, err error) {\n    for _, value := range a {\n        sum += value\n    }\n}\nc := 1\nd := 2\nsum, _ := add(a, b, 3, 4)\nfmt.Println(sum)\n\n其中a是一个int类型的切片，在函数中可以使用a[0]、a[1]等方式访问切片中的元，也可以通过for循环进行访问"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（8）.html#函数一等公民特性",
    "href": "content/learning-notes/golang/entries/golang学习记录（8）.html#函数一等公民特性",
    "title": "golang学习记录（8）",
    "section": "",
    "text": "函数的一等公民特性，能够当作参数进行传递、作为返回值进行返回、赋值给变量等操作\n大大提升了函数的灵活性和复用性\n\n\n\n举个例子：\nfunc add(a ...int)(sum int, err error) {\n    for _, value := range a {\n        sum += value\n    }\n}\n\nfunc main(){\n    //这里将add函数作为参数赋值给变量funcVar\n    funcVar := add\n    c := 1\n    d := 2\n    sum, _ := funcVar(a, b, 3, 4)\n    fmt.Println(sum)\n}\n\n\n\n举个例子：\nfunc cal(op string) func(){\n    switch op {\n    case \"+\":\n        return func(){\n            fmt.Println(\"这是加法\")\n        }\n\n    case \"-\":\n        return func(){\n            fmt.Println(\"这是减法\")\n        }\n    default:\n        return func(){\n            fmt.Println(\"这不是加法也不是减法\")\n        }\n    }\n}\n\n//因为返回的是函数，所以在调用的时候需要加上()\ncal(\"+\")()\n\n\n\n举个例子（没啥意义，只是说明用法）：\nfunc add(a, b int) int{\n    fmt.Printf(\"sum is %d\\n\", a + b)\n}\nfunc cal(y int, myfunc func(int, int)) {\n    myfunc(y, 2)\n}\n\ncal(1, add)\n\n//输出结果为sum is 3\n//调用cal函数传递add函数成为myfunc， 然后1+2\n\n\n\n\n匿名函数就是没有函数名的函数，匿名函数可以作为参数进行传递，也可以作为返回值进行返回\n匿名函数是在传递或者返回的时候进行定义\n\n//匿名函数作为参数进行传递\nfunc add(a, b int) int{\n    fmt.Printf(\"sum is %d\\n\", a + b)\n}\nfunc cal(y int, myfunc func(int, int)) {\n    myfunc(y, 2)\n}\n\ncal(1, func(a, b int){\n    fmt.Printf(\"total is %d\\n\", a + b)\n})\n\n//输出结果为total is 3\n//调用cal函数传递临时定义的匿名函数函数成为myfunc， 然后1+2\n\n\n//匿名函数作为变量进行赋值\nfunc cal(y int, myfunc func(int, int)) {\n    myfunc(y, 2)\n}\nlocalFunc := func(a, b int){\n    fmt.Printf(\"local is %d\\n\", a + b)\n}\n\ncal(1, localFunc)\n\n//输出结果为local is 3\n//调用cal函数传递localFunc成为myfunc， 然后1+2，跟上边的效果是一样的"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（8）.html#go中函数的闭包特性",
    "href": "content/learning-notes/golang/entries/golang学习记录（8）.html#go中函数的闭包特性",
    "title": "golang学习记录（8）",
    "section": "",
    "text": "有一个需求，希望有一个函数每次调用返回的结果值都是增加一次之后的值\n实现这个需求通常的方法是设置一个全局变量，每次调用函数的时候，将全局变量的值加1，然后返回全局变量的值\n\n全局变量方式实现：\nvar local int\nfunc add() int{\n    local += 1\n    return local\n}\n\nfor i := 0; i &lt; 5; i++ {\n    fmt.Println(add())\n}\n但是这种情况下会出现一个问题，想让local归零很难实现，而且被迫声明了一个全集变量\n因此go中设计了闭包的特性，下面是一个例子：\nfunc auotoAdd() func() int {\n    local := 0\n    return func() int {\n        return local\n    }\n}\n\nnextFunc := auotoAdd()\nfor i := 0; i &lt; 5; i++ {\n    fmt.Println(nextFunc())\n}\n//输出结果为0 1 2 3 4\n//想要归零的话，只需要重新调用auotoAdd()函数即可\n根据上面的例子可以得出闭包的定义：是指一个函数能够访问其外部作用域中的变量，即使外部函数已经结束执行。\n比如：在一个函数中的匿名函数能够访问这个函数中的局部变量，这个匿名函数称为闭包。"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（8）.html#defer的应用场景",
    "href": "content/learning-notes/golang/entries/golang学习记录（8）.html#defer的应用场景",
    "title": "golang学习记录（8）",
    "section": "",
    "text": "defer可以理解为其它语言中的finally，在函数执行完毕之后执行，通常用于释放资源、关闭文件、关闭数据库连接等操作\n连接数据库、打开文件、开始锁等场景下，无论执行是否成功都要记得进行关闭操作，否则会造成资源泄漏等问题\n\n// 一个在Java中的例子\ntry {\n    // 可能会发生异常的代码\n} catch (Exception e) {\n    // 异常处理代码\n} finally {\n    // 无论是否发生异常，都会执行的代码\n}\n在Java中try和finally之间的距离可能很远，容易忘记关闭资源，而在go中可以使用defer来解决这个问题\n在go中defer的使用方式如下：\nvar mu sync.Mutex\n\nmu.lock()\ndefer mu.unlock() //defer后面的代码会在return之前执行\ndefer语句成对出现，可以防止忘记关闭资源，机制更好用，代码更简洁\ndefer fmt.Println(\"1\")\ndefer fmt.Println(\"2\")\ndefer fmt.Println(\"3\")\nfmt.Println(\"4\")\n//输出结果为4 3 2 1\ndefer的执行顺序是先进后出的，类似于栈的概念\ndefer的应用可以修改返回值\n// 在这个例子中，defer 推迟执行的是一个匿名函数\n// deferReturn 函数被调用，准备返回值 10。\n// 在返回之前，defer 推迟执行的匿名函数被执行。\n// 匿名函数中，result 被增加 1，因此 result 的值从 10 变为 11。\n// deferReturn 函数返回修改后的 result 值，即 11。\n// 因此，尽管 deferReturn 函数的返回语句是 return 10，但由于 defer 推迟执行的函数在返回之前修改了 result 的值，所以最终的输出结果是 11。这也展示了在 Go 语言中，defer 可以修改函数的返回值。\n\n// 搞不懂就看源码\n\nfunc deferReturn() (result int){\n    defer func(){\n        result++\n    }()\n    return 10\n}\n\nret := deferReturn()\nfmt.Println(ret) //输出结果为11"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（8）.html#go的errorrecover和panic",
    "href": "content/learning-notes/golang/entries/golang学习记录（8）.html#go的errorrecover和panic",
    "title": "golang学习记录（8）",
    "section": "",
    "text": "在go语言中关于出错处理最重要的概念有三个：\n1、error\n2、panic\n3、recover\n\n\ngo中关于语言错误处理的理念：不应该使用异常处理控制流程，而应该使用错误值。\n其他语言在使用异常处理控制流程时，通常会使用try catch来捕获异常，类似于包住函数 {: .prompt-tip }\n\n\n在go语言中开发函数的人需要有一个返回值告诉调用者是否成功，go的设计者要求我们必须处理这个err，在go的代码中，会大量出现”if err != nil”这样的语句\ngo的设计者认为必须处理这个err，继续防御性编程\n所以go中使用panic来处理错误，panic会中断当前的函数执行，然后在调用函数中查找是否有recover，如果有recover则会执行recover，否则会一直向上查找，直到找到recover或者程序崩溃\n\n\n\n在go中error有专门的包，下面举个例子：\nimport (\n    \"fmt\"\n    \"errors\"\n)\n\nfunc A() (int, error) {\n    return 1, errors.New(\"这是一个错误\")\n}\n\nfunc main() {\n    if _, err := A(); err!= nil {\n        fmt.Println(err)\n    }\n}\n\n\n\n\npanic是go中的内置函数，这个函数会导致程序退出，使用的场景不是很多\n\n再举个例子：\nimport (\n    \"fmt\"\n    \"errors\"\n)\n\nfunc A() (int, error) {\n    panic(\"this is a panic\")\n    fmt.Println(\"能执行到这吗？\")\n    return 1, errors.New(\"这是一个错误\")\n}\n\nfunc main() {\n    if _, err := A(); err!= nil {\n        fmt.Println(err)\n    }\n}\n\n// 在上面的例子中，panic会导致程序退出，所以fmt.Println(\"能执行到这吗？\")不会被执行，只会打印错误栈\n\npanic会导致程序的退出，注意平时开发中不能随便使用，下面是它的一些应用场景：\n在一个服务启动的过程中，开始必须要准备好一些依赖服务，日志文件是否存在、数据库是否能连接、配置文件有没有问题等等，准备好后才能启动服务\n如果在进行服务启动检查的过程中，发现任何一项需求不能被满足，就主动调用panic，让程序退出\n一旦服务器启动了，某行代码中不小心调用了panic，程序挂了就是非常严重的事故\n在go中一些地方也会被动触发panic：\n1、数组越界\n2、空指针\n……\n\n为了能够应对被动触发panic的情况，go中提供了recover函数，recover函数可以捕获panic，并且让程序继续执行，下一节介绍recover函数\npanic后会返回一个interface{}类型的值，这个值就是panic的值\n\n\n\n下面是一个recover使用的例子：\n// 在go中map的使用需要进行初始化，否则会报错，这是一个会被动触发panic的场景\n\nfunc A() {\n    defer func(){\n        if err := recover(); err!= nil {\n            fmt.Println(\"recoverd is A(): \", err)\n        }\n    }()\n    var names map[string]string\n    names[\"xiaoming\"] = \"go工程师\"\n    return 0, errors.New(\"这是一个错误\")\n}\n// 上面的代码会输出recoverd is A(): assignment to entry nil map\n\n还有一些使用的注意事项：\n1、recover只能在defer函数中使用才能生效\n2、defer需要在panic之前进行定义\n3、recover处理异常后，逻辑并不会恢复到panic的点继续执行\n4、多个defer会形成栈，后定义的defer会先执行"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（6）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（6）.html",
    "title": "golang学习记录（6）",
    "section": "",
    "text": "个其他语言差不多，go中if语句后面的条件判断可以加括号，也可以不加，通常不写括号，但是如果条件比较复杂，建议加上括号。\nage := 10\n//1、加括号\nif age &gt; 18 {\n    fmt.Println(\"你已经成年了\")\n}\n//2、不加括号\nif (age &gt; 18){\n    fmt.Println(\"你已经成年了\")\n}\n\n\n\nage := 10\nif age &gt; 18 {\n    fmt.Println(\"你已经成年了\")\n} else {\n    fmt.Println(\"你还没有成年\")\n}\n\n// else if\nif age &gt; 20 {\n    fmt.Println(\"你已经成年了\")\n} else if a18 &gt; 16 {\n    fmt.Println(\"你已经成年了\")\n} else {\n    fmt.Println(\"你还没有成年\")\n}\n\n\n\n\n\ngo中没有while循环，只有for循环\n\n\n\n//基础写法\nfor i := 0; i &lt; 10; i++ {\n    fmt.Println(i)\n}\n//注意不能加括号\n\n//for循环代替while循环\nvar i int = 0\nfor {\n    if i &gt; 10 {\n        break\n    }\n    fmt.Println(i)\n    i++\n}\n\n\n\n\n\nfor i := 1; i &lt;= 1--; i++{\n    if i % 2 == 0{\n        fmt.Println(i)\n    }\n}\n\n\n\nfor i := 1; i &lt;= 9; i++{\n    for j := 1; j &lt;= i; j++{\n        fmt.Printf(\"%d * %d = %d\\t\", j, i, i * j)\n    }\n    fmt.Println()\n}\n\n\n\n\n\nfor range 主要对于数组、切片、字符串、map、通道等进行迭代循环，返回的是索引和值。\n\nname := \"hello go, hello world\"\n\nfor index, value := range name {\n    fmt.Printf(\"index = %d, value = %c\\n\", index, value)\n}\n\nfor _, value := range name {\n    fmt.Printf(\"value = %c\\n\", value)\n}\n\nfor index := range name {\n    fmt.Printf(\"index = %d\\n\", index)\n    fmt.Printf(\"value = %c\\n\", name[index])\n}\n\n注意： \n\n\n\n\n使用break和continue来退出循环。\ncontinue 用于跳过当前循环的剩余语句，然后继续执行下一次循环。\nbreak 用于跳出当前循环，执行循环之后的语句。\n\n\n\n\n\ngoto语句可以让我们的代码跳转到指定的代码块中运行，但是不建议使用goto语句，因为goto语句会让代码的可读性变差，而且也会让代码的维护变得困难。\ngo语言中的goto语句可以实现程序的跳转，goto语句使用最多的是程序的错误处理，当程序处理错误时，跳转到相应的标签处统一处理。\n\nfor i := 0; i &lt; 10; i++ {\n    for j := 0; j &lt; 10; j++ {\n        if j == 5 {\n            goto over\n        }\n        fmt.Println(i, j)\n    }\n}\n\n//任意代码块\nover:\n    fmt.Println(\"over\")\n//代码直接跳转到over代码块中运行\n\n\n\n\nswitch语句用于根据不同的条件执行不同的代码块，它可以替代多个if else语句。\n提升代码的可读性\n\n//基础写法\nswitch var1{\n    case val1:\n       ...\n    case val2:\n       ...\n    default:\n       ...\n}\n\n//举例--中文的星期几，输出对应的英文\nday := \"星期一\"\n\nswitch dat{\n    case \"星期一\":\n        fmt.Println(\"Monday\")\n    case \"星期二\":\n        fmt.Println(\"Tuesday\")\n    case \"星期三\":\n        fmt.Println(\"Wednesday\")\n    case \"星期四\":\n        fmt.Println(\"Thursday\")\n    case \"星期五\":\n        fmt.Println(\"Friday\")\n    case \"星期六\":\n        fmt.Println(\"Saturday\")\n    case \"星期日\":\n        fmt.Println(\"Sunday\")\n    default:\n        fmt.Println(\"Unknown\")\n}\n\nsiwtch {\n    case day == \"星期一\":\n        fmt.Println(\"Monday\")\n    case day == \"星期二\":\n        fmt.Println(\"Tuesday\")\n    case day == \"星期三\":\n        fmt.Println(\"Wednesday\")\n    case day == \"星期四\":\n        fmt.Println(\"Thursday\")\n    case day == \"星期五\":\n        fmt.Println(\"Friday\")\n    case day == \"星期六\":\n        fmt.Println(\"Saturday\")\n    case day == \"星期日\":\n        fmt.Println(\"Sunday\")\n    default:\n        fmt.Println(\"Unknown\")\n}\n\nscore := 90\n\nswitch {\n    case score &gt;= 90:\n        fmt.Println(\"A\")\n    case score &gt;= 80:\n        fmt.Println(\"B\")\n    case score &gt;= 70:\n        fmt.Println(\"C\")\n    case score &gt;= 60:\n        fmt.Println(\"D\")\n    default:\n        fmt.Println(\"E\")\n}\n\n注意：Go语言的switch语句不需要break关键字来终止每个case。如果不使用break，执行完一个case后，程序会自动退出switch语句。"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（6）.html#if条件判断",
    "href": "content/learning-notes/golang/entries/golang学习记录（6）.html#if条件判断",
    "title": "golang学习记录（6）",
    "section": "",
    "text": "个其他语言差不多，go中if语句后面的条件判断可以加括号，也可以不加，通常不写括号，但是如果条件比较复杂，建议加上括号。\nage := 10\n//1、加括号\nif age &gt; 18 {\n    fmt.Println(\"你已经成年了\")\n}\n//2、不加括号\nif (age &gt; 18){\n    fmt.Println(\"你已经成年了\")\n}\n\n\n\nage := 10\nif age &gt; 18 {\n    fmt.Println(\"你已经成年了\")\n} else {\n    fmt.Println(\"你还没有成年\")\n}\n\n// else if\nif age &gt; 20 {\n    fmt.Println(\"你已经成年了\")\n} else if a18 &gt; 16 {\n    fmt.Println(\"你已经成年了\")\n} else {\n    fmt.Println(\"你还没有成年\")\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（6）.html#for循环",
    "href": "content/learning-notes/golang/entries/golang学习记录（6）.html#for循环",
    "title": "golang学习记录（6）",
    "section": "",
    "text": "go中没有while循环，只有for循环\n\n\n\n//基础写法\nfor i := 0; i &lt; 10; i++ {\n    fmt.Println(i)\n}\n//注意不能加括号\n\n//for循环代替while循环\nvar i int = 0\nfor {\n    if i &gt; 10 {\n        break\n    }\n    fmt.Println(i)\n    i++\n}\n\n\n\n\n\nfor i := 1; i &lt;= 1--; i++{\n    if i % 2 == 0{\n        fmt.Println(i)\n    }\n}\n\n\n\nfor i := 1; i &lt;= 9; i++{\n    for j := 1; j &lt;= i; j++{\n        fmt.Printf(\"%d * %d = %d\\t\", j, i, i * j)\n    }\n    fmt.Println()\n}\n\n\n\n\n\nfor range 主要对于数组、切片、字符串、map、通道等进行迭代循环，返回的是索引和值。\n\nname := \"hello go, hello world\"\n\nfor index, value := range name {\n    fmt.Printf(\"index = %d, value = %c\\n\", index, value)\n}\n\nfor _, value := range name {\n    fmt.Printf(\"value = %c\\n\", value)\n}\n\nfor index := range name {\n    fmt.Printf(\"index = %d\\n\", index)\n    fmt.Printf(\"value = %c\\n\", name[index])\n}\n\n注意： \n\n\n\n\n使用break和continue来退出循环。\ncontinue 用于跳过当前循环的剩余语句，然后继续执行下一次循环。\nbreak 用于跳出当前循环，执行循环之后的语句。"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（6）.html#goto语句",
    "href": "content/learning-notes/golang/entries/golang学习记录（6）.html#goto语句",
    "title": "golang学习记录（6）",
    "section": "",
    "text": "goto语句可以让我们的代码跳转到指定的代码块中运行，但是不建议使用goto语句，因为goto语句会让代码的可读性变差，而且也会让代码的维护变得困难。\ngo语言中的goto语句可以实现程序的跳转，goto语句使用最多的是程序的错误处理，当程序处理错误时，跳转到相应的标签处统一处理。\n\nfor i := 0; i &lt; 10; i++ {\n    for j := 0; j &lt; 10; j++ {\n        if j == 5 {\n            goto over\n        }\n        fmt.Println(i, j)\n    }\n}\n\n//任意代码块\nover:\n    fmt.Println(\"over\")\n//代码直接跳转到over代码块中运行"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（6）.html#switch语句",
    "href": "content/learning-notes/golang/entries/golang学习记录（6）.html#switch语句",
    "title": "golang学习记录（6）",
    "section": "",
    "text": "switch语句用于根据不同的条件执行不同的代码块，它可以替代多个if else语句。\n提升代码的可读性\n\n//基础写法\nswitch var1{\n    case val1:\n       ...\n    case val2:\n       ...\n    default:\n       ...\n}\n\n//举例--中文的星期几，输出对应的英文\nday := \"星期一\"\n\nswitch dat{\n    case \"星期一\":\n        fmt.Println(\"Monday\")\n    case \"星期二\":\n        fmt.Println(\"Tuesday\")\n    case \"星期三\":\n        fmt.Println(\"Wednesday\")\n    case \"星期四\":\n        fmt.Println(\"Thursday\")\n    case \"星期五\":\n        fmt.Println(\"Friday\")\n    case \"星期六\":\n        fmt.Println(\"Saturday\")\n    case \"星期日\":\n        fmt.Println(\"Sunday\")\n    default:\n        fmt.Println(\"Unknown\")\n}\n\nsiwtch {\n    case day == \"星期一\":\n        fmt.Println(\"Monday\")\n    case day == \"星期二\":\n        fmt.Println(\"Tuesday\")\n    case day == \"星期三\":\n        fmt.Println(\"Wednesday\")\n    case day == \"星期四\":\n        fmt.Println(\"Thursday\")\n    case day == \"星期五\":\n        fmt.Println(\"Friday\")\n    case day == \"星期六\":\n        fmt.Println(\"Saturday\")\n    case day == \"星期日\":\n        fmt.Println(\"Sunday\")\n    default:\n        fmt.Println(\"Unknown\")\n}\n\nscore := 90\n\nswitch {\n    case score &gt;= 90:\n        fmt.Println(\"A\")\n    case score &gt;= 80:\n        fmt.Println(\"B\")\n    case score &gt;= 70:\n        fmt.Println(\"C\")\n    case score &gt;= 60:\n        fmt.Println(\"D\")\n    default:\n        fmt.Println(\"E\")\n}\n\n注意：Go语言的switch语句不需要break关键字来终止每个case。如果不使用break，执行完一个case后，程序会自动退出switch语句。"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（4）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（4）.html",
    "title": "golang学习记录（4）",
    "section": "",
    "text": "go的基础数据类型有bool、string、int、float、byte、rune、uint、int8、int16、int32、int64、uint8、uint16、uint32、uint64、float32、float64等\n具体可以分成以下几种：\n\n\n\n\n\n\n\ntrue 和 false\n\n\n\n\n\n\n多种数值考虑到了空间要求高的情况\n\nint8\nint16\nint32\nint64\nuint8\nuint16\nuint32\nuint64\nint\nuint\n\nint和uint的大小取决于操作系统架构，操作系统时32位就是32位，操作系统是64位就是64位\n其他类型具体介绍如下： \n\n\n\n\nfloat32\nfloat64\n\n分别表示32位浮点数和64位浮点数\n\n\n\n在go中没有复数类型，但是可以使用complex64和complex128类型来表示复数。\ngo中也有专门的包处理复数\nimport \"math/cmplx\"\n\n\n\ngo中没有char类型，只有byte类型，byte是uint8的别名，byte类型用于表示一个字节（8bit），通常用于处理二进制数据和文本数据。\nvar b byte = 'A'\n\n\n\nrune是int32的别名，rune类型用于表示一个Unicode字符，通常用于处理Unicode文本数据。\nvar r rune = '中'\n\n\n\n\n单个字符一般用byte进行存储\n字符串就是string\nvar name string\nname = \"aorange\"\n\n\n\n\n在go中定义了byte，他是uint8的别名，通过这种别名的方式确定byte用于字符，而不是将uint8既用于字符又用于整数。\nvar a int8 = 12\nvar b = uint8(a)\n\nvar f float32 = 12.3\nvar g = int(f)\n\n// 字符转换为数字，这种情况可能会出错，有err返回\nvar isrt = \"12\"\nvar i, err = strconv.Atoi(isrt)\nif err!= nil {\n    fmt.Println(\"转换失败\")\n}\n\n//数字转字符串类型，理论上不会出错，没有err返回\nvar i = 12\nvar s = strconv.Itoa(i)\n\n\n\n将字符串转成folat32，或者bool类型 将其他类型转成字符串类型\nvar s = \"12.3\"\nvar f, err = strconv.ParseFloat(s, 32) // 32表示32位浮点数\n\n//ParseInt进行进制转换\nparseInt , err := strconv.ParseInt(s: \"12\", 8, 64)//8表示8进制，64表示64位\n//此时输出结果为10进制的10\n\n//有关bool类型的转换\nparseBool, err := strconv.ParseBool(s: \"true\")\n//转换失败parseBool结果为零值，即false，err不为空\n//true，t，T，y，Y，1，\n//false，f，F，n，N，0\n//其他结果转换可能失败\n\n//基本类型转字符串\nstrconv.FmoatBool(b: true)\nfmt.Println(b)\n//其他的转换可以找源码看看，都差不多，都是用的strconv.FormatXXX\n转换失败测试如下： \n\n\n\n\n这玩意需要到了就直接查，常用的跟C++差不多\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n对性能要求高的情况下考虑与运算，与运算比加减乘除运算快很多\n\n\n\n\n\n\n\n具体优先级如下： \n\n\n基础还是要多使用，熟悉就好了，各种语言关于数据的类型和转换都有相似之处"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（4）.html#数值浮点数和字符类型",
    "href": "content/learning-notes/golang/entries/golang学习记录（4）.html#数值浮点数和字符类型",
    "title": "golang学习记录（4）",
    "section": "",
    "text": "true 和 false\n\n\n\n\n\n\n多种数值考虑到了空间要求高的情况\n\nint8\nint16\nint32\nint64\nuint8\nuint16\nuint32\nuint64\nint\nuint\n\nint和uint的大小取决于操作系统架构，操作系统时32位就是32位，操作系统是64位就是64位\n其他类型具体介绍如下： \n\n\n\n\nfloat32\nfloat64\n\n分别表示32位浮点数和64位浮点数\n\n\n\n在go中没有复数类型，但是可以使用complex64和complex128类型来表示复数。\ngo中也有专门的包处理复数\nimport \"math/cmplx\"\n\n\n\ngo中没有char类型，只有byte类型，byte是uint8的别名，byte类型用于表示一个字节（8bit），通常用于处理二进制数据和文本数据。\nvar b byte = 'A'\n\n\n\nrune是int32的别名，rune类型用于表示一个Unicode字符，通常用于处理Unicode文本数据。\nvar r rune = '中'\n\n\n\n\n单个字符一般用byte进行存储\n字符串就是string\nvar name string\nname = \"aorange\""
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（4）.html#基本类型的转换",
    "href": "content/learning-notes/golang/entries/golang学习记录（4）.html#基本类型的转换",
    "title": "golang学习记录（4）",
    "section": "",
    "text": "在go中定义了byte，他是uint8的别名，通过这种别名的方式确定byte用于字符，而不是将uint8既用于字符又用于整数。\nvar a int8 = 12\nvar b = uint8(a)\n\nvar f float32 = 12.3\nvar g = int(f)\n\n// 字符转换为数字，这种情况可能会出错，有err返回\nvar isrt = \"12\"\nvar i, err = strconv.Atoi(isrt)\nif err!= nil {\n    fmt.Println(\"转换失败\")\n}\n\n//数字转字符串类型，理论上不会出错，没有err返回\nvar i = 12\nvar s = strconv.Itoa(i)"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（4）.html#format进行格式转换",
    "href": "content/learning-notes/golang/entries/golang学习记录（4）.html#format进行格式转换",
    "title": "golang学习记录（4）",
    "section": "",
    "text": "将字符串转成folat32，或者bool类型 将其他类型转成字符串类型\nvar s = \"12.3\"\nvar f, err = strconv.ParseFloat(s, 32) // 32表示32位浮点数\n\n//ParseInt进行进制转换\nparseInt , err := strconv.ParseInt(s: \"12\", 8, 64)//8表示8进制，64表示64位\n//此时输出结果为10进制的10\n\n//有关bool类型的转换\nparseBool, err := strconv.ParseBool(s: \"true\")\n//转换失败parseBool结果为零值，即false，err不为空\n//true，t，T，y，Y，1，\n//false，f，F，n，N，0\n//其他结果转换可能失败\n\n//基本类型转字符串\nstrconv.FmoatBool(b: true)\nfmt.Println(b)\n//其他的转换可以找源码看看，都差不多，都是用的strconv.FormatXXX\n转换失败测试如下："
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（4）.html#运算符和表达式",
    "href": "content/learning-notes/golang/entries/golang学习记录（4）.html#运算符和表达式",
    "title": "golang学习记录（4）",
    "section": "",
    "text": "这玩意需要到了就直接查，常用的跟C++差不多\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n对性能要求高的情况下考虑与运算，与运算比加减乘除运算快很多\n\n\n\n\n\n\n\n具体优先级如下： \n\n\n基础还是要多使用，熟悉就好了，各种语言关于数据的类型和转换都有相似之处"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（2）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（2）.html",
    "title": "golang学习记录（2）",
    "section": "",
    "text": "首先要创建golang开发的目录，可以创建成下面的形式 &gt; go_project &gt; - src &gt; * go_code &gt; * project01 &gt; * main &gt; * hello.go &gt; * package &gt; * project02 &gt; * main &gt; * package\n其中hello.go就是一个简单的go程序，代码如下：\npackage main\nimport \"fmt\"\nfunc main(){\n    fmt.Println(\"hello world!\")\n}\n说明： （1）go的文件后缀就是“.go”，在go中，一个文件就是一个包，一个包可以包含多个文件，但是一个文件只能包含一个包。 （2）package main 表示当前文件所在的包名，必须是main包，否则无法执行。 （3）在go中，每个文件都必须归属于一个包 （4）import “fmt” 表示引入fmt包，fmt包是go语言标准库中的一个包，提供了格式化输入输出的功能。引入后，就可以使用fmt包的函数，比如fmt.Println()。 （5）func main() 表示main函数，是程序的入口函数，程序从main函数开始执行。其中func是关键字，表示一个函数，main是函数名，是一个主函数，是程序的入口。 （6）fmt.Println(“hello world!”)表示调用fmt包中的Println函数，打印输出hello world!。\n\n\n\n\n\n首先，我们要写完一个go程序\n然后，要对写完的程序进行编译，生成一个可执行文件，使用“go build”命令\ngo build hello.go\n最后，执行可执行文件，得到运行结果。\n同时，也可以直接使用“go run”命令，直接运行go程序，不需要编译，也不需要生成可执行文件。但是，每次运行都会重新编译，效率较低，并且执行时间较长。\ngo run hello.go\n总的来说，go语言的执行流程是：编写代码 -&gt; 编译生成可执行文件 -&gt; 运行可执行文件。\n\n前者运行时间短 后者运行时间长 实际开发中用到的是前者，后者一般用于测试。\n\n\n\n（1）go语言是编译型语言，需要先编译成可执行文件，然后才能运行。\n（2）如果先编译生成了可执行文件，可以将可执行文件拷贝到其他机器上，直接运行。\n（3）如果使用 go run 命令运行源码，想要在另一台机器上运行，需要先安装go环境，否则无法执行\n（4） 在编译时，编译器会将程序运行依赖的库文件包含在可执行文件中，所以可执行文件会变得很大，且能够独立运行。\n\n\n\n\n\n\n通过编译器将go源码编译成二进制文件\n在编译时指定生成的文件名：go build -o test.exe hello.go，其中在Windows下生成文件的后缀必须是exe，在Linux下生成文件的后缀可以是exe或者没有后缀。\n如果源码中没有错误，能够正常运行编译，如果源码中有错，会在错误的那行报错，并且编译失败。\n\n\n\n1、生成可执行文件，然后运行。\n2、直接使用go run命令运行，不需要编译，不需要生成可执行文件。\n\n\n\n\ngolang源文件以go为扩展名，编译后生成的可执行文件以exe为扩展名。\ngo程序的执行入口是main函数\ngo语言严格区分大小写\ngo方法由一条条语句构成，语句后面不需要分号\n在go语言中，一行代表一条语句结束。一行就写一条语句，go编译器是一行行进行编译的，一行中不能写多条语句。\ngo语言中定义的变量或者import的包如果没有使用到，代码就不能通过编译（提升代码的性能）\n括号是成对出现的，缺少会编译错误。\n\n\n\n\n\n个制表位，实现对齐功能\n换行符与\n\\ 一个反斜杠字符\n\" 一个双引号字符\n个回车符\n\n\n\n\n\n1、单行注释：//\n2、多行注释（块注释）：/* */\n\n\n\n1、 尽量使用行注释，注释方法和语句\n2、要有正确的缩进和空行（空白），shift+tab向左缩进，tab向右缩进，或者使用gofmt命令进行格式化，例如：gofmt -w main.go(可以将格式化后的内容重新写入文件)，gofmt main.go(可以将格式化后的内容输出到终端，不能写入文件)\n3、 运算符两边加空格\n4、函数的大括号 \n5、 关键字和操作符之间加空格\n6、 函数名、变量名、常量名、结构体字段名使用驼峰式命名法\n7、一行不要超过80个字符，超过80个字符需要换行\n\n\n\n\n官方网站：运行和学习\n中文编程指南：中文指南，也有其它语言的\n官方的包：关于包的使用和说明\n\n在官网可以查看代码的运行结果 tour run 可以运行代码\n\n\n\n\n什么是API？\n应用程序编程接口（Application Programming Interface），就是一个函数\n\nGolang提供了大量的标准库\nGolang中文网 : 中文关于包的介绍和使用说明\n在Go中：包-&gt;源文件-&gt;函数 \n要使用函数就直接import导入 ### Golang开发常见错误和解决方法\n注释的目的是提升可阅读性，让代码更容易理解\n1、显示找不到文件 源文件名写错、不存在或者当前的路径错误。\n2、语法错误 违反语法规则，括号，引号匹配失败海诺这拼错单词。 通过查看错误提示信息，找到错误的位置，然后修改。\n注意：“1”和”l”在编程的时候比较难区分"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（2）.html#golang开发基础",
    "href": "content/learning-notes/golang/entries/golang学习记录（2）.html#golang开发基础",
    "title": "golang学习记录（2）",
    "section": "",
    "text": "首先要创建golang开发的目录，可以创建成下面的形式 &gt; go_project &gt; - src &gt; * go_code &gt; * project01 &gt; * main &gt; * hello.go &gt; * package &gt; * project02 &gt; * main &gt; * package\n其中hello.go就是一个简单的go程序，代码如下：\npackage main\nimport \"fmt\"\nfunc main(){\n    fmt.Println(\"hello world!\")\n}\n说明： （1）go的文件后缀就是“.go”，在go中，一个文件就是一个包，一个包可以包含多个文件，但是一个文件只能包含一个包。 （2）package main 表示当前文件所在的包名，必须是main包，否则无法执行。 （3）在go中，每个文件都必须归属于一个包 （4）import “fmt” 表示引入fmt包，fmt包是go语言标准库中的一个包，提供了格式化输入输出的功能。引入后，就可以使用fmt包的函数，比如fmt.Println()。 （5）func main() 表示main函数，是程序的入口函数，程序从main函数开始执行。其中func是关键字，表示一个函数，main是函数名，是一个主函数，是程序的入口。 （6）fmt.Println(“hello world!”)表示调用fmt包中的Println函数，打印输出hello world!。\n\n\n\n\n\n首先，我们要写完一个go程序\n然后，要对写完的程序进行编译，生成一个可执行文件，使用“go build”命令\ngo build hello.go\n最后，执行可执行文件，得到运行结果。\n同时，也可以直接使用“go run”命令，直接运行go程序，不需要编译，也不需要生成可执行文件。但是，每次运行都会重新编译，效率较低，并且执行时间较长。\ngo run hello.go\n总的来说，go语言的执行流程是：编写代码 -&gt; 编译生成可执行文件 -&gt; 运行可执行文件。\n\n前者运行时间短 后者运行时间长 实际开发中用到的是前者，后者一般用于测试。\n\n\n\n（1）go语言是编译型语言，需要先编译成可执行文件，然后才能运行。\n（2）如果先编译生成了可执行文件，可以将可执行文件拷贝到其他机器上，直接运行。\n（3）如果使用 go run 命令运行源码，想要在另一台机器上运行，需要先安装go环境，否则无法执行\n（4） 在编译时，编译器会将程序运行依赖的库文件包含在可执行文件中，所以可执行文件会变得很大，且能够独立运行。\n\n\n\n\n\n\n通过编译器将go源码编译成二进制文件\n在编译时指定生成的文件名：go build -o test.exe hello.go，其中在Windows下生成文件的后缀必须是exe，在Linux下生成文件的后缀可以是exe或者没有后缀。\n如果源码中没有错误，能够正常运行编译，如果源码中有错，会在错误的那行报错，并且编译失败。\n\n\n\n1、生成可执行文件，然后运行。\n2、直接使用go run命令运行，不需要编译，不需要生成可执行文件。\n\n\n\n\ngolang源文件以go为扩展名，编译后生成的可执行文件以exe为扩展名。\ngo程序的执行入口是main函数\ngo语言严格区分大小写\ngo方法由一条条语句构成，语句后面不需要分号\n在go语言中，一行代表一条语句结束。一行就写一条语句，go编译器是一行行进行编译的，一行中不能写多条语句。\ngo语言中定义的变量或者import的包如果没有使用到，代码就不能通过编译（提升代码的性能）\n括号是成对出现的，缺少会编译错误。\n\n\n\n\n\n个制表位，实现对齐功能\n换行符与\n\\ 一个反斜杠字符\n\" 一个双引号字符\n个回车符\n\n\n\n\n\n1、单行注释：//\n2、多行注释（块注释）：/* */\n\n\n\n1、 尽量使用行注释，注释方法和语句\n2、要有正确的缩进和空行（空白），shift+tab向左缩进，tab向右缩进，或者使用gofmt命令进行格式化，例如：gofmt -w main.go(可以将格式化后的内容重新写入文件)，gofmt main.go(可以将格式化后的内容输出到终端，不能写入文件)\n3、 运算符两边加空格\n4、函数的大括号 \n5、 关键字和操作符之间加空格\n6、 函数名、变量名、常量名、结构体字段名使用驼峰式命名法\n7、一行不要超过80个字符，超过80个字符需要换行\n\n\n\n\n官方网站：运行和学习\n中文编程指南：中文指南，也有其它语言的\n官方的包：关于包的使用和说明\n\n在官网可以查看代码的运行结果 tour run 可以运行代码\n\n\n\n\n什么是API？\n应用程序编程接口（Application Programming Interface），就是一个函数\n\nGolang提供了大量的标准库\nGolang中文网 : 中文关于包的介绍和使用说明\n在Go中：包-&gt;源文件-&gt;函数 \n要使用函数就直接import导入 ### Golang开发常见错误和解决方法\n注释的目的是提升可阅读性，让代码更容易理解\n1、显示找不到文件 源文件名写错、不存在或者当前的路径错误。\n2、语法错误 违反语法规则，括号，引号匹配失败海诺这拼错单词。 通过查看错误提示信息，找到错误的位置，然后修改。\n注意：“1”和”l”在编程的时候比较难区分"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（13）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（13）.html",
    "title": "golang学习记录（13）",
    "section": "",
    "text": "go test命令是一个按照一定约定和组织的测试代码驱动程序\n在包目录中，所有以_test.go结尾的源码文件都会被go test运行到\n我们写的 _test.go源码文件不用担心内容过多，因为go test命令不会将这些测试文件打包到最后的可执行文件\n\n\n在实际应用中，test文件有四类：\n1、Test开头的：功能测试\n2、Benchmark开头的：性能测试\n3、Example开头的：模糊测试\n4、TestMain开头的：单元测试\n\n\n\n下面举一个单元测试的例子：\n在包目录中有三个go文件，分别是：\n1、add.go\n2、add_test.go\n3、main.go\n\n在add.go中定义了一个Add函数，用来实现两个整数的相加：\n在add_test.go中首先导入”testing”包，然后定义了一个TestAdd函数，用来测试Add函数的正确性，并作出相应的出错处理：\nimport \"testing\"\n\nfunc TestAdd(t *testing.T){\n    re := add(1,2)\n    if re!= 3{\n        t.Errorf(\"add(1,2) = %d; want 3\", re)\n    }\n}\n之后对add_test.go文件执行go test命令，即可进行单元测试，查看测试结果\n\n\n\n\n在实际应用中，我们可能会遇到一些耗时的单元测试用例，我们可以使用t.Skip()函数来跳过这些耗时的单元测试用例\n在执行测试文件的过程中，使用 go test -short命令可以查看测试结果，其中 -short命令会跳过所有耗时的单元测试用例\n耗时的单元测试用例是有自己定义的\n\n下面是一个使用跳过单元测试的例子：\nfunc TestAdd(t *testing.T){\n    if testing.Short(){\n        t.Skip(\"skip this test\")\n    }\n    // 下面是执行不到的\n    re := add(1,2)\n    if re!= 3{\n        t.Errorf(\"add(1,2) = %d; want 3\", re)\n    }\n}\ntesting中的short相当于采用了两种模式，供用户选择。\n\n\n\n\n\n在实际测试的的时候，测试用例可能不止一组，一个一个测试非常耗时，go中提供了一种基于表格驱动测试的方式，它可以一次性测试多组数据，提高测试效率\n\n下面是一个基于表格驱动测试的例子：\nimport \"testing\"\n\nfunc TestAdd(t *testing.T){\n    var tests = []struct{\n        a int\n        b int\n        want int\n    }{\n        {1,2,3},\n        {2,3,5},\n        {3,4,7},\n    }\n\n    for _, tt := range tests{\n        re := add(tt.a, tt.b)\n        if re!= tt.want{\n            t.Errorf(\"add(%d, %d) = %d; want %d\", tt.a, tt.b, re, tt.want)\n        }\n    }\n}\n\n\n\n\n在一些核心函数中对性能有要求，我们可以使用benchmark性能测试来测试函数的性能\n同样，性能测试函数也在”testing”包中\n在应用过程中，性能测试函数的命名必须以Benchmark开头，后面跟上要测试的函数名\n性能测试函数的参数必须是*testing.B类型的指针\n在执行测试文件的过程中，使用 go test -bench命令可以查看测试结果，其中 -bench命令会执行所有的性能测试用例\n\n下面是一个关于单元性能测试的例子：\nimport \"testing\"\n\nfunc BenchmarkAdd(b *testing.B){\n    a := 123\n    b := 456\n    c := 579\n\n\n    for i:=0; i&lt;b.N; i++{\n        if actual := add(a,b); actual!= c{\n            fmt.Printf(\"add(%d, %d) = %d; want %d\", a, b, actual, c)\n    }\n}\n在进行性能测试过沉重还有一个常用的函数：b.ResetTimer()，它可以重置计时器，使得测试结果更加准确"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（13）.html#单元测试用例",
    "href": "content/learning-notes/golang/entries/golang学习记录（13）.html#单元测试用例",
    "title": "golang学习记录（13）",
    "section": "",
    "text": "go test命令是一个按照一定约定和组织的测试代码驱动程序\n在包目录中，所有以_test.go结尾的源码文件都会被go test运行到\n我们写的 _test.go源码文件不用担心内容过多，因为go test命令不会将这些测试文件打包到最后的可执行文件\n\n\n在实际应用中，test文件有四类：\n1、Test开头的：功能测试\n2、Benchmark开头的：性能测试\n3、Example开头的：模糊测试\n4、TestMain开头的：单元测试\n\n\n\n下面举一个单元测试的例子：\n在包目录中有三个go文件，分别是：\n1、add.go\n2、add_test.go\n3、main.go\n\n在add.go中定义了一个Add函数，用来实现两个整数的相加：\n在add_test.go中首先导入”testing”包，然后定义了一个TestAdd函数，用来测试Add函数的正确性，并作出相应的出错处理：\nimport \"testing\"\n\nfunc TestAdd(t *testing.T){\n    re := add(1,2)\n    if re!= 3{\n        t.Errorf(\"add(1,2) = %d; want 3\", re)\n    }\n}\n之后对add_test.go文件执行go test命令，即可进行单元测试，查看测试结果\n\n\n\n\n在实际应用中，我们可能会遇到一些耗时的单元测试用例，我们可以使用t.Skip()函数来跳过这些耗时的单元测试用例\n在执行测试文件的过程中，使用 go test -short命令可以查看测试结果，其中 -short命令会跳过所有耗时的单元测试用例\n耗时的单元测试用例是有自己定义的\n\n下面是一个使用跳过单元测试的例子：\nfunc TestAdd(t *testing.T){\n    if testing.Short(){\n        t.Skip(\"skip this test\")\n    }\n    // 下面是执行不到的\n    re := add(1,2)\n    if re!= 3{\n        t.Errorf(\"add(1,2) = %d; want 3\", re)\n    }\n}\ntesting中的short相当于采用了两种模式，供用户选择。"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（13）.html#基于表格驱动测试",
    "href": "content/learning-notes/golang/entries/golang学习记录（13）.html#基于表格驱动测试",
    "title": "golang学习记录（13）",
    "section": "",
    "text": "在实际测试的的时候，测试用例可能不止一组，一个一个测试非常耗时，go中提供了一种基于表格驱动测试的方式，它可以一次性测试多组数据，提高测试效率\n\n下面是一个基于表格驱动测试的例子：\nimport \"testing\"\n\nfunc TestAdd(t *testing.T){\n    var tests = []struct{\n        a int\n        b int\n        want int\n    }{\n        {1,2,3},\n        {2,3,5},\n        {3,4,7},\n    }\n\n    for _, tt := range tests{\n        re := add(tt.a, tt.b)\n        if re!= tt.want{\n            t.Errorf(\"add(%d, %d) = %d; want %d\", tt.a, tt.b, re, tt.want)\n        }\n    }\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（13）.html#benchmark性能测试",
    "href": "content/learning-notes/golang/entries/golang学习记录（13）.html#benchmark性能测试",
    "title": "golang学习记录（13）",
    "section": "",
    "text": "在一些核心函数中对性能有要求，我们可以使用benchmark性能测试来测试函数的性能\n同样，性能测试函数也在”testing”包中\n在应用过程中，性能测试函数的命名必须以Benchmark开头，后面跟上要测试的函数名\n性能测试函数的参数必须是*testing.B类型的指针\n在执行测试文件的过程中，使用 go test -bench命令可以查看测试结果，其中 -bench命令会执行所有的性能测试用例\n\n下面是一个关于单元性能测试的例子：\nimport \"testing\"\n\nfunc BenchmarkAdd(b *testing.B){\n    a := 123\n    b := 456\n    c := 579\n\n\n    for i:=0; i&lt;b.N; i++{\n        if actual := add(a,b); actual!= c{\n            fmt.Printf(\"add(%d, %d) = %d; want %d\", a, b, actual, c)\n    }\n}\n在进行性能测试过沉重还有一个常用的函数：b.ResetTimer()，它可以重置计时器，使得测试结果更加准确"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（11）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（11）.html",
    "title": "golang学习记录（11）",
    "section": "",
    "text": "go语言中interface是一种非常重要的类型，是非常重要的组成部分\n\n\n\n\n鸭子类型\n当一只鸟走起来像鸭子，游泳起来像鸭子，叫起来也想鸭子，那这只鸟就是鸭子\n鸭子类型强调的是事物的方法，而不是内部的结构\n也就是说，只要一个对象实现了接口的所有方法，那么这个对象就可以被认为是实现了这个接口，就能将这个对象作为这个接口的实例\n\n\n\n\n\n接口的定义需要用到type和interface关键字，具体的定义格式如下：\n\ntype 接口名 interface{\n    方法名1(参数列表) 返回值列表\n    方法名2(参数列表) 返回值列表\n   ...\n}\n下面是一个例子：\ntype Duck interface{\n    Gaga()\n    Walk()\n    Swimming()\n}\n\ntype pskDuck struct{\n    legs int\n}\n\nfunc (pd *pskDuck) Gaga(){\n    fmt.Println(\"嘎嘎嘎\")\n}\n\nfunc (pd *pskDuck) Walk(){\n    fmt.Println(\"走\")\n}\n\nfunc (pd *pskDuck) Swimming(){\n    fmt.Println(\"游泳\")\n}\n\nfunc main(){\n    var duck Duck = &pskDuck{}\n    duck.Gaga()\n    duck.Walk()\n    duck.Swimming()\n}\n\n\n\n\n在实际的应用场景中，接口不应该写的太大，一般一个接口只实现一个方法\n\ntype Duck interface{\n    Gaga()\n}\n\ntype Duck2 interface{\n    Walk()\n}\n\ntype Duck3 interface{\n    Swimming()\n}\n\ntype pskDuck struct{}\n、\nfunc (pd *pskDuck) Gaga(){\n    fmt.Println(\"嘎嘎嘎\")\n}\n\nfunc (pd *pskDuck) Walk(){\n    fmt.Println(\"走\")\n}\n\nfunc (pd *pskDuck) Swimming(){\n    fmt.Println(\"游泳\")\n}\n\nfunc main(){\n    var duck Duck = &pskDuck{}\n    var duck2 Duck2 = &pskDuck{}\n}\n\n在上面的例子中，pskDuck实现了Duck、Duck2、Duck3三个接口，但是在main函数中，只声明了Duck接口，但是却可以将pskDuck的实例赋值给Duck接口，这是因为pskDuck实现了Duck接口的所有方法，所以可以将pskDuck的实例赋值给Duck接口\n接口也可以作为结构体的参数\n接口的使用非常灵活\n代码的解耦\n一个类型实现多个接口。一个接口实现多个类型\n……\n\n\n\n\n\n断言\n\n举个例子，做一个加法计算器：\nfunc add(a, b interface{}) interface{}{\n    switch a.(type){\n    case int:\n        ai, _ := a.(int)\n        bi, _ := b.(int)\n        return ai + bi\n\n    case int32:\n        ai, _ := a.(int32)\n        bi, _ := b.(int32)\n        return ai + bi\n    \n\n    case float32:\n        ai, _ := a.(float32)\n        bi, _ := b.(float32)\n        return ai + bi\n    \n    //……\n\n    default:\n        return 0\n    }\n}\n\n\nfunc main(){\n    fmt.Println(add(1, 2))\n    fmt.Println(add(1, 3))\n    fmt.Println(add(1.0, 2.0))\n}\n\n\n\n\n接口嵌套达到代码复用的目的\n\ntype MyWriter interface{\n    Write(string)\n}\n\ntype MyReader interface{\n    Reader() string\n}\n\ntype MyReaderWriter interface{\n    MyReader\n    MyWriter\n    ReadWriter()\n}\n\ntype SreadWriter struct{}\n\nfunc (srw *SreadWriter) Read(){\n    fmt.Println(\"read\")\n}\n\nfunc (srw *SreadWriter) Write(){\n    fmt.Println(\"write\")\n}\n\nfunc (srw *SreadWriter) ReadWriter(){\n    fmt.Println(\"readWriter\")\n}\n\nfunc main(){\n    var mrw MyReaderWriter = &SreadWriter{}\n    mrw.Read()\n\n}\n\n\n\n\nslice不能作为接口的参数，因为slice是一个引用类型，但是接口是一个值类型，所以不能将slice作为接口的参数，但是可以将slice的指针作为接口的参数\n\nfunc mPrint(data ... interface{}){\n    for _, value := range data{\n        fmt.Println(value)\n    }\n}\n\nfunc main(){\n    //这样是支持的\n    var data = []interface{}{\n        \"aaaaa\",\n        19,\n        1800.00,\n    }\n    mPrint(data...)\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（11）.html#鸭子类型",
    "href": "content/learning-notes/golang/entries/golang学习记录（11）.html#鸭子类型",
    "title": "golang学习记录（11）",
    "section": "",
    "text": "鸭子类型\n当一只鸟走起来像鸭子，游泳起来像鸭子，叫起来也想鸭子，那这只鸟就是鸭子\n鸭子类型强调的是事物的方法，而不是内部的结构\n也就是说，只要一个对象实现了接口的所有方法，那么这个对象就可以被认为是实现了这个接口，就能将这个对象作为这个接口的实例"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（11）.html#接口的定义",
    "href": "content/learning-notes/golang/entries/golang学习记录（11）.html#接口的定义",
    "title": "golang学习记录（11）",
    "section": "",
    "text": "接口的定义需要用到type和interface关键字，具体的定义格式如下：\n\ntype 接口名 interface{\n    方法名1(参数列表) 返回值列表\n    方法名2(参数列表) 返回值列表\n   ...\n}\n下面是一个例子：\ntype Duck interface{\n    Gaga()\n    Walk()\n    Swimming()\n}\n\ntype pskDuck struct{\n    legs int\n}\n\nfunc (pd *pskDuck) Gaga(){\n    fmt.Println(\"嘎嘎嘎\")\n}\n\nfunc (pd *pskDuck) Walk(){\n    fmt.Println(\"走\")\n}\n\nfunc (pd *pskDuck) Swimming(){\n    fmt.Println(\"游泳\")\n}\n\nfunc main(){\n    var duck Duck = &pskDuck{}\n    duck.Gaga()\n    duck.Walk()\n    duck.Swimming()\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（11）.html#多接口实现",
    "href": "content/learning-notes/golang/entries/golang学习记录（11）.html#多接口实现",
    "title": "golang学习记录（11）",
    "section": "",
    "text": "在实际的应用场景中，接口不应该写的太大，一般一个接口只实现一个方法\n\ntype Duck interface{\n    Gaga()\n}\n\ntype Duck2 interface{\n    Walk()\n}\n\ntype Duck3 interface{\n    Swimming()\n}\n\ntype pskDuck struct{}\n、\nfunc (pd *pskDuck) Gaga(){\n    fmt.Println(\"嘎嘎嘎\")\n}\n\nfunc (pd *pskDuck) Walk(){\n    fmt.Println(\"走\")\n}\n\nfunc (pd *pskDuck) Swimming(){\n    fmt.Println(\"游泳\")\n}\n\nfunc main(){\n    var duck Duck = &pskDuck{}\n    var duck2 Duck2 = &pskDuck{}\n}\n\n在上面的例子中，pskDuck实现了Duck、Duck2、Duck3三个接口，但是在main函数中，只声明了Duck接口，但是却可以将pskDuck的实例赋值给Duck接口，这是因为pskDuck实现了Duck接口的所有方法，所以可以将pskDuck的实例赋值给Duck接口\n接口也可以作为结构体的参数\n接口的使用非常灵活\n代码的解耦\n一个类型实现多个接口。一个接口实现多个类型\n……"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（11）.html#接口与动态类型传参",
    "href": "content/learning-notes/golang/entries/golang学习记录（11）.html#接口与动态类型传参",
    "title": "golang学习记录（11）",
    "section": "",
    "text": "断言\n\n举个例子，做一个加法计算器：\nfunc add(a, b interface{}) interface{}{\n    switch a.(type){\n    case int:\n        ai, _ := a.(int)\n        bi, _ := b.(int)\n        return ai + bi\n\n    case int32:\n        ai, _ := a.(int32)\n        bi, _ := b.(int32)\n        return ai + bi\n    \n\n    case float32:\n        ai, _ := a.(float32)\n        bi, _ := b.(float32)\n        return ai + bi\n    \n    //……\n\n    default:\n        return 0\n    }\n}\n\n\nfunc main(){\n    fmt.Println(add(1, 2))\n    fmt.Println(add(1, 3))\n    fmt.Println(add(1.0, 2.0))\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（11）.html#接口嵌套",
    "href": "content/learning-notes/golang/entries/golang学习记录（11）.html#接口嵌套",
    "title": "golang学习记录（11）",
    "section": "",
    "text": "接口嵌套达到代码复用的目的\n\ntype MyWriter interface{\n    Write(string)\n}\n\ntype MyReader interface{\n    Reader() string\n}\n\ntype MyReaderWriter interface{\n    MyReader\n    MyWriter\n    ReadWriter()\n}\n\ntype SreadWriter struct{}\n\nfunc (srw *SreadWriter) Read(){\n    fmt.Println(\"read\")\n}\n\nfunc (srw *SreadWriter) Write(){\n    fmt.Println(\"write\")\n}\n\nfunc (srw *SreadWriter) ReadWriter(){\n    fmt.Println(\"readWriter\")\n}\n\nfunc main(){\n    var mrw MyReaderWriter = &SreadWriter{}\n    mrw.Read()\n\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（11）.html#接口与slice常见的错误",
    "href": "content/learning-notes/golang/entries/golang学习记录（11）.html#接口与slice常见的错误",
    "title": "golang学习记录（11）",
    "section": "",
    "text": "slice不能作为接口的参数，因为slice是一个引用类型，但是接口是一个值类型，所以不能将slice作为接口的参数，但是可以将slice的指针作为接口的参数\n\nfunc mPrint(data ... interface{}){\n    for _, value := range data{\n        fmt.Println(value)\n    }\n}\n\nfunc main(){\n    //这样是支持的\n    var data = []interface{}{\n        \"aaaaa\",\n        19,\n        1800.00,\n    }\n    mPrint(data...)\n}"
  },
  {
    "objectID": "content/learning-notes/deepL/entries/通过案例了解机器学习.html",
    "href": "content/learning-notes/deepL/entries/通过案例了解机器学习.html",
    "title": "通过案例了解机器学习",
    "section": "",
    "text": "A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E.\n\n基础概念\n近些年，人工智能飞速发展，我们经常听到人工智能、机器学习、深度学习和强化学习等名词。事实上，它们之间存在着密切的联系。\n\n人工智能\n人工智能（Artificial Intelligence, AI）是一个广泛的领域，可以从“能力”和“学科”两个方面对人工智能进行定义。从能力的角度看，人工智能是指用人工的方法在机器上实现的智能；从学科角度看，人工智能是一门研究如何构造智能机器或智能系统，使其能模拟、延伸和扩展人类智能的学科。\n\n\n机器学习\n机器学习（Machine Learning, ML）是AI的一个子集，它专注于开发算法和统计模型。机器学习是指在不需要明确编程的情况下，让计算机能够利用数据提高在某个任务上表现的算法。机器学习又可以分为监督学习、无监督学习、半监督学习和强化学习等。\n\n\n深度学习\n深度学习（Deep Learning, DL）是机器学习的一个子领域，它使用类似于人脑的神经网络结构，特别是具有多个层的深层神经网络，来学习复杂的模式和表示。\n\n\n强化学习\n强化学习（Reinforcement Learning, RL）是机器学习的一个分支，它专注于如何让智能体（agent）通过与环境的交互来学习最佳行为或策略，以最大化某种累积奖励。\n\n\n深度强化学习\n深度强化学习（Deep Reinforcement Learning, DRL）是深度学习和强化学习的结合，它使用深度神经网络作为智能体的大脑，以处理高维度的输入数据并学习复杂的策略。\n它们的关系可以大致总结为下图： \n\n\n\n课程基础\n\n机器学习\n机器学习最重要的是寻找到一个函数，让机器具备找到一个函数的能力。\n通常情况下，函数是非常复杂的，人难以自己写出，若是通过机器的力量自己找出有很多优势。\n机器学习寻找的函数通常是不同的，根据实际需求可以分成回归、分类和结构化学习等。\n\n\n回归（regression）\n假设要找的函数输出的是一个数值，或者称为一个标量（scalar），这种机器学习的任务称为回归。（根据历史数据和指标预测未来的一个数值）\n回归问题中，比较经典的是房价预测问题，这个问题在很多教程中都被作为例子，在Kaggle中可以进行实践。\n\n\n分类（classification）\n分类任务是让机器做选择题，函数的输出是从设定好的选项中选出一个选项当作输出。通常，在确定选项的过程中会牵扯到概率的计算，根据概率判断最可能的选项，常见的分类算法中都有概率的影子，个人感觉人工智能技术的发展确实离不开数学的支持。\n在分类问题中，比较常见的就是垃圾邮件判断的例子，判断邮件是否为垃圾邮件，这是一个二分类问题，除此之外还有多分类，AlphaGo下围棋就是从棋盘中找到最正确的选项，还有动物识别（猫、狗、鸟……）。\n\n\n结构化学习（structed learning）\n在这种情况下，机器学习并不只是要做出选择或者输出一个数字，而是要产生一个有结构的物体，比如画一张图、写一篇文章……近些年也逐渐得到更多应用。 在其他学习群里看到过一张有意思的图： \n结构化学习仍需要我们去探索。\n\n\n\n案例学习\n\n已有的数据是youtube后以往的信息，想要得到的明天可能观看的次数是多少 通过一个函数来实现这个过程\n\n机器学习找函数的过程\n1、写出一个带有未知参数的函数（这个函数基于我们的知识积累设置，这只是一个猜测），这个函数能够预测未来观看的次数\n\\[\ny=b+wx_1\n\\]\n\n其中\\(y\\)表示要预测的观看次数，\\(x_1\\) 表示前一天的观看人数\n\\(w\\)和\\(b\\)都表示未知的参数，都需要让机器从数据中学习\n\n2、定义损失函数（loss function）\n损失函数就是：在当前参数组合下，所有数据误差和的平均值（个人理解），公式如下：\n\\[  L= \\frac{1}{N} \\sum_n^{i=1} e_n \\]\n\n其中\\(e\\)表示误差\n可以采用预测值与目标值之间差的绝对值：\\(e = \\vert y - \\hat{y} \\vert\\)\n也可以采用差的平方: \\(e=(y-\\hat{y})^2\\)\n\n\n当采用绝对值，称为MAE（Mean Absolute Error）\n当采用平方，称为MSE（Mean Squared Error）\n\n除了上述的两种方式，还有一种计算loss的方式称为“交叉熵”\n计算的损失函数可以通过可视化方式呈现，如：热力图、等高线图……。下面是课程中采用的示例： \n3、优化（Optimization）\n优化的目的是让损失函数的值最小，如下公式：\n\\[\nw^*,b^*=min_{w,b}L\n\\]\n\n我们要找到让损失函数值最小的未知参数组合。\n\n常用的方式是梯度下降（gradient descent），通过梯度下降进行参数优化的过程如图： \n其中有几个非常重要的概念：\n斜率：斜率大于0表示loss在上升，斜率小于0表示loss在下降，等于0表示到达了一个极值点。\n学习率（learning rate)：\\(\\eta\\)可以理解为跨一步的大小，\\(\\eta\\)越高，跨一步越大，反之越小。\\(\\eta\\)可以经验决定。\n超参数（hyperparameter)：在机器学习过程中需要人为预先设定的参数。\n还有一个重要的点是关于\\(w\\)的更新： \\[\nw^1 \\leftarrow w^0 - \\eta \\frac{\\partial{l}}{\\partial{w}}\\vert_{w=w^0}\n\\]\n随着\\(w\\)的不断更新，理想状态下loss的斜率会成为0，如下图所示 \n当\\(w=w^T\\)时，斜率为0，当时此时loss并不是最低的\nlocal minima：局部最小\nglobal minima：全局最小\n\n在上图中，一个有意的现象，loss有负值，为什么loss可以是负的？\n因为loss是可以自己定义的，用上边的绝对值和平方计算肯定是正值，但是如果自己定义不同的方式可以是负值。\n\n4、最后\n找到合适的模型要观察数据、理解数据并进行试验，根据结果更新模型。"
  },
  {
    "objectID": "content/learning-notes/algorithm/entries/不定长滑动窗口-越长越合法+求最短+最小.html",
    "href": "content/learning-notes/algorithm/entries/不定长滑动窗口-越长越合法+求最短+最小.html",
    "title": "leetcode-灵神跟练-滑动窗口与双指针-不定长滑动窗口-越长越合法+求最短+最小",
    "section": "",
    "text": "定长滑动窗口-越长越合法/求最短/最小\n\n209. 长度最小的子数组\n\n题面\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n示例 1：\n输入：target = 7, nums = [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n示例 2：\n输入：target = 4, nums = [1,4,4]\n输出：1\n示例 3：\n输入：target = 11, nums = [1,1,1,1,1,1,1,1]\n输出：0\n提示：\n1 &lt;= target &lt;= 10^9\n1 &lt;= nums.length &lt;= 10^5\n1 &lt;= nums[i] &lt;= 10^4\n\n\n思路说明\n采用双指针变长滑动窗口的思路\n设定左指针，控制窗口大小，遍历数组的index作为右指针\n设置变量统计窗口内的数字和\n当数字和达到要求的时候 - 采用while循环 - 更新字数组的最小值 - 将左边的值排除窗口，更新数字和，同时将左指针向右移动 - 直到数字和不满足要求结束循环\n\n\n题解\n\n// 209.长度最小的子数组\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc minSubArrayLen(target int, nums []int) int {\n    ans, left := math.MaxInt, 0\n    cnt := 0\n\n    for i, num := range nums {\n        cnt += num\n        for cnt &gt;= target {\n            ans = min(ans, i-left+1)\n            cnt -= nums[left]\n            left += 1\n        }\n    }\n\n    if ans &gt; len(nums) {\n        return 0\n    } else {\n        return ans\n    }\n}\n\nfunc main() {\n    testCases := []struct {\n        nums   []int\n        target int\n    }{\n        {[]int{2, 3, 1, 2, 4, 3}, 7},\n        {[]int{1, 4, 4}, 4},\n        {[]int{1, 1, 1, 1, 1, 1, 1, 1}, 11},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(minSubArrayLen(testCase.target, testCase.nums))\n    }\n}\n\n\n\n\n2904. 最短且字典序最小的美丽子字符串\n\n题面\n给你一个二进制字符串 s 和一个正整数 k 。\n如果 s 的某个子字符串中 1 的个数恰好等于 k ，则称这个子字符串是一个 美丽子字符串 。\n令 len 等于 最短 美丽子字符串的长度。\n返回长度等于 len 且字典序 最小 的美丽子字符串。如果 s 中不含美丽子字符串，则返回一个 空 字符串。\n对于相同长度的两个字符串 a 和 b ，如果在 a 和 b 出现不同的第一个位置上，a 中该位置上的字符严格大于 b 中的对应字符，则认为字符串 a 字典序 大于 字符串 b 。\n例如，“abcd” 的字典序大于 “abcc” ，因为两个字符串出现不同的第一个位置对应第四个字符，而 d 大于 c 。\n示例 1：\n输入：s = “100011001”, k = 3\n输出：“11001”\n解释：示例中共有 7 个美丽子字符串：\n\n子字符串 “100011001” 。\n子字符串 “100011001” 。\n子字符串 “100011001” 。\n子字符串 “100011001” 。\n子字符串 “100011001” 。\n子字符串 “100011001” 。\n子字符串 “100011001” 。\n\n最短美丽子字符串的长度是 5 。\n长度为 5 且字典序最小的美丽子字符串是子字符串 “11001” 。\n示例 2：\n输入：s = “1011”, k = 2\n输出：“11”\n解释：示例中共有 3 个美丽子字符串： 1. 子字符串 “1011” 。 2. 子字符串 “1011” 。 3. 子字符串 “1011” 。\n最短美丽子字符串的长度是 2 。\n长度为 2 且字典序最小的美丽子字符串是子字符串 “11” 。\n示例 3：\n输入：s = “000”, k = 1\n输出：“”\n解释：示例中不存在美丽子字符串。\n提示：\n1 &lt;= s.length &lt;= 100\n1 &lt;= k &lt;= s.length\n\n\n思路说明\n我们要做的是找到一个子字符串，子字符串中1的数量为看，如果有多个答案，返回字典序最小的那个\n首先根据题目，当字符串中1的数量小于k的时候，会返回空字符串，直接返回\n然后初始化结果ans为输入字符串s，因为最差的结果就是s，所以设置为s\n之后设置cnt表示窗口内1的数量，left表示窗口的左边界，用循环的index表示右边界\n每次移动右边界之后 - 判断窗口内1的数量是不是达到要求 - 如果达到了，开始移动左边界，直到把最左边的1排出 - 这个过程中，左边可能有很多0，排出之后会减小子字符串的长度，所以不断更新子字符串以及左边界，这是还要注意子字符串长度相同选最小字典序的情况 - 这个过程通过while循环实现\n\n\n题解\n\n// 2904.最短且字典序最小的美丽子字符串\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc shortestBeautifulSubstring(s string, k int) string {\n    if strings.Count(s, \"1\") &lt; k {\n        return \"\"\n    }\n    ans := s\n    cnt, left := 0, 0\n\n    for i, ch := range s {\n        if ch == '1' {\n            cnt += 1\n        }\n\n        for cnt &gt;= k {\n            tmp := s[left : i+1]\n            if s[left] == '1' {\n                cnt -= 1\n            }\n            left += 1\n            if len(tmp) == len(ans) {\n                if tmp &lt; ans {\n                    ans = tmp\n                }\n            }\n            if len(tmp) &lt; len(ans) {\n                ans = tmp\n            }\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        s string\n        k int\n    }{\n        {\"100011001\", 3},\n        {\"1011\", 2},\n        {\"000\", 1},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(shortestBeautifulSubstring(testCase.s, testCase.k))\n    }\n}\n\n\n\n\n1234. 替换子串得到平衡字符串\n\n题面\n有一个只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符，且长度为 n 的字符串。\n假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。\n给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。\n你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。\n请返回待替换子串的最小可能长度。\n如果原字符串自身就是一个平衡字符串，则返回 0。\n示例 1：\n输入：s = “QWER”\n输出：0\n解释：s 已经是平衡的了。\n示例 2：\n输入：s = “QQWE”\n输出：1\n解释：我们需要把一个 ‘Q’ 替换成 ‘R’，这样得到的 “RQWE” (或 “QRWE”) 是平衡的。\n示例 3：\n输入：s = “QQQW”\n输出：2\n解释：我们可以把前面的 “QQ” 替换成 “ER”。\n示例 4：\n输入：s = “QQQQ”\n输出：3\n解释：我们可以替换后 3 个 ‘Q’，使 s = “QWER”。\n提示：\n1 &lt;= s.length &lt;= 10^5\ns.length 是 4 的倍数\ns 中只含有 ‘Q’, ‘W’, ‘E’, ‘R’ 四种字符\n\n\n思路说明\n构建一个最小窗口，让窗口外的每种字符数量尽量接近n，这个最小窗口就是需要替换的字符串\n通过哈希表统计每种字符的数量\n\n\n题解\n\n// 1234.替换子串得到平衡字符串\npackage main\n\nimport \"fmt\"\n\nfunc balancedString(s string) int {\n    // 构建哈希表，统计各自的数量\n    // 构建一个最小窗口，让窗口外的每种字符数量尽量接近n，这个最小窗口就是需要替换的字符串\n    mp := make(map[byte]int, 4)\n    n := len(s) / 4\n\n    for i := 0; i &lt; len(s); i++ {\n        mp[s[i]] += 1\n    }\n\n    // 已经平衡，返回0\n    if mp['Q'] == n && mp['W'] == n && mp['E'] == n && mp['R'] == n {\n        return 0\n    }\n\n    ans, left := len(s), 0\n\n    for i := 0; i &lt; len(s); i++ {\n        mp[s[i]] -= 1 // 放进窗口\n        for mp['Q'] &lt;= n && mp['W'] &lt;= n && mp['E'] &lt;= n && mp['R'] &lt;= n {\n            // 满足条件，记录并收缩\n            ans = min(ans, i-left+1)\n            mp[s[left]] += 1\n            left += 1\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []string{\n        \"QWER\",\n        \"QQWE\",\n        \"QQQW\",\n        \"QQQQ\",\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(balancedString(testCase))\n    }\n}\n\n\n\n\n2875. 无限数组的最短子数组\n\n题面\n给你一个下标从 0 开始的数组 nums 和一个整数 target 。\n下标从 0 开始的数组 infinite_nums 是通过无限地将 nums 的元素追加到自己之后生成的。\n请你从 infinite_nums 中找出满足 元素和 等于 target 的 最短 子数组，并返回该子数组的长度。如果不存在满足条件的子数组，返回 -1 。\n示例 1：\n输入：nums = [1,2,3], target = 5\n输出：2\n解释：在这个例子中 infinite_nums = [1,2,3,1,2,3,1,2,…] 。\n区间 [1,2] 内的子数组的元素和等于 target = 5 ，且长度 length = 2 。\n可以证明，当元素和等于目标值 target = 5 时，2 是子数组的最短长度。\n示例 2：\n输入：nums = [1,1,1,2,3], target = 4\n输出：2\n解释：在这个例子中 infinite_nums = [1,1,1,2,3,1,1,1,2,3,1,1,…].\n区间 [4,5] 内的子数组的元素和等于 target = 4 ，且长度 length = 2 。\n可以证明，当元素和等于目标值 target = 4 时，2 是子数组的最短长度。\n示例 3：\n输入：nums = [2,4,6,8], target = 3\n输出：-1\n解释：在这个例子中 infinite_nums = [2,4,6,8,2,4,6,8,…] 。\n可以证明，不存在元素和等于目标值 target = 3 的子数组。\n提示：\n1 &lt;= nums.length &lt;= 10^5\n1 &lt;= nums[i] &lt;= 10^5\n1 &lt;= target &lt;= 10^9\n\n\n思路说明\n使用的nuns的数量是不不定的，可能是1-n个，但是可以观察到，如果使用n个，中间n-2个是完整的，左边nums和右边nums，分别取右边和左边连续的数据\n设 nums的数据和事total\ntarget = total*m + res\nres = nums*2[i:j]\n我们要做的就是找到res的长度\nres = target & total\n其他的按照固定步骤做即可\n\n\n题解\n\n// 2875.无限数组的最短子数组\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc minSizeSubarray(nums []int, target int) int {\n    total := 0\n    for _, x := range nums {\n        total += x\n    }\n\n    ans := math.MaxInt\n    left, sum, n := 0, 0, len(nums)\n    for right := 0; right &lt; n*2; right++ {\n        sum += nums[right%n]\n        for sum &gt; target%total {\n            sum -= nums[left%n]\n            left++\n        }\n        if sum == target%total {\n            ans = min(ans, right-left+1)\n        }\n    }\n    if ans == math.MaxInt {\n        return -1\n    }\n    return ans + target/total*n\n}\n\nfunc main() {\n    testCases := []struct {\n        nums   []int\n        target int\n    }{\n        {[]int{1, 2, 3}, 5},\n        {[]int{1, 1, 1, 2, 3}, 4},\n        {[]int{2, 4, 6, 8}, 3},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(minSizeSubarray(testCase.nums, testCase.target))\n    }\n}\n\n\n\n\n76. 最小覆盖子串\n\n题面\n给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。\n注意：\n对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。\n如果 s 中存在这样的子串，我们保证它是唯一的答案。\n示例 1：\n输入：s = “ADOBECODEBANC”, t = “ABC”\n输出：“BANC”\n解释：最小覆盖子串 “BANC” 包含来自字符串 t 的 ‘A’、‘B’ 和 ‘C’。\n示例 2：\n输入：s = “a”, t = “a”\n输出：“a”\n解释：整个字符串 s 是最小覆盖子串。\n示例 3:\n输入: s = “a”, t = “aa”\n输出: “”\n解释: t 中两个字符 ‘a’ 均应包含在 s 的子串中，\n因此没有符合条件的子字符串，返回空字符串。\n提示：\nm == s.length\nn == t.length\n1 &lt;= m, n &lt;= 10^5\ns 和 t 由英文字母组成\n\n\n思路说明\n先说一下题目的要求，找到s的子串，子串包含t中所有字符（种类和数量）\n首先，我们要知道t中有哪些字符\n然后，在s中找到子串，子串中包含t中所有种类字符，这个子串尽可能小\n所以使用哈希表统计t中所有字符种类和数量\n然后在s中找子串，如果子串中字符在哈希表中，就减去，如果哈希表全部变成0，表示子串中已经包含t中全部字符，然后缩小窗口，直到不满足要求\n\n\n题解\n\n// 76.最小覆盖子串\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc minWindow(s string, t string) string {\n    // 先统计一下t中各个字符的数量,统计一下字符的种类\n    mp := make(map[byte]int)\n\n    for i := 0; i &lt; len(t); i++ {\n        mp[t[i]] += 1\n    }\n    left := 0\n    cnt := len(mp) // 字符的种类\n    ans := \"\"\n    tmp := math.MaxInt\n\n    for i := 0; i &lt; len(s); i++ {\n        if _, ok := mp[s[i]]; ok { // 字符有效\n            mp[s[i]] -= 1\n            if mp[s[i]] == 0 { // 符合要求\n                cnt -= 1\n            }\n        }\n\n        for cnt == 0 { // 子串中已经满足要求，缩小子串范围\n            if tmp &gt; i-left+1 {\n                tmp = i - left + 1\n                ans = s[left : i+1]\n            }\n            if _, ok := mp[s[left]]; ok { // 字符有效\n                mp[s[left]] += 1\n                if mp[s[left]] == 1 { // 符合要求\n                    cnt += 1\n                }\n            }\n            left += 1\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        s string\n        t string\n    }{\n        {\"ADOBECODEBANC\", \"ABC\"},\n        {\"a\", \"a\"},\n        {\"a\", \"aa\"},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(minWindow(testCase.s, testCase.t))\n    }\n}\n\n\n\n\n632. 最小区间\n\n题面\n你有 k 个 非递减排列 的整数列表。找到一个 最小 区间，使得 k 个列表中的每个列表至少有一个数包含在其中。\n我们定义如果 b-a &lt; d-c 或者在 b-a == d-c 时 a &lt; c，则区间 [a,b] 比 [c,d] 小。\n示例 1：\n输入：nums = [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]\n输出：[20,24]\n解释：\n列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。\n列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。\n列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。\n示例 2：\n输入：nums = [[1,2,3],[1,2,3],[1,2,3]]\n输出：[1,1]\n提示：\nnums.length == k\n1 &lt;= k &lt;= 3500\n1 &lt;= nums[i].length &lt;= 50\n-105 &lt;= nums[i][j] &lt;= 10^5\nnums[i] 按非递减顺序排列\n\n\n思路说明\n构建pair，包含数字和位置，然后排序，构建一个滑动窗口，窗口包含所有index并且窗口最小\n\n\n题解\n\n// 632.最小区间\npackage main\n\nimport (\n    \"fmt\"\n    \"slices\"\n)\n\nfunc smallestRange(nums [][]int) []int {\n    type pair struct{ x, i int } // 数字和他们所在的位置\n    pairs := []pair{}\n\n    for i, arr := range nums {\n        for _, num := range arr {\n            pairs = append(pairs, pair{num, i})\n        }\n    }\n\n    slices.SortFunc(pairs, func(a, b pair) int { return a.x - b.x })\n\n    ansL, ansR := pairs[0].x, pairs[len(pairs)-1].x\n    mp := make(map[int]int)\n    left := 0\n\n    for _, p := range pairs {\n        r, i := p.x, p.i\n        mp[i] += 1\n\n        for len(mp) == len(nums) { // 每个列表都至少包含一个数\n            l, i := pairs[left].x, pairs[left].i\n            if r-l &lt; ansR-ansL {\n                ansL, ansR = l, r\n            }\n            mp[i] -= 1\n            if mp[i] == 0 {\n                delete(mp, i)\n            }\n            left += 1\n        }\n    }\n    return []int{ansL, ansR}\n}\n\nfunc main() {\n    testCases := [][][]int{\n        [][]int{\n            []int{4, 10, 15, 24, 26},\n            []int{0, 9, 12, 20},\n            []int{5, 18, 22, 30},\n        },\n        [][]int{\n            []int{1, 2, 3},\n            []int{1, 2, 3},\n            []int{1, 2, 3},\n        },\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(smallestRange(testCase))\n    }\n}"
  },
  {
    "objectID": "content/blogs/entries/本地服务器低速传输解决方案.html",
    "href": "content/blogs/entries/本地服务器低速传输解决方案.html",
    "title": "本地服务器低速传输解决方案",
    "section": "",
    "text": "最近在给一台远程 Linux 服务器部署项目，遇到在一个极其离谱的网络环境：\n\n文件很大：代码加数据包足足有 6.7GB。\n网络极差：本地 Mac 与服务器之间的 Ping 值高达 700ms+，且伴随严重丢包。\n速度感人：尝试使用 scp 或 rsync 直传，速度稳定在 40KB/s…… 传完预计需要 40 个小时，而且随时会断开。\n\n但在排查过程中发现，服务器本身的下行带宽其实并不差（Speedtest 实测有 70Mbps），瓶颈在于“我与服务器之间”那条拥堵的链路，导致 TCP 协议的滑动窗口崩溃，速度上不去。\n解决思路： 既然直连不行，那就找个“中转站”。利用百度网盘（配合 SVIP）作为高速桥梁，并在 Linux 服务器上通过命令行工具跑满带宽下载。\n本文将介绍一套 bypy + aria2 多线程下载 的终极解决方案。\n\n\n\n\n\n速度快：利用百度网盘的 CDN 和服务器自身的带宽，避开点对点拥堵。但是要有百度网盘的会员才能享受高速下载。\n稳定：aria2 支持多线程并发和断点续传，搞定大文件。\n\n\n\n\n\n\n\n压缩： 先将项目文件夹压缩成 zip 包。可以在终端执行：\nzip -r project.zip project_folder\n上传： 打开百度网盘客户端，将 project.zip 上传到网盘 /apps/bypy/ 目录下，方便后续操作。\n\n\n\n\n登录你的远程 Linux 服务器。我们需要安装两个工具：\n\nbypy：百度网盘的 Python 客户端。\naria2：多线程下载神器（关键！没有它大文件会卡死）。\n\n如果你有 conda 环境（终端显示 (base)），安装非常简单：\n# 1. 安装 bypy\npip install bypy\n\n# 2. 安装 aria2\nconda install -c conda-forge aria2\n# 或者\napt-get install aria2  # 如果你有 root 权限\n验证安装： 输入 aria2c -v，如果能看到版本号说明安装成功。\n\n\n\n\n在服务器终端输入：\nbypy info\n\n终端会显示一个长链接。\n复制这个链接，在本地浏览器打开。\n登录百度账号，复制网页上显示的授权码。\n回到服务器终端，粘贴授权码并回车。\n\n显示容量信息即表示绑定成功。\n\n\n\n\nbypy 默认使用的是 Python 单线程下载，遇到几个 G 的大文件经常会**“起步快，然后迅速掉速直到卡死（0%不动）”**。\n必须挂载 aria2 进行多线程拉取。\n请执行以下命令：\n# --downloader aria2: 指定使用 aria2 下载器\n# --processes 4: 开启 4 线程并发（跑满带宽）\n# --timeout 600: 增加超时容忍度，防止网络波动中断\n\nbypy --downloader aria2 --processes 4 --timeout 600 download project.enc\n效果对比：\n\n普通下载：200KB/s -&gt; 0KB/s (卡死)。\nAria2 下载：[#20a9c1 1.2GiB/6.2GiB(19%) CN:4 DL:5.2MiB] -&gt; 5.2MB/s 稳定跑满！\n\n\n\n\n\n下载完成后，你得到了 project.zip。现在用同样的密码把它变回 zip 包。\n# 解压\nunzip project.zip\n\n\n\n\n\n当 SSH 链路质量极差时，不要死磕 SCP 或 Rsync。\n“本地压缩 -&gt; 网盘中转 -&gt; Aria2 多线程拉取” 是一条虽然步骤稍多，但绝对可行、安全且高速的路径。特别是对于几个 G 的代码或模型权重文件，这是最节省时间的选择。\n\n小贴士： 如果你的文件不在 /apps/bypy/ 目录下，记得在网盘网页端把文件移动进去，否则 bypy 可能找不到文件(apps文件夹名称可能是中文，注意识别)。"
  },
  {
    "objectID": "content/blogs/entries/本地服务器低速传输解决方案.html#前言绝望的-50kbs",
    "href": "content/blogs/entries/本地服务器低速传输解决方案.html#前言绝望的-50kbs",
    "title": "本地服务器低速传输解决方案",
    "section": "",
    "text": "最近在给一台远程 Linux 服务器部署项目，遇到在一个极其离谱的网络环境：\n\n文件很大：代码加数据包足足有 6.7GB。\n网络极差：本地 Mac 与服务器之间的 Ping 值高达 700ms+，且伴随严重丢包。\n速度感人：尝试使用 scp 或 rsync 直传，速度稳定在 40KB/s…… 传完预计需要 40 个小时，而且随时会断开。\n\n但在排查过程中发现，服务器本身的下行带宽其实并不差（Speedtest 实测有 70Mbps），瓶颈在于“我与服务器之间”那条拥堵的链路，导致 TCP 协议的滑动窗口崩溃，速度上不去。\n解决思路： 既然直连不行，那就找个“中转站”。利用百度网盘（配合 SVIP）作为高速桥梁，并在 Linux 服务器上通过命令行工具跑满带宽下载。\n本文将介绍一套 bypy + aria2 多线程下载 的终极解决方案。"
  },
  {
    "objectID": "content/blogs/entries/本地服务器低速传输解决方案.html#方案优势",
    "href": "content/blogs/entries/本地服务器低速传输解决方案.html#方案优势",
    "title": "本地服务器低速传输解决方案",
    "section": "",
    "text": "速度快：利用百度网盘的 CDN 和服务器自身的带宽，避开点对点拥堵。但是要有百度网盘的会员才能享受高速下载。\n稳定：aria2 支持多线程并发和断点续传，搞定大文件。"
  },
  {
    "objectID": "content/blogs/entries/本地服务器低速传输解决方案.html#操作全流程",
    "href": "content/blogs/entries/本地服务器低速传输解决方案.html#操作全流程",
    "title": "本地服务器低速传输解决方案",
    "section": "",
    "text": "压缩： 先将项目文件夹压缩成 zip 包。可以在终端执行：\nzip -r project.zip project_folder\n上传： 打开百度网盘客户端，将 project.zip 上传到网盘 /apps/bypy/ 目录下，方便后续操作。\n\n\n\n\n登录你的远程 Linux 服务器。我们需要安装两个工具：\n\nbypy：百度网盘的 Python 客户端。\naria2：多线程下载神器（关键！没有它大文件会卡死）。\n\n如果你有 conda 环境（终端显示 (base)），安装非常简单：\n# 1. 安装 bypy\npip install bypy\n\n# 2. 安装 aria2\nconda install -c conda-forge aria2\n# 或者\napt-get install aria2  # 如果你有 root 权限\n验证安装： 输入 aria2c -v，如果能看到版本号说明安装成功。\n\n\n\n\n在服务器终端输入：\nbypy info\n\n终端会显示一个长链接。\n复制这个链接，在本地浏览器打开。\n登录百度账号，复制网页上显示的授权码。\n回到服务器终端，粘贴授权码并回车。\n\n显示容量信息即表示绑定成功。\n\n\n\n\nbypy 默认使用的是 Python 单线程下载，遇到几个 G 的大文件经常会**“起步快，然后迅速掉速直到卡死（0%不动）”**。\n必须挂载 aria2 进行多线程拉取。\n请执行以下命令：\n# --downloader aria2: 指定使用 aria2 下载器\n# --processes 4: 开启 4 线程并发（跑满带宽）\n# --timeout 600: 增加超时容忍度，防止网络波动中断\n\nbypy --downloader aria2 --processes 4 --timeout 600 download project.enc\n效果对比：\n\n普通下载：200KB/s -&gt; 0KB/s (卡死)。\nAria2 下载：[#20a9c1 1.2GiB/6.2GiB(19%) CN:4 DL:5.2MiB] -&gt; 5.2MB/s 稳定跑满！\n\n\n\n\n\n下载完成后，你得到了 project.zip。现在用同样的密码把它变回 zip 包。\n# 解压\nunzip project.zip"
  },
  {
    "objectID": "content/blogs/entries/本地服务器低速传输解决方案.html#总结",
    "href": "content/blogs/entries/本地服务器低速传输解决方案.html#总结",
    "title": "本地服务器低速传输解决方案",
    "section": "",
    "text": "当 SSH 链路质量极差时，不要死磕 SCP 或 Rsync。\n“本地压缩 -&gt; 网盘中转 -&gt; Aria2 多线程拉取” 是一条虽然步骤稍多，但绝对可行、安全且高速的路径。特别是对于几个 G 的代码或模型权重文件，这是最节省时间的选择。\n\n小贴士： 如果你的文件不在 /apps/bypy/ 目录下，记得在网盘网页端把文件移动进去，否则 bypy 可能找不到文件(apps文件夹名称可能是中文，注意识别)。"
  },
  {
    "objectID": "content/blogs/entries/如何使用git.html",
    "href": "content/blogs/entries/如何使用git.html",
    "title": "如何使用git",
    "section": "",
    "text": "记录一下自己使用git容易忘记的指令和相关的规范"
  },
  {
    "objectID": "content/blogs/entries/如何使用git.html#git提交规范",
    "href": "content/blogs/entries/如何使用git.html#git提交规范",
    "title": "如何使用git",
    "section": "git提交规范",
    "text": "git提交规范\n下面是我在逐渐遵循的git提交规范"
  },
  {
    "objectID": "content/blogs/entries/如何使用git.html#git常用指令",
    "href": "content/blogs/entries/如何使用git.html#git常用指令",
    "title": "如何使用git",
    "section": "git常用指令",
    "text": "git常用指令\n\n修改远程仓库地址\ngit remote set-url origin &lt;new-url&gt;"
  },
  {
    "objectID": "content/blogs/entries/保姆教程如何创建自己的“个人网站”.html",
    "href": "content/blogs/entries/保姆教程如何创建自己的“个人网站”.html",
    "title": "保姆教程如何创建自己的“个人网站”",
    "section": "",
    "text": "如何创建自己的个人网站\n\n文章主要介绍如何使用 Jekyll 和 GitHub 创建一个属于自己的个人网站，通过网站可以记录自己的学习笔记，技术收获，同时也可以更好地展示自己，养成笔记的好习惯（21天轻松养成好习惯，哈哈哈）。\n\n\n0、放在开头的一些东西\nRuby安装教程 因为文章是后补的，文章中没有介绍Ruby的安装，安装教程可以参考前面的链接。\n安装Ruby的目的是在本地运行代码，查看网站的效果，如果不需要本地运行可以不配置Ruby环境。\nJekyll模板网站 http://jekyllthemes.org/ 网站中包含了很多静态网的模板，大家可以自由选择，在本中文使用的是chirpy主题，所有模板的配置过程也都大差不差。 ### 1、使用GitHub创建自己的仓库 #### step 1 在GitHub中键入chirpy查找本教程使用的模板，上面的模板可以自行改动，大佬可以阅读源码创建自己的个人主页，下面的仓库操作比较简单，本文选择使用下面的模板，不进行修改，直接进行基础配置后可以进行使用。 \n\nstep 2\n首先找到模板所在的GitHub仓库，在左上角找到“use this template”，然后选择其中的“Create a new repository”，用模板构建自己的仓库。 \n\n\nstep 3\n进行仓库配置，首先需要创建自己仓库的名称，为了后续能够形成自己的个人主页，仓库名称需要设置为 “你的用户名”+“.github.io” ，这样可以通过https://username.github.io直接访问。然后需要将仓库的可见方式设置为Public（默认就是Public，不需要改动）。 \n\n\nstep 4\n点击 “Create repository” 创建属于自己的仓库。 \n\n\nstep 5\n等待仓库创建完成。 \n\n\nstep 6\n仓库创建完成。这时候可以检查仓库的名称是否正确，防止后续不能正常显示网页。 \n\n\nstep 7\n等待一段时间，GitHub配置完成后，在浏览器中输入 “username.github.io” 可以初步看到网页显示的效果，此时只有一个界面，很多配置还没有完成，能够正常显示就是初步成功。 \n\n\n\n2、将仓库内容git到本地\n\n为了能够更好配置网页，测试效果，后续配置和上传帖子，可以将项目git到本地进行配置\n在本地运行Jekyll模板需要配置Ruby环境，配置流程可以参考上面的链接\n当然，在GitHub直接进行修改也是可以的\n\n\n获取git链接\n在创建的仓库界面右上角点击 “code” ，选择HTTPS复制git链接。 \n\n\ngit到本地\n进入想要下载的文件夹，右击选择 “Git Bash Here” 。 \n在其中输入“git clone” + 刚在复制的git链接，将仓库git到本地吗，如果失败就多尝试几次，如果需要配置git可以找篇帖子看一下，都大差不差很好配置。 \n\n\nIDE打开项目\n文章选择使用pycharm打开项目。 \n打开项目后可以右击查看到项目中有git选项，这是因为Pycharm识别到我们git的项目了，通过点选就能完成项目的添加、提交和推送。 \n\n\n\n3、本地配置网站\n\n安装配置\n执行下方命令可以自动进行运行环境配置\nbundle\n\n在配置的过程中可能会出现错误，文章在配置过程中显示缺少wdm插件。 \n安装wdm\ngem install wdm\n\n根据图片中显示安装的是0.2.0版本，而需要的是0.1.1版本，检查Gemfile文件修改其中wdm需要的版本即可。 \n\n\n添加头像\n项目中资源文件一般放在assets中，在assets中创建文件夹防止头像即可，头像的显示需要在配置文件中添加路径，记得本步骤的路径即可。 \n\n\n配置文件修改\n项目的基本配置都在 “_config.yml” 文件中，阅读文件根据需要配置即可。 其中有几个配置比较关键 &gt; lang: 设置显示的语言，语言配置可以看这里，添加文件名就行。 &gt; &gt; description:网站的描述。 &gt; &gt; url: 改成你的网站地址”https://username.github.io” &gt; &gt; github:username: 改成自己的username &gt; &gt; social: 社交平台链接，根据需要修改 &gt; &gt; avatar：头像地址，改成上一步的地址即可 &gt; &gt; comments:评论系统配置，后面详细介绍\n\n\n\n本地运行项目\n配置完成后，执行下面命令运行项目，在 127.0.0.1:4000 查看运行结果。\nbundle exec jekyll server\n 在运行的过程中可能也会出现错误，基本都是缺少插件或者插件的版本问题，哪里报错改哪里，缺啥补啥，直接复制报错信息，直接搜基本都能找到解决方法。\n运行效果如下： \n结束运行： 首先ctrl+c，然后两次确定即可。 \n\n\n添加文章\n文章的添加在 “_post” 文件夹中即可，文件的命名格式和标头都有要求。 \n\n文章命名格式为：YYYY-MM-DD-TITLE.md（注意是markdown文件）\n\n\n标头格式为：\ntitle: 题目名称\nauthor: 作者名称\ndate: 项目创建时间\ncategories: 项目分类，如：[Jekyll, GitHub]\ntags: 项目标签，如：[Jekyll, Github]\nmath: 是否显示latex公式\n……\n其他根据需要添加，可以阅读源码查看相应配置\n\n\n\n\n\n4、提交修改\n提交项目使用git进行控制，主要有三个过程：添加，提交和推送。由于使用了pycharm作为IDE，能直接通过点选完成。\n右击项目，选择 “Git”，先点 “添加” ，然后点 “Commit目录” ，最后推送即可更新GitHub仓库中的内容。待内容更新完成可以在 “https://username.github.io” 查看更新效果。 \n提交更新后效果如下： \n\n\n5、添加评论系统\n在模板中配置了多种评论系统，文章中选择使用 “giscus”。\n在添加前需要完成一个配置，在 “Pages” 中将source改成 “GitHub Actions”。 \n\n安装giscus\n在giscus中点击安装即可，可能需要GitHub认证，按照步骤操作即可。 \n\n\nGitHub配置\n在设置中将Discussions设置为true \n查看Discussions，可以选择或创建一个标签作为评论系统的评论类别名称。这里选择的是 “General”。 \n\n\ngiscus配置\n在giscus中进行配置\n\n首先配置仓库：username/username.github.io\n然后选择映射关系，选择第一个，保持默认即可\n选择Discussion分类，选择之前确定或创建的分类即可 \n\n\n\n项目文件配置\n在giscus配置完成后，会生成专属id \n在项目的 “_config.yml” 文件中进行相应配置\n\nprovider: giscus\ngiscus:\n\nrepo: username/username.github.io\nrepo_id: 自己的repo_id\ncategory: Comments\ncategory_id: 自己的category_id\nmapping: pathname\n\n\n\n\n\n评论系统测试\n将修改后的项目提交，在网页的文章最后能看到评论系统，需要GitHub登陆后才能提交评论 \n\n\n\n6、关于创建过程中遇到的一些问题和解决方法\n\n文章中使用的Jekyll模板作者设计的非常全面，我们在使用的过程中可能会遇到很多问题，本章节主要记录遇到的问题和解决方案\n\n\n数学公式不显示的问题 在post编写的过程中可以使用latex写公式，GitHub也已经支持latex公式的显示，但提交的文章中公式还是源码。 在标头中设置“math: true”就可以 类似的问题可以查看源码，我之前一直以为作者没有添加公式识别功能，查看后才知道写了,需要在标头中进行设置。源码地址\n\n\n黑白两种主题不能切换的问题 缺少必要插件，具体少那个可以自己查查，我忘了\n\n\n插件安装报错wdm，在Gemfile中写的是0.1.1版本，实际安装过程中执行“bundle”命令安装的是0.2.0版本，吧Gemfile文件中的版本号改一下就行。 遇到其他插件报错的时候也可以参考这个方法\n\n\n项目识别不了http链接，可能是出于安全考虑吧 原本是”[xxx] (http://xxx/xxx)“，不能识别http协议，链接直接写就行，不然提交后会在Actions中报错。"
  },
  {
    "objectID": "content/blogs/entries/一文了解RAG.html",
    "href": "content/blogs/entries/一文了解RAG.html",
    "title": "一文了解RAG",
    "section": "",
    "text": "RAG（Retrieval Augmented Generation）：检索增强生成"
  },
  {
    "objectID": "content/blogs/entries/一文了解RAG.html#引言",
    "href": "content/blogs/entries/一文了解RAG.html#引言",
    "title": "一文了解RAG",
    "section": "0 引言",
    "text": "0 引言\n写在前面，作者也是初学者，抱着学习的心态写了这篇文章，如果有问题，欢迎大家邮箱联系进行批评指正。\n本篇将系统介绍RAG的基本概念、核心技术原理、发展背景和典型架构，随后深入探讨多模态RAG（如文本-图像、文本-视频的检索增强生成）和Graph RAG（基于图结构数据的检索增强生成）等前沿方向，最后分析当前面临的挑战与未来发展趋势。"
  },
  {
    "objectID": "content/blogs/entries/一文了解RAG.html#基本概念",
    "href": "content/blogs/entries/一文了解RAG.html#基本概念",
    "title": "一文了解RAG",
    "section": "1 基本概念",
    "text": "1 基本概念\nRAG（Retrieval Augmented Generation），中文名称是检索增强生成，通俗意义上来讲就是通过检索提升大模型生成效果的技术，旨在提升生成式AI的准确性与可信度。它实现了大语言模型与外部知识库的结合，是缓解幻觉与提升可追溯性的关键路线之一。该概念最初由Facebook AI研究团队在2020年提出，并发表了命名RAG的开创性论文。如今，RAG已发展为一类庞大的方法体系，被认为是通向更可靠生成式AI的重要方向。"
  },
  {
    "objectID": "content/blogs/entries/一文了解RAG.html#背景和技术原理",
    "href": "content/blogs/entries/一文了解RAG.html#背景和技术原理",
    "title": "一文了解RAG",
    "section": "2 背景和技术原理",
    "text": "2 背景和技术原理\n\n2. 1 背景\n大模型在没有外部知识库的情况下也能”记住”大量知识，但仍然存在明显局限：参数中的知识更新成本高、回答往往缺少可核验的证据来源；遇到冷门知识、最新信息或长链路推理时，错误率会上升；在多轮对话与长上下文场景里，也可能出现信息遗忘、主题漂移与证据混淆等问题。\n比如，你问的是aorangehc是谁，它却开始讲爱因斯坦是谁，这类与问题无关或事实不符的生成通常被称为幻觉（LLM Hallucination)。幻觉并非某一个模型的偶然故障，而是概率式生成在信息不足、目标不清或证据缺失时容易出现的系统性现象，因此研究者开始从模型之外引入约束与外部信息来降低这类问题的发生。\n一种方法是在预训练之后对模型进行指令微调与对齐训练，让它在不确定时更倾向于回答”不知道”或主动澄清。一种方法是使用者通过Prompt对回答范围、证据要求与输出格式进行限制，减少模型自由发挥的空间。\n还有一种就是引入外部知识库。我们现在使用ChatGPT、Gemini、Kimi、豆包以及DeepSeek等大模型应用时，经常会看到联网搜索或知识库问答功能：系统会根据问题去外部数据源检索网页或文档片段，将检索结果作为证据提供给模型，再由模型基于证据与自身语言能力组织答案，从而显著提升事实性与可解释性。这个”先检索、再生成”的过程，就是RAG的典型范式。\n\n\n2.2 技术原理\n现在意义上的大模型具有很多能力，我们日常中更多是使用大模型进行提问，让它解决遇到的难题，比如Python代码报错，把报错信息扔给大模型，它给出修改意见，这个过程中使用的主要能力是指令遵循。除此之外还有上下文学习、推理、工具使用等，随着技术的发展，大模型可调用的能力在不断扩展。\n在RAG中主要利用的就是大模型的上下文学习能力，通过检索获取相关知识作为上下文提供给大模型，然后由大模型基于问题与证据进行归纳总结并生成回答。\nRAG的核心思想是在生成任务中引入检索模块。模型在接到输入后，先由检索模块从外部知识库（如维基百科、专有文档库、企业内部资料等）中检索出相关资料，再将检索到的内容与原始输入一起送入生成模型，生成最终回答或文本。这种”检索-生成”策略使模型能够现查现用所需知识，而不必完全依赖参数中存储的旧知识。OpenAI的WebGPT工作即是典型案例：它让GPT-3在一个受控的浏览环境中搜索网页、抽取引用片段并据此回答长问题，从而提升答案的事实性与可核验性。通过引入检索，不仅能降低幻觉发生率，也使知识库可以更灵活地扩展与更新，例如用户可以按需接入新的数据源供系统使用。\n自RAG提出后，各大研究团队纷纷推出改进的检索增强模型。例如，DeepMind在2021年发布的RETRO模型通过接入超大规模文本数据库进行检索增强，在较小参数规模下取得了与当时超大模型相当甚至在部分基准上更优的效果，体现了检索对”以更小模型获得更强知识能力”的潜力。又如Meta在2022年推出的Atlas模型，将预训练的检索增强语言模型用于少样本学习，在开放域问答等知识密集任务上，用显著更少的参数规模取得了与超大模型相竞争的表现。这些成果表明，检索增强可以在更小模型规模下达到甚至逼近超大模型的效果，凸显了参数与检索融合的效率优势与工程价值。"
  },
  {
    "objectID": "content/blogs/entries/一文了解RAG.html#rag框架",
    "href": "content/blogs/entries/一文了解RAG.html#rag框架",
    "title": "一文了解RAG",
    "section": "3 RAG框架",
    "text": "3 RAG框架\n\n图片引用自文献Retrieval-Augmented Generation for AI-Generated Content: A Survey\n典型RAG系统包含检索器与生成器两大核心组件。\n\n3.1 RAG基本流程\n首先，输入查询会被检索模块编码为向量表示，并在外部知识库的向量索引中进行相似度搜索，检索出若干相关文本片段，并可能应用重排序技术来提高精度。随后，这些检索到的证据片段与原始查询一并提供给生成模型，模型将基于问题与证据生成最终回答。通过将外部知识融入生成过程，RAG能够让回答更贴近事实，并在工程实现上支持给出引用来源与证据片段，从而提升可解释性与可审计性。\n经典RAG在生成整个回答时往往使用固定的一组检索文档；也有更高级的变体如RAG-Token，可以在生成过程中对不同位置动态使用不同检索证据，从而提升信息使用的灵活性。\n无论哪种方式，检索结果与生成模型的融合都是关键。很多实现会将检索文本直接拼接到模型输入中，而一些研究也探索在模型内部以更结构化的方式利用检索信息，使模型在生成时能更稳定地对齐证据、减少无关发挥。实践中，检索器与生成器既可以分阶段独立优化，也可以在特定设定下进行联合训练或端到端微调，以让检索器更偏向于返回对生成最有帮助的证据、生成器也更善于引用与整合证据。\n\n\n3.2 检索器\n检索是指根据信息需求识别并获取相关信息。具体来说，我们可以将信息资源视为一个键值存储，其中每个键对应一个值，键和值可以相同。给定一个查询，目标是使用相似性函数搜索出最相似的前k个键，并获取与之配对的值。根据不同的相似性函数，现有的检索方法可分为稀疏检索、稠密检索及其他类型。\n\n3.2.1 稀疏检索器\n稀疏检索器利用词项匹配指标，如TF-IDF、BM25，主要用于文档的相关检索。这些方法通过分析文本中的词统计信息并构建倒排索引来实现高效搜索。本质上，BM25是大规模网络搜索中的一个强大基线，它整合了逆文档频率权重、查询词项出现次数和其他相关指标。\n\n\n3.2.2 稠密检索器\n稠密检索通过稠密嵌入向量来表示查询和键，并构建近似最近邻索引加快搜索速度，能用于所有模态的检索。稠密检索将原本的数据通过预训练模型编码成为向量，然后通过计算相似度分数进行检索，相似度计算可以通过余弦、内积和L2距离等。\n现在的RAG系统为了提升效果一般采用稀疏检索+稠密检索的混合检索模式，提升效果。\n\n\n\n3.3 生成器\n生成器结合检索到的内容，生成所需内容。\n随着AIGC时代的发展，生成器也不断发展丰富成熟，不同的生成器模型可以用于不同的场景，比如\n\nTransformer模型用于文本到文本的任务\nVisualGPT可以用于图像到文本的任务\nStable Diffusion可以用于文本到图像的任务\nCodex可以用于文本到代码的任务"
  },
  {
    "objectID": "content/blogs/entries/一文了解RAG.html#rag增强",
    "href": "content/blogs/entries/一文了解RAG.html#rag增强",
    "title": "一文了解RAG",
    "section": "4 RAG增强",
    "text": "4 RAG增强\n是的检索增强生成(的)增强也是很重要的研究点，有很多技巧。\n\n4.1 输入增强\n最初输入到检索器中的内容对检索阶段的最终结果有显著影响，输入增强的方式主要有以下几种。\n\n4.1.1 查询转换\n查询转换可以通过修改输入查询来增强检索结果。\nQuery2doc和HyDE，利用原始查询生成伪文档，之后将该伪文档用作检索的查询。伪文档包含更丰富的相关信息，有助于检索出更准确的结果。\nTOC利用检索到的内容，将模糊的查询分解为多个清晰的子查询，这些子查询被发送到生成器，经聚合后产生最终结果。对于。\nRQ-RAG将复杂或模糊的查询分解为清晰的子查询以进行细粒度检索，并对响应进行综合，从而为原始查询提供连贯的答案\n\n\n4.1.2 数据增强\n数据增强表示在检索前对数据进行改进，包括去除无关信息、消除歧义、更新过时文档、合成新数据等技术\nMake-An-Audio利用字幕生成和音频-文本检索为无语言音频生成字幕，以缓解数据稀疏问题，并添加随机概念音频来改进原始音频。\nLESS通过分析梯度信息优化下游任务的数据集选择，旨在提升模型对指令提示的响应性能。\nReACC通过重命名和死代码插入来预训练代码检索模型。\n\n\n\n4.2 检索器增强\n\n4.2.1 递归检索\n归检索是指执行多次搜索以获取更丰富、更高质量的内容。\nReACT利用思维链（CoT）将查询分解以进行递归检索，并提供更丰富的信息。\nRATP采用蒙特卡洛树搜索进行模拟，以选择最优的检索内容，然后将其模板化并转发给生成器进行输出。\n\n\n4.2.2 块优化\n块优化指的是调整块大小以改善检索结果。\nLlamaIndex集成了一系列 chunk 优化方法，其中一种遵循”从小到大”的原则。其核心思想是精准定位更细粒度的内容，同时返回更丰富的信息。例如，句子窗口检索会获取小的文本块，并返回检索片段周围的相关句子窗口。在自动合并检索中，文档被组织成树状结构。该过程先获取子节点，再检索包含其子节点内容的父节点。\nRAPTOR采用递归嵌入、聚类和文本块摘要的方法，直到无法进一步聚类为止，从而构建多层树状结构。\nPrompt-RAG通过预先生成目录来提高检索准确性，使模型能够根据查询自主选择相关章节。\n\n\n4.2.3 检索器微调\n在稠密检索中检索器依赖于一个高效的嵌入模型，来表示相关内容并为生成器提供输入，从而提升系统性能。\n可以通过特定领域或任务相关的数据进行微调，以提升在目标领域的性能。\nREPLUG将语言模型视为黑盒，并根据最终结果更新检索模型。\nAPICoder使用Python文件以及API名称、签名和描述对检索模型进行微调。\nEDITSUM对检索模型进行微调，以减小检索后摘要之间的杰卡德距离。\n最新的模型Qwen3系列开源了多种embedding和rerank模型，并开放了技术报告，效果很好。其中小模型适合用来做微调测试和效果对比。\n\n\n4.2.4 混合检索\n混合检索指同时采用多种不同的检索方法或从多个不同的来源提取信息。\nRAP-Gen、BlendedRAG 和ReACC均同时使用密集检索器和稀疏检索器来提高检索质量。\nRencos使用稀疏检索器在句法层面检索相似的代码片段，并使用密集检索器在语义层面检索相似的代码片段。\nBASHEXPLAINER首先使用密集检索器捕获语义信息，然后使用稀疏检索器获取词汇信息。\nRetDream先通过文本进行检索，再通过图像嵌入进行检索。\nCRAG的特点是配备了一个检索评估器，用于衡量文档与查询的相关性，并根据置信度生成三种检索响应：如果结果准确，则直接用于知识优化；如果结果不正确，则进行网络搜索；对于模糊情况，则采用混合方法。\n\n\n4.2.5 Rerank\n重排序应该是最常见的方式，指对检索到的内容进行重新排序，以获得更高的多样性和更好的结果。也有很多重排序的模型开源可以使用。\nRe2G在传统检索器之后应用了一个重排序器模型，以减少因将文本压缩为向量而导致的信息丢失所带来的影响。\nAceCoder利用选择器对检索到的程序进行重排序，以减少冗余程序并获得多样化的检索程序。\nXRICL在检索后使用基于蒸馏的示例重排序器。\nRangan采用量化影响度量，通过评估查询和参考之间的统计偏差来衡量数据子集的相似性，并对检索结果进行重排序。\nUDAPDR利用大语言模型经济高效地生成用于训练特定领域重排序器的合成查询，然后应用多教师知识蒸馏来开发一个协同的检索器。\n\n\n4.2.6 检索转换\n检索转换通过重新表述检索到的内容，以更好地激发生成器的潜力，从而改进输出结果。\nFILCO能高效地从检索到的文本中清除无关内容，只保留相关的支持性内容，从而简化生成器的任务，有助于准确预测答案。\nFiD-Light首先使用编码器将检索到的内容转换为向量，然后对其进行压缩，大幅减少了延迟时间。\n\n\n\n4.3 生成器增强\n\n4.3.1 提示工程-Prompt Engineering\n提示工程是一种专注于提高大型语言模型输出质量的提示工程技术，如提示压缩、后退提示、主动提示、思维链提示等，均适用于检索增强生成系统中的大型语言模型生成器。\nLLMLingua应用一个小型模型来压缩查询的整体长度，以加速模型推理，减轻无关信息对模型的负面影响，并缓解中间迷失现象。\nReMoDiffuse通过使用ChatGPT将复杂描述分解为结构化文本脚本。\nASAP将包含输入代码、函数定义、分析结果和相应注释的示例元组纳入提示词中，以获得更好的结果。\nCEDAR使用设计好的提示词模板，将代码演示、查询和自然语言指令组织成提示词。\nXRICL利用思维链技术，在跨语言语义解析和推理中添加翻译对作为中间步骤。\nACTIVERAG采用认知连接机制来校准大语言模型的内在认知，并在答案生成中应用思维链提示词。\nMake-An-Audio能够使用其他模态作为输入，这可以为后续过程提供更丰富的信息。\n\n\n4.3.2 解码调优\n解码调优包括通过微调超参数来增强生成器控制，以提高多样性、限制输出词汇量以及进行其他调整。\nInferFix通过调整解码器的温度来平衡结果的多样性和质量。（温度可以理解为一个参数，控制模型生成内容的发散程度）\nSYNCHROMESH通过实施补全引擎来消除实现错误，从而限制解码器的输出词汇量。\n\n\n4.3.3 生成器微调\n生成器的微调可以增强模型掌握更精确领域知识的能力，或使其更好地与检索器相适配。\nRETRO固定了检索器的参数，并在生成器中使用分块交叉注意力机制来结合查询和检索器的内容。\nCARE 利用图像、音频和视频-文本对训练编码器，然后微调解码器（生成器）以同时减少字幕和概念检测损失，同时保持编码器和检索器固定。\nAnimate-A-Story利用图像数据优化视频生成器，然后微调LoRA适配器以捕捉给定角色的外观细节。\n\n\n\n4.4 结果增强\n\n4.4.1 输出重写\n输出重写指的是在特定场景下对生成器生成的内容进行改写，以满足下游任务的需求。\nSARGAM通过采用一种特殊的Transformer，结合删除分类器、占位符分类器和插入分类器，在代码相关任务中优化输出，使其更贴合现实世界的代码语境。\nRing根据生成器产生的每个令牌的对数概率平均值对候选结果进行重新排序，从而获得多样化的结果。\nCBR-KBQA通过将生成的关系与知识图谱中查询实体的本地邻域所呈现的关系进行对齐，来修正结果。\n\n\n\n4.5 流程增强 Pipeline Enhancement\nRAG流程增强指的是对RAG的整个流程进行优化，以获得更好的性能结果。\n\n4.5.1 自适应检索\n一些关于RAG的研究表明，检索并非总能提升最终结果。当模型固有的参数化知识足以回答相关问题时，过度检索可能会导致资源浪费，并可能造成混淆。因此有些方法研究是否应该进行RAG。\n\n基于规则\n\nFLARE会在生成过程中主动决定是否以及何时对概率进行搜索。\nEfficient-KNNLM将 KNN-LM 和 NPM的生成概率与超参数 λ 相结合，以确定生成和检索的比例。\n还有对问题进行统计分析，以便为高频问题提供直接答案，并对低频问题应用检索增强生成等。\n\n基于模型\n\nSelf-RAG使用训练过的生成器，根据不同用户查询下的检索令牌来决定是否执行检索。\nSKR利用大型语言模型自身的能力预先判断其是否能够回答该问题，若能回答，则不执行检索。\nRowen将一个问题翻译成多种语言，并检查这些语言版本答案的一致性，以此来决定是否需要信息检索。\nAdaptiveRAG通过一个较小的语言模型作为分类器，根据查询的复杂程度动态决定是否进行检索。\n\n\n\n\n4.5.2 迭代式检索增强生成\n迭代式检索增强生成通过在检索和生成阶段反复循环来逐步优化结果，实际就是进行多轮操作\nRepoCoder采用迭代检索-生成方法进行代码补全，利用先前生成的代码优化查询，以更好地利用分散的信息并改善结果。\nITER-RETGEN通过使用生成器的输出来确定知识缺口、检索必要信息并为未来的生成周期提供信息，从而迭代地提高内容质量。\nSelfMemory迭代地利用检索增强生成器来构建一个庞大的记忆池，记忆选择器从该池中挑选输出，为下一个生成周期提供信息。\nRAT首先由大语言模型通过零样本思维链提示生成内容，然后通过从外部知识库检索知识来修改每个思维步骤。"
  },
  {
    "objectID": "content/blogs/entries/一文了解RAG.html#rag的多跳多领域问题graph-rag",
    "href": "content/blogs/entries/一文了解RAG.html#rag的多跳多领域问题graph-rag",
    "title": "一文了解RAG",
    "section": "5 RAG的多跳多领域问题（Graph RAG）",
    "text": "5 RAG的多跳多领域问题（Graph RAG）\n在RAG中有一个非常经典的瓶颈问题：有些问题并不是在找某一段最相似的文本，而是在要求把分散在多篇文档、多个概念、甚至多个领域的线索串起来，形成综合结论。当回答需要沿着共享实体、属性或关系在不同信息片段间穿行，并在此基础上生成新的洞察时，单纯依赖向量相似度检索往往不够用。这就是RAG需要面对的多跳与多领域问题。\nGraphRAG（Graph Retrieval-Augmented Generation）可以被看作是为这两类问题准备的一条升级路线，它不只检索语义相近的文本块，而是把知识显式表示成图结构，例如从文本中抽取实体与关系形成知识图谱或图索引，并利用图中的关系结构来组织证据与推进推理。\nIBM对GraphRAG的定义很贴近工程实践：GraphRAG是一种引入图结构数据的高级RAG；不同于仅靠向量检索语义相似文本，它利用图的关系结构来检索与处理信息，尤其擅长多跳推理、关系上下文以及层级结构数据的组织与查询。"
  },
  {
    "objectID": "content/blogs/entries/一文了解RAG.html#多模态rag",
    "href": "content/blogs/entries/一文了解RAG.html#多模态rag",
    "title": "一文了解RAG",
    "section": "6 多模态RAG",
    "text": "6 多模态RAG\n\n6.1 多模态大模型\n随着大语言模型技术的不断发展，多模态甚至全模态大模型已经成为重要研究对象，并不断发展，现在多模态大模型也逐渐成为主流，给人们的生活带来便利，值得一提的是，gemini图像生成真的很强，下面的图就是它生成的，直观地展示了多模态大模型从早期的图文基础连接（如CLIP, DALL-E）起步，经历多感官融合（如GPT-4V, Gemini），最终迈向全模态实时交互与通用人工智能（AGI）的完整技术演进路线图。使用的提示词是：“生成一张介绍多模态大模型发展历程的图片”，很简单的提示词，但是生成的图挺科幻的。\n\n\n\n6.2 多模态检索增强生成\n随着多模态大模型的发展，研究者开始探索多模态检索增强生成（Multimodal RAG），即让系统不仅能检索文本，还能利用图像、音频、视频以及代码等多种数据源作为知识依据。比较特殊的是，RAG的核心思想和流程在不同模态之间基本保持一致，不过需要在检索器、生成器和相关技术细节上进行调整。\n多模态RAG的基本理念是：针对不同模态的数据，引入对应的编码器将它们映射到可比较的向量空间，从而支持跨模态检索。例如，系统可以将图像用视觉模型编码为向量、将文本用语言模型编码为向量，并建立统一或可对齐的检索索引。当用户以文本提出查询时，检索模块不仅可以返回相关文本片段，也可以返回相关图像、音频片段或视频片段作为补充信息。目前多模态检索最常见的是图文两种模态，更深入的细节往往与VLM相关，后面会进一步介绍。\n多模态RAG在需要综合视觉与文本信息的任务中展现出独特价值。例如在跨媒体问答场景中，用户给出一张图片并提出与之相关的问题，系统可以先对图像内容进行理解，再结合检索到的外部知识文本回答更深入的问题，例如图片中的人物背景、地点信息或历史事件脉络等。又如在视频问答或多媒体搜索中，系统可以综合检索字幕文本、视频关键帧、片段摘要乃至音频线索来获得更全面的信息。\n一些研究将多模态RAG用于视觉问答任务，证明结合图像内容与外部知识能够回答一些仅凭图像本身难以回答的问题。业界也出现了支持多模态检索的开源工具与框架，例如使用CLIP类模型编码图文以实现跨模态搜索。总体而言，多模态RAG拓展了传统RAG只能处理纯文本的限制，为系统提供了面向多模态世界的外部证据通道，使生成结果更丰富且更可核验。\n\n\n6.3 多模态RAG难题\n\n不同模态的数据格式各异，如何对齐多模态表示是关键，常见做法是基于大规模图文对、音频与转写文本等进行对比学习，使不同模态向量落在语义一致的空间中。\n检索过程可能需要在不同模态间跳转，例如以图搜文或以文搜图，这要求索引能够存储多模态信息并支持任意模态查询到任意模态内容。\n多模态数据规模大且检索计算开销高，尤其是在海量图像或视频片段上做近似最近邻检索时，对成本与延迟都是挑战。一些系统会采用先转文本再检索的策略，例如对图片做OCR或生成描述后再进入文本检索流程，以兼容现有文本检索体系，但这可能丢失关键视觉细节。更偏前沿的方法倾向于保留原始模态信息，让检索结果直接返回图像或视频内容，并由多模态生成模型端到端完成理解与生成，从而减少中间表示带来的信息损失。"
  },
  {
    "objectID": "content/blogs/entries/一文了解RAG.html#rag的应用",
    "href": "content/blogs/entries/一文了解RAG.html#rag的应用",
    "title": "一文了解RAG",
    "section": "7 RAG的应用",
    "text": "7 RAG的应用\n\n7.1 应用分类\n\n文本RAG\n\n问答：通过从海量且全面的文本资源集合中提取信息，对提出的问题做出回应。\n事实核查：通常是指判断给定的自然语言文本与相关的主张或断言是否与文本中的事实相符。\n常识推理：指的是机器利用所获取的外部知识及其应用，以类人的方式对问题或任务进行推断或做出决策的能力。\n人机对话：包括机器理解自然语言的能力，以及熟练运用这种技能与人类进行无缝交流的能力。\n神经机器翻译：将文本从源语言自动翻译为目标语言。\n事件抽取：这是自然语言处理中的一个过程，它涉及识别文本中的特定事件并对其进行分类，同时将这些事件与相关实体关联起来。\n摘要生成：从冗长的文本中提炼关键信息，并生成一个简洁、连贯的摘要，以概括主要主题。\n\n代码RAG\n\n代码生成：将自然语言描述转换为代码实现。\n代码摘要：将代码转换为自然语言描述。\n代码补全：代码补全类似于下一句预测任务的代码版本。\n自动程序修复：基于查询的RAG常用于自动程序修复中，以帮助生成模型修复有缺陷的代码\nText2SQL和基于代码的语义解析：语义解析将自然语言转换为清晰的结构化表示，例如SQL或其他特定领域语言，通常会借助代码的帮助。\n\n知识RAG\n\n知识库问答：通常利用知识库来确定问题的正确答案。\n知识增强的开放域问答：主要是对结构化知识的应用。\n表格问答：表格作为另一种结构化知识形式，也有助于问答。\n\n3D RAG\n\nText-2-3D：检索可用于增强3D资产生成。\n\n图像 RAG\n\n图像生成：指的是创建新图像的过程，通常运用人工智能和机器学习领域的算法。\n图像摘要： 是生成图像文本描述的过程。\n\n视频 RAG\n\n视频摘要：将视觉内容转化为描述性语句。\n视频问答和对话：视频问答与对话会生成与视频内容一致的单轮或多轮响应。\n\n音频 RAG\n\n音频字幕生成：音频 captioning 本质上是一项序列到序列任务，它为音频数据生成自然语言数据\n音频生成：通常根据自然语言提示合成音频。\n\n科学领域 RAG\n\n药物发现：药物发现的目标是生成能同时满足多种特性的分子。\n生物医学信息学增强：通过从生物医学领域特定数据库中检索信息，提高了大语言模型的表达能力，从而增强了模型为医疗领域的任务提供有价值指导的能力。\n数学问答：数学领域的检索增强生成技术简化了解题过程，促进了研究创新，并优化了教育策略。\n\n\n\n\n7.2 应用领域\n个人与企业内部知识库 这类应用致力于解决私有数据的检索与问答难题，它将公司内部文档、手册或个人笔记进行结构化处理与向量化索引，当用户提问时系统能够定位到文件中的相关段落并由大模型基于证据生成答案，从而在很多场景中替代传统关键词搜索并显著提升信息获取效率。\n学术论文深度阅读与溯源 针对科研人员需要处理海量文献且对准确性要求极高的场景，这类应用能够跨多篇论文检索证据并生成综述或回答，其核心特点是强调证据可追溯与引用对齐，尽可能让每一个关键结论都能回到原文依据，从而最大化降低幻觉带来的风险。\n超大规模代码库智能助手 为了解决传统大模型难以一次性读完完整项目代码的问题，这类应用会对代码仓库的结构、符号与依赖关系进行索引，让开发者能够用自然语言查询项目架构或具体函数实现细节，并在证据范围内给出解释与修改建议，从而更高效地理解与维护复杂的遗留代码。\n\n\n7.3 Ima\nima是腾讯开发的Ai知识库工具，核心就是采用RAG，目前支持导入公众号文章构建知识库进行检索。\n在公众号中文章中点击转发，将文章导入知识库，之后可以通过AI进行相关问答。\n\n\n\n7.4 Coze\nCoze空间是字节跳动旗下AI应用开发平台扣子，是一个多智能体协作开发环境，它允许开发者在一个统一的画布式界面中，将多个AI Agent、工具、数据源和工作流编排成复杂的自动化任务系统，实现从单一聊天机器人到多角色协同、多步骤执行的进阶AI应用构建。\n我们下面使用其中的Agent和知识库构建功能，构建一个八股问答姬。\n首先导入文本，构建知识库，然后创建智能体，并进行测试，测试能从知识库中检索对应信息，这是一个知识库RAG的应用。\n  \n\n\n7.5 Ragflow\nRAGFlow是领先的开源检索增强生成（RAG）引擎，它融合了尖端的RAG与智能体功能，为大语言模型打造卓越的上下文层。它提供了精简的RAG工作流，适用于任何规模的企业。在融合的上下文引擎和预制智能体模板的支持下，RAGFlow使开发者能够将复杂数据转化为高保真、可投入生产的人工智能系统，且效率和精度都极为出色。\n它可以进行本地部署和使用。"
  },
  {
    "objectID": "content/blogs/entries/一文了解RAG.html#数据集benchmark",
    "href": "content/blogs/entries/一文了解RAG.html#数据集benchmark",
    "title": "一文了解RAG",
    "section": "8 数据集&Benchmark",
    "text": "8 数据集&Benchmark\n\n8.1 Others;\n\n噪声鲁棒性，测试大型语言模型能否从含噪声的文档中提取必要信息\n负例拒绝，评估大型语言模型在检索到的内容不足时能否拒绝回答\n信息整合，检查大型语言模型能否通过整合多个检索到的内容来获取知识并进行回答\n反事实鲁棒性，判断大型语言模型能否识别检索到的内容中的反事实错误\n忠实性，基于检索到的内容评估事实准确性\n答案相关性，判断结果是否针对查询\n上下文相关性，评估检索到的内容的相关性及其简洁性\nCRUD-RAG将RAG任务分为四种类型：创建、读取、更新和删除，并通过文本续写、问答、幻觉纠正和开放域多文档摘要来对其进行评估\n我之前用过的数据集TreezzZ/WebQA，测试多模态效果，这玩意本身就是一个benchmark，包含问答对，通过简单脚本处理就能使用\n\n\n\n8.2 多模态RAG\n\n8.2.1 数据集\n\n\n\n图像-文本数据集\n\n\nLAION-400M：4亿对图文数据；用于多模态模型的预训练（图像-文本） Conceptual-Captions：超过300万对图像-标题；多语言的英德图像描述（图像-文本）CIRR：来自21,552张图像的36,554个三元组；侧重于自然图像关系（图像-文本）MS-COCO：33万张带字幕的图像；用于字幕到图像和图像到字幕的生成（图像-文本）Flickr30K：31K张图像，每张图像都配有5个英文 caption（图像-文本）Multi30K：30k条来自母语者的德语字幕和人工翻译的字幕（图像-文本）NoCaps：用于零样本图像 captioning 评估；15K 张图像（图像-文本）Laion-5B：58.5亿个图像-文本对被用作检索的外部存储器（图像-文本）COCO-CN：用于跨语言标记和带中文句子的图像描述的20,341张图像（图像-文本）CIRCO：1020个查询，每个查询平均有4.53个基准真值；用于组合图像检索（图像-文本）MINT-1T：1万亿个文本标记和34亿张图像；比现有的开源数据集大10倍（图像-文本）ShareGPT4V：120万张图片，配有GPT-4生成的说明文字，包括空间和事实细节（图像-文本）OmniCorpus：22亿个网页文档中的86亿张图像和1.7万亿个标记；交错的文本-图像布局（图像-文本）\n\n\n\n\n视频-文本数据集\n\n\nBDD-X：77小时的驾驶视频，配有专家的文字解释；用于可解释的驾驶行为研究（视频-文本）YouCook2：2000个带有对齐描述的烹饪视频；专注于视频-文本任务（视频-文本）ActivityNet：20,000个带有多个字幕的视频；用于视频理解和字幕生成（视频-文本）SoccerNet：550场足球比赛的视频和元数据；包括转录的解说和关键事件注释（视频-文本）MSVD：1970个视频，每个视频大约有40条字幕（视频-文本）LSMDC：来自202部电影的118,081个视频-文本对；一个电影描述数据集（视频-文本）DiDemo：10,000个视频，每个视频有4个拼接的字幕；包含事件的时间定位（视频-文本）COIN：涵盖180项任务的11,827个教学类YouTube视频，用于全面的教学视频分析（视频-文本）MSRVTT-QA：视频问答基准（视频-文本）ActivityNet-QA：58,000个人工标注的问答对，涉及5,800个视频；视频问答模型的基准（视频-文本）EpicKitchens-100：用于在线动作预测的700个视频（100小时的烹饪活动）；以自我为中心的视觉数据集（视频-文本）Ego4D：430万个以自我为中心的视频的视频-文本对；大规模以自我为中心的视频数据集（视频-文本）HowTo100M：来自120万个YouTube视频的1.36亿个带字幕的视频片段；用于学习文本-视频嵌入（视频-文本）CharadesEgo：来自第一视角和第三人称视角视频的68,536个活动实例；用于评估（视频-文本）ActivityNet：20K个视频，每个视频有3.7个时间定位的句子；对视频中的事件进行密集字幕标注（视频-文本）\n\n\n\n\n音频-文本数据集\n\n\nLibriSpeech：1000小时的英语朗读语音及对应文本；基于有声读物的语音识别语料库（音频-文本）SpeechBrown：55K对语音-文本样本；15个类别，涵盖从宗教到小说的各种主题（音频-文本）AudioCaps：46K个音频片段与人工编写的文本字幕配对（音频-文本）MusicCaps：它由5.5k个音乐-文本对组成，配有人类专家提供的丰富文本描述（音频-文本）Clotho：包含多样化音景的音频字幕数据集（音频-文本）WavCaps：大规模弱标记音频-文本数据集，包含约40万个带配对字幕的音频片段（音频-文本）Spoken SQuAD：SQuAD数据集的音频版本，用于口语问答，侧重于听力理解任务（音频-文本）AudioSet：来自YouTube的2,084,320个人工标注的10秒音频片段；632个音频事件类别（音频-文本）\n\n\n\n\n知识与问答数据集\n\n\nVQA：用于视觉问答的40万个带图像的问答对（图像-文本）PAQ：6500万个基于文本的问答对；一个大规模数据集（文本）ELI5：270K个复杂多样的问题，配有网页和图像作为补充（文本）MultimodalQA：29,918个需要对文本、表格和图像进行多模态多跳推理的问题（图像-文本-表格）ViQuAE：来自维基百科的1180万个段落，涵盖2397个独特实体；知识密集型问答（文本）OK-VQA：14K个需要外部知识的视觉问答问题（图像-文本）WebQA：46K个需要跨文本和图像进行推理的查询（图像-文本）Infoseek：使用基于维基百科的知识库（600万个段落）进行细粒度视觉知识检索（图像-文本）ClueWeb22：100亿个网页被分为三个子集；一个大规模的网络语料库（文本）MOCHEG：15,601个带有真实性标签的声明，并附有文本和图像证据（图像-文本）VQA：110万个问题（通过VG-QA问题扩充），用于微调VQA模型（图像-文本）A-OKVQA：使用世界知识进行视觉问答的基准；约25000个问题（图像-文本）XL-HeadTags：415K条新闻标题-文章对包含来自六个不同语系的20种语言（文本）DocVQA：12767张不同的文档图像，包含50K个问答对，按推理类型分类，用于评估文档视觉问答（DocVQA）方法（图像-文本）ChartQA：9.6K个人工编写的问答对 + 23.1K个从图表摘要生成的问答对（图像-文本）DVQA：30万个图表上的350万个问答对，用于评估结构、数据检索和推理能力（图像-文本）\n\n\n\n\n医学数据集\n\n\nMIMIC-CXR：125,417个胸部X光片和报告的训练对（图像-文本）CheXpert：65,240名患者的224,316张胸部X光片；专注于医学分析（图像-文本）MIMIC-III：超过4万名患者的健康相关数据（文本）IU-Xray：7470对胸部X光片和相应的诊断报告（图像-文本）PubLayNet：从PubLayNet构建了100,000个训练样本和2,160个测试样本（医疗领域定制）（图像-文本）Quilt-1M：438K张医学图像，配有768K个文本对；包含显微图像和UMLS实体（图像-文本）\n\n\n\n\n时尚数据集\n\n\nFashion-IQ：三个类别共77,684张图像；采用Recall@10和Recall@50进行评估 （图像-文本）FashionGen：260.5K 个时尚图像和物品描述的图像-文本对（图像-文本）VITON-HD：83K张用于虚拟试穿的图像；高分辨率服装物品（图像-文本）Fashionpedia：48,000张带有分割掩码和细粒度属性标注的时尚图像（图像-文本）DeepFashion：约80万张多样化的时尚图片，用于伪三元组生成（图像-文本）\n\n\n\n\n3D数据集\n\n\nShapeNet：涵盖55个常见物体类别，包含51300个独特的3D模型（3D-文本）\n\n\n\n\nOthers\n\n\nGeoDE：来自6个世界地区的40个类别中的61,940张图像；强调物体识别中的地理多样性（图像）RU-AI ：147万个真实内容与AI生成内容的样本，用于虚假检测的稳健性（图像-文本-音频）MIMIC-IT：用于模型对齐的280万个多模态指令-响应对（图像-视频-文本）MMVQA：横跨3146份多页研究PDF，包含26.2万个问答对，用于稳健的多模态信息检索（图像-文本）\n\n\n\n\n\n8.2.2 Benchmark\n\n\n\n跨模态\n\n\nMRAG-Bench：评估视觉检索、整合以及对不相关视觉信息的鲁棒性（图像）M2⁢R⁢A⁢G：对多模态检索增强生成（RAG）进行基准测试；评估检索、多跳推理和整合能力（图像-文本）Dyn-VQA：专注于动态检索、多跳推理以及对变化信息的鲁棒性（图像-文本）MMBench：涵盖视觉问答、图像描述、检索；评估跨视觉、文本和音频的跨模态理解能力（图像-文本-音频）ScienceQA：包含21,208个问题；通过文本、图表和图像测试科学推理能力（图像-表格-文本）SK-VQA：提供200万个问答对；专注于合成知识、多模态推理和外部知识整合（图像-文本）SMMQG：包含1024个问答对；侧重于合成多模态数据和受控问题生成（图像-文本）\n\n\n\n\n文本\n\n\nTriviaQA：提供65万个问答对；阅读理解数据集，适用于多模态检索增强生成（RAG）（文本）Natural Questions：包含307,373个训练示例；真实世界的搜索查询，可适配视觉语境（文本）\n\n\n\n\n\n8.2.3 评估指标\n\n检索评估\n\n准确率\n召回率和Recall@K：用于检查前K个结果中的相关项目，比标准召回率更受青睐\n精确率和Top-K准确率\n\n\n\nF1分数\n平均倒数排名（MRR）：用于衡量返回列表中第一个相关结果的排名位置，其中Q是查询的总数。r⁢a⁢n⁢kq是查询q的第一个相关结果的排名。\n\n\n模态评估\n\n文本评估\n\n精确匹配（EM）\nBLEU\n\n\n\n\nROUGE：用于评估文本摘要和生成\nROUGE-N：用于衡量生成文本与参考文本之间 N 元语法的重叠度\n\n\n\nROUGE-L：衡量生成文本与参考文本之间的最长公共子序列（LCS）\n\n\n\nMETEOR\n\n图像评估\n\n图像描述\n\nCIDEr（基于共识的图像描述评估）：利用TF-IDF和余弦相似度来衡量描述质量\nSPICE（语义命题图像描述评估）\nSPIDEr ：结合CIDEr和SPICE\n\n语义对齐\n\nBERTScore\nCLIPScore\n\n\n图像质量\n\nFID\n\n\n\nKID\nInception Score：通过分类概率评估图像的多样性和质量"
  },
  {
    "objectID": "content/blogs/entries/一文了解RAG.html#参考资料",
    "href": "content/blogs/entries/一文了解RAG.html#参考资料",
    "title": "一文了解RAG",
    "section": "参考资料",
    "text": "参考资料\n为什么大家都用RAG，这篇小白都看懂了\nRetrieval-Augmented Generation for AI-Generated Content: A Survey\nAsk in Any Modality: A Comprehensive Survey on Multimodal Retrieval-Augmented Generation\n未完待续，后续我们会对文章进行优化，并提供相关图片、数据集、代码和文献链接等，这是一个长期不断优化的过程！"
  },
  {
    "objectID": "content/blogs/entries/Windows安装Jekyll.html",
    "href": "content/blogs/entries/Windows安装Jekyll.html",
    "title": "Windows安装Jekyll",
    "section": "",
    "text": "之前分享了如何在GitHub上搭建个人博客，但缺少Jekyll的安装教程。最近换了新电脑，正好借此机会补上这个重要的环节，为想要搭建技术博客的朋友们提供一份详细的Windows安装指南。\n\n\nJekyll基于Ruby开发，所以我们首先需要安装Ruby环境：\n\n访问Ruby官网下载适合你的RubyInstaller\n我选择的是rubyinstaller-devkit-3.4.7-1-x64版本\n你也可以根据系统配置选择合适的版本\n\n\n安装时的关键步骤：\n\n双击下载的安装程序，按提示进行安装\n重要：务必勾选”添加到PATH”选项，方便在命令行中直接使用\n安装过程中会自动安装MSYS2，这是后续安装gem和Jekyll的必要组件\n\n\n安装完成后，打开命令提示符测试是否安装成功：\nruby -v\n\n\n\n\nRubyGems是Ruby的包管理器，我们需要用它来安装Jekyll：\n\n前往RubyGems下载页面\n选择ZIP格式下载\n\n\n安装步骤：\n\n将下载的ZIP文件解压到合适的目录\n在解压后的文件夹中打开命令提示符\n运行安装命令：\n\nruby setup.rb\n\n\n\n\n现在我们可以开始安装Jekyll了：\n安装Jekyll核心：\ngem install jekyll\n安装分页插件（很多主题都需要）：\ngem install jekyll-paginate\n验证安装是否成功：\njekyll -v\n\n\n\n在你的Jekyll博客目录中，启动本地服务器：\nbundle exec jekyll server\n如果提示缺少某些插件，按照提示安装即可：\n\n安装完成后重新运行，看到成功提示：\n\n在浏览器中访问 http://localhost:4000，就能看到你的博客在本地运行的效果了！\n\n\n\n\n恭喜！现在你已经在Windows上成功安装了Jekyll，可以开始本地开发和测试你的博客了。如果在安装过程中遇到任何问题，欢迎在评论区留言交流。\n贴心提示：建议将整个安装过程记录下来，这样下次换电脑或者重装系统时就能快速完成环境配置。\n参考资源：在Windows上安装Jekyll\n博客作者简介 大家好，我是一名热爱分享的技术博主，专注于Web开发和开源技术。通过这个博客，我希望与大家分享我的学习心得和实践经验，帮助更多开发者解决实际问题。如果你对技术分享感兴趣，欢迎关注我的博客，我们一起成长！"
  },
  {
    "objectID": "content/blogs/entries/Windows安装Jekyll.html#第一步安装ruby环境",
    "href": "content/blogs/entries/Windows安装Jekyll.html#第一步安装ruby环境",
    "title": "Windows安装Jekyll",
    "section": "",
    "text": "Jekyll基于Ruby开发，所以我们首先需要安装Ruby环境：\n\n访问Ruby官网下载适合你的RubyInstaller\n我选择的是rubyinstaller-devkit-3.4.7-1-x64版本\n你也可以根据系统配置选择合适的版本\n\n\n安装时的关键步骤：\n\n双击下载的安装程序，按提示进行安装\n重要：务必勾选”添加到PATH”选项，方便在命令行中直接使用\n安装过程中会自动安装MSYS2，这是后续安装gem和Jekyll的必要组件\n\n\n安装完成后，打开命令提示符测试是否安装成功：\nruby -v"
  },
  {
    "objectID": "content/blogs/entries/Windows安装Jekyll.html#第二步安装rubygems",
    "href": "content/blogs/entries/Windows安装Jekyll.html#第二步安装rubygems",
    "title": "Windows安装Jekyll",
    "section": "",
    "text": "RubyGems是Ruby的包管理器，我们需要用它来安装Jekyll：\n\n前往RubyGems下载页面\n选择ZIP格式下载\n\n\n安装步骤：\n\n将下载的ZIP文件解压到合适的目录\n在解压后的文件夹中打开命令提示符\n运行安装命令：\n\nruby setup.rb"
  },
  {
    "objectID": "content/blogs/entries/Windows安装Jekyll.html#第三步安装jekyll及相关组件",
    "href": "content/blogs/entries/Windows安装Jekyll.html#第三步安装jekyll及相关组件",
    "title": "Windows安装Jekyll",
    "section": "",
    "text": "现在我们可以开始安装Jekyll了：\n安装Jekyll核心：\ngem install jekyll\n安装分页插件（很多主题都需要）：\ngem install jekyll-paginate\n验证安装是否成功：\njekyll -v"
  },
  {
    "objectID": "content/blogs/entries/Windows安装Jekyll.html#第四步本地测试",
    "href": "content/blogs/entries/Windows安装Jekyll.html#第四步本地测试",
    "title": "Windows安装Jekyll",
    "section": "",
    "text": "在你的Jekyll博客目录中，启动本地服务器：\nbundle exec jekyll server\n如果提示缺少某些插件，按照提示安装即可：\n\n安装完成后重新运行，看到成功提示：\n\n在浏览器中访问 http://localhost:4000，就能看到你的博客在本地运行的效果了！"
  },
  {
    "objectID": "content/blogs/entries/Windows安装Jekyll.html#安装完成",
    "href": "content/blogs/entries/Windows安装Jekyll.html#安装完成",
    "title": "Windows安装Jekyll",
    "section": "",
    "text": "恭喜！现在你已经在Windows上成功安装了Jekyll，可以开始本地开发和测试你的博客了。如果在安装过程中遇到任何问题，欢迎在评论区留言交流。\n贴心提示：建议将整个安装过程记录下来，这样下次换电脑或者重装系统时就能快速完成环境配置。\n参考资源：在Windows上安装Jekyll\n博客作者简介 大家好，我是一名热爱分享的技术博主，专注于Web开发和开源技术。通过这个博客，我希望与大家分享我的学习心得和实践经验，帮助更多开发者解决实际问题。如果你对技术分享感兴趣，欢迎关注我的博客，我们一起成长！"
  },
  {
    "objectID": "content/blogs/entries/Deepseek-R1-32B模型部署.html",
    "href": "content/blogs/entries/Deepseek-R1-32B模型部署.html",
    "title": "Deepseek-R1-32B模型部署",
    "section": "",
    "text": "这段时间国产大模型deepseek受到广泛关注，deepseek也开源了他们模型的参数，在huggingface上，提供了原始模型和经过不同程度蒸馏的模型\n因为好奇，手边刚好也有之前白嫖的阿里云的服务器，就尝试一下本地部署的过程\n本文简单介绍一下部署的过程，也提供一个gradio的示例，进行模型的使用\n\n\n\n\n免费试用，可以选择交互式建模进行试用。\n\n\n注册阿里云账号并选择试用即可\n\n\n\n\n\n首先在阿里云创建一个实例\n\n然后选择选择A10的GPU和图中所示的镜像\n\n之后等待实例创建完成，进入实例环境，点击右上方加号，进入命令行\n\n\n\n\n\n在命令行进行模型下载与测试\n\n1、设置Hugging Face镜像源\n export HF_ENDPOINT=https://hf-mirror.com\n2、下载DeepSeek-R1 32B模型\nhuggingface-cli download Valdemardi/DeepSeek-R1-Distill-Qwen-32B-AWQ --cache-dir /mnt/workspace/Valdemardi/DeepSeek-R1-Distill-Qwen-32B-AWQ\n3、测试模型是否能加载成功\n vllm serve Valdemardi/DeepSeek-R1-Distill-Qwen-32B-AWQ --quantization awq_marlin --max-model-len 1024 --max-num-batched-tokens 2048 --max-num-seqs 1 --tensor-parallel-size 1 --port 8003 --enforce-eager --gpu_memory_utilization=0.90 --enable-chunked-prefill\n\n相关参数说明： quantization awq_marlin：启用AWQ量化，显著降低显存占用。 max-model-len 1024：设置最大序列长度为1024个token，适用于大部分NLP任务。 max-num-batched-tokens 2048：设置批量处理的token数为512，平衡处理速度和显存占用。 max-num-seqs 1：设置同时处理的序列数为1，避免多序列处理带来的显存碎片。 tensor-parallel-size 1：禁用 tensor 并行，最大化利用显存。 port 8003：设置服务监听端口为8003。 enforce-eager：启用 eager 模式，加快推理速度。 gpu_memory_utilization 0.90：设置显存使用率为98%，尽可能多地利用显存。 enable-chunked-prefill：启用分块预填充，减少显存碎片。\n\n\n\n\n\n\n使用gradio加载vllm推理模型，进行可视化交互，使用的代码如下：\n\nimport gradio as gr\nimport requests\nfrom subprocess import Popen, PIPE\nimport threading\nimport time\nimport json\n\n# ============== 配置参数 ==============\nMODEL_NAME = \"DeepSeek-R1-Distill-Qwen-32B-AWQ\"\nVLLM_PORT = 8003\nGRADIO_PORT = 7860\n\nVLLM_CMD = [\n    \"vllm\", \"serve\", MODEL_NAME,\n    \"--quantization\", \"awq\",\n    \"--max-model-len\", \"1024\",\n    \"--max-num-batched-tokens\", \"2048\",\n    \"--max-num-seqs\", \"1\",\n    \"--tensor-parallel-size\", \"1\",\n    \"--port\", str(VLLM_PORT),\n    \"--gpu-memory-utilization\", \"0.9\",\n    \"--enforce-eager\",\n    \"--disable-log-requests\",\n    \"--swap-space\", \"16\"\n]\n\n# ============== 服务管理类 ==============\nclass VLLMServer:\n    def __init__(self):\n        self.process = None\n        self._ready = threading.Event()\n        self.start_time = time.time()\n\n    def start(self):\n        try:\n            print(f\"正在加载模型 {MODEL_NAME}...\")\n            self.process = Popen(VLLM_CMD, stdout=PIPE, stderr=PIPE, text=True)\n            \n            def log_monitor():\n                while self.process.poll() is None:\n                    line = self.process.stderr.readline()\n                    if \"Uvicorn running\" in line:\n                        print(\"vLLM服务启动成功！\")\n                        self._ready.set()\n                    if time.time() - self.start_time &gt; 600:\n                        print(\"模型加载超时，请检查显存是否足够\")\n                        self.process.terminate()\n                    print(\"[vLLM]\", line.strip())\n            \n            threading.Thread(target=log_monitor, daemon=True).start()\n            return True\n        except Exception as e:\n            print(f\"vLLM启动失败: {str(e)}\")\n            return False\n\n    def is_ready(self, timeout=600):\n        return self._ready.wait(timeout=timeout)\n\n# ============== 提示词构建 ==============\ndef build_prompt(history):\n    prompt = \"&lt;|beginofutterance|&gt;system\\n你是一个智能助手&lt;|endofutterance|&gt;\\n\"\n    for entry in history:\n        if entry[\"role\"] == \"user\":\n            prompt += f\"&lt;|beginofutterance|&gt;user\\n{entry['content']}&lt;|endofutterance|&gt;\\n\"\n        elif entry[\"role\"] == \"assistant\":\n            prompt += f\"&lt;|beginofutterance|&gt;assistant\\n{entry['content']}&lt;|endofutterance|&gt;\\n\"\n    prompt += \"&lt;|beginofutterance|&gt;assistant\\n\"\n    return prompt\n\n# ============== 流式生成逻辑 ==============\ndef stream_generator(history):\n    try:\n        response = requests.post(\n            f\"http://localhost:{VLLM_PORT}/v1/completions\",\n            headers={\"Content-Type\": \"application/json\"},\n            json={\n                \"model\": MODEL_NAME,\n                \"prompt\": build_prompt(history),\n                \"max_tokens\": 512,\n                \"temperature\": 0.7,\n                \"top_p\": 0.9,\n                \"stop\": [\"&lt;|endofutterance|&gt;\"],\n                \"stream\": True\n            },\n            stream=True,\n            timeout=120\n        )\n        response.raise_for_status()\n        \n        full_response = \"\"  # 用于缓存完整的助手回答\n        for chunk in response.iter_lines():\n            if chunk:\n                decoded = chunk.decode().replace(\"data: \", \"\")\n                try:\n                    data = json.loads(decoded)\n                    token = data[\"choices\"][0][\"text\"]\n                    full_response += token\n                    yield full_response  # 返回完整的生成内容（逐步追加）\n                except:\n                    pass\n                    \n    except requests.exceptions.ConnectionError:\n        yield \"服务未就绪，请稍后重试\"\n    except Exception as e:\n        yield f\"请求失败: {str(e)}\"\n\n# ============== 界面布局 ==============\nwith gr.Blocks(title=\"DeepSeek-32B vLLM版\") as demo:\n    gr.Markdown(\"## DeepSeek-R1-32B 智能助手 (vLLM版)\")\n    \n    status = gr.Textbox(label=\"服务状态\", interactive=False)\n    chatbot = gr.Chatbot(\n        height=500,\n        type=\"messages\",\n        label=\"对话历史\",\n        avatar_images=(\"user.png\", \"bot.png\")\n    )\n    msg = gr.Textbox(label=\"输入消息\", placeholder=\"请输入您的问题...\")\n    clear = gr.Button(\"清空历史\", variant=\"secondary\")\n\n    def user(user_message, history):\n        return \"\", history + [{\"role\": \"user\", \"content\": user_message}]\n\n    def bot(history):\n        if not history or history[-1][\"role\"] != \"user\":\n            yield history\n            return\n            \n        history.append({\"role\": \"assistant\", \"content\": \"\"})  # 添加空的助手消息\n        full_response = \"\"  # 用于存储完整回答\n        for chunk in stream_generator(history):\n            full_response = chunk  # 缓存生成的内容\n            yield history[:-1] + [{\"role\": \"assistant\", \"content\": full_response}]  # 更新生成的回答\n        \n        # 最终更新完整历史记录\n        history[-1][\"content\"] = full_response\n        yield history\n\n    msg.submit(user, [msg, chatbot], [msg, chatbot], queue=True).then(\n        bot, chatbot, chatbot\n    )\n    clear.click(lambda: [], None, chatbot, queue=False)\n\n    # 状态检查\n    demo.load(\n        fn=lambda: \"服务已就绪\" if vllm_server.is_ready() else \"启动中...\",\n        outputs=status\n    )\n\nif __name__ == \"__main__\":\n    vllm_server = VLLMServer()\n    print(\"正在启动vLLM服务...\")\n    threading.Thread(target=vllm_server.start, daemon=True).start()\n    \n    if vllm_server.is_ready():\n        print(\"启动Gradio界面...\")\n        demo.launch(\n            server_name=\"0.0.0.0\",\n            server_port=GRADIO_PORT,\n            share=False\n        )\n    else:\n        print(\"服务启动失败\")\n\n\n\n\n\n\n运行成功后点击下方链接即可打开界面\n\n\n\n\n从图中测试可以看出，数学方面好像有提升，但是草莓问题中的’r’还是不能数出有多少\n\n\n\n\n\n使用3090单显卡部署deepseek-r1 32B"
  },
  {
    "objectID": "content/blogs/entries/Deepseek-R1-32B模型部署.html#白嫖阿里云服务器",
    "href": "content/blogs/entries/Deepseek-R1-32B模型部署.html#白嫖阿里云服务器",
    "title": "Deepseek-R1-32B模型部署",
    "section": "",
    "text": "免费试用，可以选择交互式建模进行试用。\n\n\n注册阿里云账号并选择试用即可"
  },
  {
    "objectID": "content/blogs/entries/Deepseek-R1-32B模型部署.html#模型下载和加载测试",
    "href": "content/blogs/entries/Deepseek-R1-32B模型部署.html#模型下载和加载测试",
    "title": "Deepseek-R1-32B模型部署",
    "section": "",
    "text": "首先在阿里云创建一个实例\n\n然后选择选择A10的GPU和图中所示的镜像\n\n之后等待实例创建完成，进入实例环境，点击右上方加号，进入命令行\n\n\n\n\n\n在命令行进行模型下载与测试\n\n1、设置Hugging Face镜像源\n export HF_ENDPOINT=https://hf-mirror.com\n2、下载DeepSeek-R1 32B模型\nhuggingface-cli download Valdemardi/DeepSeek-R1-Distill-Qwen-32B-AWQ --cache-dir /mnt/workspace/Valdemardi/DeepSeek-R1-Distill-Qwen-32B-AWQ\n3、测试模型是否能加载成功\n vllm serve Valdemardi/DeepSeek-R1-Distill-Qwen-32B-AWQ --quantization awq_marlin --max-model-len 1024 --max-num-batched-tokens 2048 --max-num-seqs 1 --tensor-parallel-size 1 --port 8003 --enforce-eager --gpu_memory_utilization=0.90 --enable-chunked-prefill\n\n相关参数说明： quantization awq_marlin：启用AWQ量化，显著降低显存占用。 max-model-len 1024：设置最大序列长度为1024个token，适用于大部分NLP任务。 max-num-batched-tokens 2048：设置批量处理的token数为512，平衡处理速度和显存占用。 max-num-seqs 1：设置同时处理的序列数为1，避免多序列处理带来的显存碎片。 tensor-parallel-size 1：禁用 tensor 并行，最大化利用显存。 port 8003：设置服务监听端口为8003。 enforce-eager：启用 eager 模式，加快推理速度。 gpu_memory_utilization 0.90：设置显存使用率为98%，尽可能多地利用显存。 enable-chunked-prefill：启用分块预填充，减少显存碎片。"
  },
  {
    "objectID": "content/blogs/entries/Deepseek-R1-32B模型部署.html#gradio交互",
    "href": "content/blogs/entries/Deepseek-R1-32B模型部署.html#gradio交互",
    "title": "Deepseek-R1-32B模型部署",
    "section": "",
    "text": "使用gradio加载vllm推理模型，进行可视化交互，使用的代码如下：\n\nimport gradio as gr\nimport requests\nfrom subprocess import Popen, PIPE\nimport threading\nimport time\nimport json\n\n# ============== 配置参数 ==============\nMODEL_NAME = \"DeepSeek-R1-Distill-Qwen-32B-AWQ\"\nVLLM_PORT = 8003\nGRADIO_PORT = 7860\n\nVLLM_CMD = [\n    \"vllm\", \"serve\", MODEL_NAME,\n    \"--quantization\", \"awq\",\n    \"--max-model-len\", \"1024\",\n    \"--max-num-batched-tokens\", \"2048\",\n    \"--max-num-seqs\", \"1\",\n    \"--tensor-parallel-size\", \"1\",\n    \"--port\", str(VLLM_PORT),\n    \"--gpu-memory-utilization\", \"0.9\",\n    \"--enforce-eager\",\n    \"--disable-log-requests\",\n    \"--swap-space\", \"16\"\n]\n\n# ============== 服务管理类 ==============\nclass VLLMServer:\n    def __init__(self):\n        self.process = None\n        self._ready = threading.Event()\n        self.start_time = time.time()\n\n    def start(self):\n        try:\n            print(f\"正在加载模型 {MODEL_NAME}...\")\n            self.process = Popen(VLLM_CMD, stdout=PIPE, stderr=PIPE, text=True)\n            \n            def log_monitor():\n                while self.process.poll() is None:\n                    line = self.process.stderr.readline()\n                    if \"Uvicorn running\" in line:\n                        print(\"vLLM服务启动成功！\")\n                        self._ready.set()\n                    if time.time() - self.start_time &gt; 600:\n                        print(\"模型加载超时，请检查显存是否足够\")\n                        self.process.terminate()\n                    print(\"[vLLM]\", line.strip())\n            \n            threading.Thread(target=log_monitor, daemon=True).start()\n            return True\n        except Exception as e:\n            print(f\"vLLM启动失败: {str(e)}\")\n            return False\n\n    def is_ready(self, timeout=600):\n        return self._ready.wait(timeout=timeout)\n\n# ============== 提示词构建 ==============\ndef build_prompt(history):\n    prompt = \"&lt;|beginofutterance|&gt;system\\n你是一个智能助手&lt;|endofutterance|&gt;\\n\"\n    for entry in history:\n        if entry[\"role\"] == \"user\":\n            prompt += f\"&lt;|beginofutterance|&gt;user\\n{entry['content']}&lt;|endofutterance|&gt;\\n\"\n        elif entry[\"role\"] == \"assistant\":\n            prompt += f\"&lt;|beginofutterance|&gt;assistant\\n{entry['content']}&lt;|endofutterance|&gt;\\n\"\n    prompt += \"&lt;|beginofutterance|&gt;assistant\\n\"\n    return prompt\n\n# ============== 流式生成逻辑 ==============\ndef stream_generator(history):\n    try:\n        response = requests.post(\n            f\"http://localhost:{VLLM_PORT}/v1/completions\",\n            headers={\"Content-Type\": \"application/json\"},\n            json={\n                \"model\": MODEL_NAME,\n                \"prompt\": build_prompt(history),\n                \"max_tokens\": 512,\n                \"temperature\": 0.7,\n                \"top_p\": 0.9,\n                \"stop\": [\"&lt;|endofutterance|&gt;\"],\n                \"stream\": True\n            },\n            stream=True,\n            timeout=120\n        )\n        response.raise_for_status()\n        \n        full_response = \"\"  # 用于缓存完整的助手回答\n        for chunk in response.iter_lines():\n            if chunk:\n                decoded = chunk.decode().replace(\"data: \", \"\")\n                try:\n                    data = json.loads(decoded)\n                    token = data[\"choices\"][0][\"text\"]\n                    full_response += token\n                    yield full_response  # 返回完整的生成内容（逐步追加）\n                except:\n                    pass\n                    \n    except requests.exceptions.ConnectionError:\n        yield \"服务未就绪，请稍后重试\"\n    except Exception as e:\n        yield f\"请求失败: {str(e)}\"\n\n# ============== 界面布局 ==============\nwith gr.Blocks(title=\"DeepSeek-32B vLLM版\") as demo:\n    gr.Markdown(\"## DeepSeek-R1-32B 智能助手 (vLLM版)\")\n    \n    status = gr.Textbox(label=\"服务状态\", interactive=False)\n    chatbot = gr.Chatbot(\n        height=500,\n        type=\"messages\",\n        label=\"对话历史\",\n        avatar_images=(\"user.png\", \"bot.png\")\n    )\n    msg = gr.Textbox(label=\"输入消息\", placeholder=\"请输入您的问题...\")\n    clear = gr.Button(\"清空历史\", variant=\"secondary\")\n\n    def user(user_message, history):\n        return \"\", history + [{\"role\": \"user\", \"content\": user_message}]\n\n    def bot(history):\n        if not history or history[-1][\"role\"] != \"user\":\n            yield history\n            return\n            \n        history.append({\"role\": \"assistant\", \"content\": \"\"})  # 添加空的助手消息\n        full_response = \"\"  # 用于存储完整回答\n        for chunk in stream_generator(history):\n            full_response = chunk  # 缓存生成的内容\n            yield history[:-1] + [{\"role\": \"assistant\", \"content\": full_response}]  # 更新生成的回答\n        \n        # 最终更新完整历史记录\n        history[-1][\"content\"] = full_response\n        yield history\n\n    msg.submit(user, [msg, chatbot], [msg, chatbot], queue=True).then(\n        bot, chatbot, chatbot\n    )\n    clear.click(lambda: [], None, chatbot, queue=False)\n\n    # 状态检查\n    demo.load(\n        fn=lambda: \"服务已就绪\" if vllm_server.is_ready() else \"启动中...\",\n        outputs=status\n    )\n\nif __name__ == \"__main__\":\n    vllm_server = VLLMServer()\n    print(\"正在启动vLLM服务...\")\n    threading.Thread(target=vllm_server.start, daemon=True).start()\n    \n    if vllm_server.is_ready():\n        print(\"启动Gradio界面...\")\n        demo.launch(\n            server_name=\"0.0.0.0\",\n            server_port=GRADIO_PORT,\n            share=False\n        )\n    else:\n        print(\"服务启动失败\")"
  },
  {
    "objectID": "content/blogs/entries/Deepseek-R1-32B模型部署.html#效果测试",
    "href": "content/blogs/entries/Deepseek-R1-32B模型部署.html#效果测试",
    "title": "Deepseek-R1-32B模型部署",
    "section": "",
    "text": "运行成功后点击下方链接即可打开界面\n\n\n\n\n从图中测试可以看出，数学方面好像有提升，但是草莓问题中的’r’还是不能数出有多少"
  },
  {
    "objectID": "content/blogs/entries/Deepseek-R1-32B模型部署.html#参考",
    "href": "content/blogs/entries/Deepseek-R1-32B模型部署.html#参考",
    "title": "Deepseek-R1-32B模型部署",
    "section": "",
    "text": "使用3090单显卡部署deepseek-r1 32B"
  },
  {
    "objectID": "content/papers/labnotes/index.html",
    "href": "content/papers/labnotes/index.html",
    "title": "个人研究相关论文",
    "section": "",
    "text": "个人研究相关论文阅读笔记\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n个人研究相关论文阅读笔记\n\n\n\n个人研究\n\nLabNotes\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/papers/deepseek/index.html",
    "href": "content/papers/deepseek/index.html",
    "title": "DeepSeek",
    "section": "",
    "text": "DeepSeek论文阅读笔记\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDeepSeek\n\n\n\nLLM\n\nPaper\n\nReport\n\nDeepSeek\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/learning-notes/infrastructure/index.html",
    "href": "content/learning-notes/infrastructure/index.html",
    "title": "基础设施学习笔记",
    "section": "",
    "text": "记录一下基础设施相关的学习笔记.\n基础设施是指支撑应用程序运行的硬件、软件和网络资源。它包括服务器、存储设备、网络设备、操作系统、数据库等。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConsul\n\n\n\ngolang\n\n微服务\n\n基础设施\n\nconsul\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n基础设施(golang)\n\n\n\ngolang\n\n微服务\n\n基础设施\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/learning-notes/golang/index.html",
    "href": "content/learning-notes/golang/index.html",
    "title": "golang",
    "section": "",
    "text": "记录一下golang学习过程中的笔记.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngo的版本管理工具-g的安装和使用\n\n\n\ngolang\n\ng\n\ngolang版本管理\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（13）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 20, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（12）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 20, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（11）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 20, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（10）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 20, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（9）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 19, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（8）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 18, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（7）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 17, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（6）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 16, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（5）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 14, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（4）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 13, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（3）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nSep 29, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（2）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nSep 23, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（1）-在win搭建go环境\n\n\n\ngolang\n\n环境搭建\n\n\n\n\n\n\n\n\n\nSep 16, 2024\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/learning-notes/algorithm/index.html",
    "href": "content/learning-notes/algorithm/index.html",
    "title": "算法学习笔记",
    "section": "",
    "text": "不开long long见祖宗，不过golang没long long(笑)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngolang实现hot100题解(ACM版本)\n\n\n\n算法\n\nleetcode\n\nhot100\n\n\n\n\n\n\n\n\n\nNov 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nleetcode-灵神跟练-滑动窗口与双指针-不定长滑动窗口-越长越合法+求最短+最小\n\n\n\n算法\n\nleetcode\n\n滑动窗口\n\n不定长滑动窗口\n\n\n\n\n\n\n\n\n\nNov 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nleetcode-灵神跟练-滑动窗口与双指针-定长滑动窗口-基础\n\n\n\n算法\n\nleetcode\n\n滑动窗口与双指针\n\n\n\n\n\n\n\n\n\nNov 9, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "pages/home.html",
    "href": "pages/home.html",
    "title": "Home主页",
    "section": "",
    "text": "这里是首页，汇总各模块最近更新内容。\n\n\nThis is the home page with the latest updates from each module.\n\n\n\nBlogs博客\n\n\n\n\n\n\n\n\n\n\n\n一文了解RAG\n\n\n\nRAG\n\nLLM\n\n\n\n\n\n\n\n\n\nJan 1, 2026\n\n\n\n\n\n\n\n\n\n\n\n\n本地服务器低速传输解决方案\n\n\n\n技术\n\n技术实践\n\nssh\n\n网络\n\n\n\n\n\n\n\n\n\nDec 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nMac安装Jekyll\n\n\n\nGitHub\n\nBlog\n\nJekyll\n\n\n\n\n\n\n\n\n\nOct 24, 2025\n\n\n\n\n\nNo matching items\n\n\n\n\nProjects项目\n\n\n\n\n\n\n\n\n\nDaily Log Maker\n\n\n\nselfTools\n\n前端\n\n每日记录\n\n\n\n\n\n\n\n\n\n\nNov 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nGesture-Fireworks\n\n\n\nselfTools\n\n前端\n\n手指烟花\n\nFireworks\n\n\n\n\n\n\n\n\n\n\nNov 16, 2025\n\n\n\n\n\n\n\n\n\n\n\nQuarto-Blogs-Template\n\n\n\nQuarto\n\nBlog\n\n\n\n\n\n\n\n\n\n\nNov 16, 2025\n\n\n\n\n\n\nNo matching items\n\n\n\n\nPapers论文\n\n\n\n\n\n\n\n\n\n\n\nDeepSeek\n\n\n\nLLM\n\nPaper\n\nReport\n\nDeepSeek\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n个人研究相关论文阅读笔记\n\n\n\n个人研究\n\nLabNotes\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\nNo matching items\n\n\n\n\nLearning Notes学习笔记\n\n\n\n\n\n\n\n\n\n\n\ngolang实现hot100题解(ACM版本)\n\n\n\n算法\n\nleetcode\n\nhot100\n\n\n\n\n\n\n\n\n\nNov 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nleetcode-灵神跟练-滑动窗口与双指针-不定长滑动窗口-越长越合法+求最短+最小\n\n\n\n算法\n\nleetcode\n\n滑动窗口\n\n不定长滑动窗口\n\n\n\n\n\n\n\n\n\nNov 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nleetcode-灵神跟练-滑动窗口与双指针-定长滑动窗口-基础\n\n\n\n算法\n\nleetcode\n\n滑动窗口与双指针\n\n\n\n\n\n\n\n\n\nNov 9, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "pages/index.html",
    "href": "pages/index.html",
    "title": "About Me关于我",
    "section": "",
    "text": "我是 aorangehc(He Cheng)\n\n\n这是我的邮箱，欢迎联系：morange0205@gmail.com\n\n\n\n\n\ngolang后端开发\n\n\n大模型应用开发\n\n\nLLM实现和部署\n\n\n\n\n\n\n\n2024 - 2027 [硕士学位/网络空间安全] [北京邮电大学]\n\n\n2020 - 2024 [学士学位/计算机科学与技术] [北方工业大学]\n\n\n\n\n\n\n\n[2025.1-2025.7] [科研实习] [中科院软件所] — [MindSpore框架下经典NLP模型复现和优化]\n\n\n[2025.8-2025.10] [后端开发实习] [长亭科技] — [参与长亭科技项目的后端开发、多模态RAG拓展和项目优化]\n\n\n\n\n\n\n\n[年份] [项目名称] [一句话描述/亮点] GitHub · Blog\n\n\n\n\n\n\nGolang 开发 LLM 深度学习 联邦学习\n\n\n\n\n\nI am aorangehc(He Cheng)\n\n\nThis is my email, feel free to contact me: morange0205@gmail.com\n\n\n\n\n\nGolang Backend Development\n\n\nLarge Model Application Development\n\n\nLLM Implementation and Deployment\n\n\n\n\n\n\n\n2024 - 2027 [Master’s Degree/Cyberspace Security] [Beijing University of Posts and Telecommunications]\n\n\n2020 - 2024 [Bachelor’s Degree/Computer Science and Technology] [North China University of Technology]\n\n\n\n\n\n\n\n[Jan 2025 - Jul 2025] [Research Intern] [Institute of Software, Chinese Academy of Sciences] — [Reproduction and optimization of classic NLP models under MindSpore framework]\n\n\n[Aug 2025 - Oct 2025] [Backend Development Intern] [Chaitin Technology] — [Participated in backend development, multimodal RAG expansion and project optimization for Chaitin Technology projects]\n\n\n\n\n\n\n\n[Years] [Project Name] [One-sentence Description/Highlight] GitHub · Blog\n\n\n\n\n\n\nGolang Development LLM Deep Learning Federated Learning"
  },
  {
    "objectID": "pages/index.html#方向",
    "href": "pages/index.html#方向",
    "title": "About Me关于我",
    "section": "",
    "text": "golang后端开发\n\n\n大模型应用开发\n\n\nLLM实现和部署"
  },
  {
    "objectID": "pages/index.html#教育经历",
    "href": "pages/index.html#教育经历",
    "title": "About Me关于我",
    "section": "",
    "text": "2024 - 2027 [硕士学位/网络空间安全] [北京邮电大学]\n\n\n2020 - 2024 [学士学位/计算机科学与技术] [北方工业大学]"
  },
  {
    "objectID": "pages/index.html#工作经历",
    "href": "pages/index.html#工作经历",
    "title": "About Me关于我",
    "section": "",
    "text": "[2025.1-2025.7] [科研实习] [中科院软件所] — [MindSpore框架下经典NLP模型复现和优化]\n\n\n[2025.8-2025.10] [后端开发实习] [长亭科技] — [参与长亭科技项目的后端开发、多模态RAG拓展和项目优化]"
  },
  {
    "objectID": "pages/index.html#项目",
    "href": "pages/index.html#项目",
    "title": "About Me关于我",
    "section": "",
    "text": "[年份] [项目名称] [一句话描述/亮点] GitHub · Blog"
  },
  {
    "objectID": "pages/index.html#技术栈",
    "href": "pages/index.html#技术栈",
    "title": "About Me关于我",
    "section": "",
    "text": "Golang 开发 LLM 深度学习 联邦学习"
  },
  {
    "objectID": "pages/index.html#focus-areas",
    "href": "pages/index.html#focus-areas",
    "title": "About Me关于我",
    "section": "",
    "text": "Golang Backend Development\n\n\nLarge Model Application Development\n\n\nLLM Implementation and Deployment"
  },
  {
    "objectID": "pages/index.html#education",
    "href": "pages/index.html#education",
    "title": "About Me关于我",
    "section": "",
    "text": "2024 - 2027 [Master’s Degree/Cyberspace Security] [Beijing University of Posts and Telecommunications]\n\n\n2020 - 2024 [Bachelor’s Degree/Computer Science and Technology] [North China University of Technology]"
  },
  {
    "objectID": "pages/index.html#experience",
    "href": "pages/index.html#experience",
    "title": "About Me关于我",
    "section": "",
    "text": "[Jan 2025 - Jul 2025] [Research Intern] [Institute of Software, Chinese Academy of Sciences] — [Reproduction and optimization of classic NLP models under MindSpore framework]\n\n\n[Aug 2025 - Oct 2025] [Backend Development Intern] [Chaitin Technology] — [Participated in backend development, multimodal RAG expansion and project optimization for Chaitin Technology projects]"
  },
  {
    "objectID": "pages/index.html#projects",
    "href": "pages/index.html#projects",
    "title": "About Me关于我",
    "section": "",
    "text": "[Years] [Project Name] [One-sentence Description/Highlight] GitHub · Blog"
  },
  {
    "objectID": "pages/index.html#technical-skills",
    "href": "pages/index.html#technical-skills",
    "title": "About Me关于我",
    "section": "",
    "text": "Golang Development LLM Deep Learning Federated Learning"
  },
  {
    "objectID": "content/blogs/index.html",
    "href": "content/blogs/index.html",
    "title": "Blogs博客",
    "section": "",
    "text": "Short essays, reviews, and research notes.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n一文了解RAG\n\n\n\nRAG\n\nLLM\n\n\n\n\n\n\n\n\n\nJan 1, 2026\n\n\n\n\n\n\n\n\n\n\n\n\n本地服务器低速传输解决方案\n\n\n\n技术\n\n技术实践\n\nssh\n\n网络\n\n\n\n\n\n\n\n\n\nDec 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nMac安装Jekyll\n\n\n\nGitHub\n\nBlog\n\nJekyll\n\n\n\n\n\n\n\n\n\nOct 24, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nPC的快捷指令\n\n\n\nWindows\n\nMac\n\nLinux\n\nInstruction\n\n\n\n\n\n\n\n\n\nOct 24, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nWindows安装Jekyll\n\n\n\nGitHub\n\nBlog\n\nJekyll\n\n\n\n\n\n\n\n\n\nOct 24, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n基于BM25检索算法构建RAG智能文档问答助手–学习和实践\n\n\n\n大模型\n\nRAG\n\n信息检索\n\n智能助手\n\n\n\n\n\n\n\n\n\nMar 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nDeepseek-R1-32B模型部署\n\n\n\n大模型\n\n部署\n\nDeepseek\n\n\n\n\n\n\n\n\n\nJan 25, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n如何使用git\n\n\n\n技术\n\ngit\n\n指令\n\n\n\n\n\n\n\n\n\nJan 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n开源协议\n\n\n\n技术\n\n技术理论\n\n\n\n\n\n\n\n\n\nJan 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n一种免费、高清、安全、但是很麻烦的远程桌面连接方案\n\n\n\n技术\n\n技术实践\n\n\n\n\n\n\n\n\n\nJan 11, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n保姆教程如何创建自己的“个人网站”\n\n\n\nGitHub\n\nBlog\n\nJekyll\n\n\n\n\n\n\n\n\n\nSep 15, 2024\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/learning-notes/deepL/index.html",
    "href": "content/learning-notes/deepL/index.html",
    "title": "深度学习学习笔记",
    "section": "",
    "text": "记录一下深度学习相关的学习笔记.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n通过案例了解机器学习\n\n\n\n深度学习\n\n深度学习基础\n\n\n\n\n\n\n\n\n\nAug 26, 2024\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/learning-notes/index.html",
    "href": "content/learning-notes/index.html",
    "title": "Learning Notes学习笔记",
    "section": "",
    "text": "课程学习笔记.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngo的版本管理工具-g的安装和使用\n\n\n\ngolang\n\ng\n\ngolang版本管理\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\ngo-zero的API语言\n\n\n\ngolang\n\n微服务\n\napi\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nGo-Kit 微服务框架\n\n\n\ngolang\n\n微服务\n\ngo-kit\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nGo-Zero 微服务框架\n\n\n\ngolang\n\n微服务\n\ngo-zero\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nProtobuf\n\n\n\ngolang\n\n微服务\n\nProtobuf\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n微服务框架(golang)\n\n\n\ngolang\n\n微服务\n\n框架\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nConsul\n\n\n\ngolang\n\n微服务\n\n基础设施\n\nconsul\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n基础设施(golang)\n\n\n\ngolang\n\n微服务\n\n基础设施\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（13）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 20, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（12）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 20, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（11）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 20, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（10）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 20, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（9）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 19, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（8）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 18, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（7）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 17, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（6）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 16, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（5）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 14, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（4）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nOct 13, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（3）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nSep 29, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（2）\n\n\n\ngolang\n\ngolang基础学习\n\n\n\n\n\n\n\n\n\nSep 23, 2024\n\n\n\n\n\n\n\n\n\n\n\n\ngolang学习记录（1）-在win搭建go环境\n\n\n\ngolang\n\n环境搭建\n\n\n\n\n\n\n\n\n\nSep 16, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n通过案例了解机器学习\n\n\n\n深度学习\n\n深度学习基础\n\n\n\n\n\n\n\n\n\nAug 26, 2024\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/learning-notes/microservices/index.html",
    "href": "content/learning-notes/microservices/index.html",
    "title": "微服务学习笔记",
    "section": "",
    "text": "记录一下微服务学习过程中的笔记.主要语言还是golang.\n相关代码仓库github: aorangehc/GoFramwork\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngo-zero的API语言\n\n\n\ngolang\n\n微服务\n\napi\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nGo-Kit 微服务框架\n\n\n\ngolang\n\n微服务\n\ngo-kit\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nGo-Zero 微服务框架\n\n\n\ngolang\n\n微服务\n\ngo-zero\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nProtobuf\n\n\n\ngolang\n\n微服务\n\nProtobuf\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n微服务框架(golang)\n\n\n\ngolang\n\n微服务\n\n框架\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/papers/index.html",
    "href": "content/papers/index.html",
    "title": "Paper&Report论文和技术报告",
    "section": "",
    "text": "记录论文和技术报告阅读\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDeepSeek\n\n\n\nLLM\n\nPaper\n\nReport\n\nDeepSeek\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n个人研究相关论文阅读笔记\n\n\n\n个人研究\n\nLabNotes\n\n\n\n\n\n\n\n\n\nJan 16, 2025\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/projects/index.html",
    "href": "content/projects/index.html",
    "title": "Projects项目",
    "section": "",
    "text": "Project write-ups, demos, and technical summaries.\n\n\n\n\n\n\n\n\n\n\n\n\nDaily Log Maker\n\n\n\nselfTools\n\n前端\n\n每日记录\n\n\n\n\n\n\n\n\n\n\nNov 23, 2025\n\n\n\n\n\n\n\n\n\n\n\nGesture-Fireworks\n\n\n\nselfTools\n\n前端\n\n手指烟花\n\nFireworks\n\n\n\n\n\n\n\n\n\n\nNov 16, 2025\n\n\n\n\n\n\n\n\n\n\n\nQuarto-Blogs-Template\n\n\n\nQuarto\n\nBlog\n\n\n\n\n\n\n\n\n\n\nNov 16, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "content/blogs/entries/Mac安装Jekyll.html",
    "href": "content/blogs/entries/Mac安装Jekyll.html",
    "title": "Mac安装Jekyll",
    "section": "",
    "text": "更新了在Windows的Jekyll教程。顺便把环境在Mac上重新配置了一遍，把完整流程记录下来，给正在折腾博客的你一份可直接照做的macOS安装指南。\n\n本文默认你使用 zsh 终端（macOS 默认），并通过 rbenv 管理 Ruby 版本，避免系统自带 Ruby 的权限与兼容问题。\n\n\n\n\n\n\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n安装完成后，根据提示把 brew 加入 PATH，并重新打开终端或执行 source ~/.zshrc。\n\n\n\nbrew update\nbrew install rbenv ruby-build\n\n\n\necho 'eval \"$(rbenv init - zsh)\"' &gt;&gt; ~/.zshrc\nsource ~/.zshrc\n\n\n\n\n\n\n\nrbenv install 3.3.5\nrbenv global 3.3.5\nruby -v\n\n\n\ngem install bundler jekyll\n\n\n\n\n\n在你的博客主目录下运行：\nbundle install\nbundle exec jekyll serve\n看到成功提示后，在浏览器访问：\nhttp://127.0.0.1:4000\n\n\n\n\n恭喜！现在你已经在 macOS 上成功安装并运行了 Jekyll。后续可以在 _config.yml 中调整主题与配置、在 _posts 中编写文章，用 bundle exec jekyll build 生成静态文件进行部署。"
  },
  {
    "objectID": "content/blogs/entries/Mac安装Jekyll.html#第一步准备基础环境",
    "href": "content/blogs/entries/Mac安装Jekyll.html#第一步准备基础环境",
    "title": "Mac安装Jekyll",
    "section": "",
    "text": "/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n安装完成后，根据提示把 brew 加入 PATH，并重新打开终端或执行 source ~/.zshrc。\n\n\n\nbrew update\nbrew install rbenv ruby-build\n\n\n\necho 'eval \"$(rbenv init - zsh)\"' &gt;&gt; ~/.zshrc\nsource ~/.zshrc"
  },
  {
    "objectID": "content/blogs/entries/Mac安装Jekyll.html#第二步安装-ruby-与-jekyll",
    "href": "content/blogs/entries/Mac安装Jekyll.html#第二步安装-ruby-与-jekyll",
    "title": "Mac安装Jekyll",
    "section": "",
    "text": "rbenv install 3.3.5\nrbenv global 3.3.5\nruby -v\n\n\n\ngem install bundler jekyll"
  },
  {
    "objectID": "content/blogs/entries/Mac安装Jekyll.html#第三步在项目中安装依赖并启动",
    "href": "content/blogs/entries/Mac安装Jekyll.html#第三步在项目中安装依赖并启动",
    "title": "Mac安装Jekyll",
    "section": "",
    "text": "在你的博客主目录下运行：\nbundle install\nbundle exec jekyll serve\n看到成功提示后，在浏览器访问：\nhttp://127.0.0.1:4000"
  },
  {
    "objectID": "content/blogs/entries/Mac安装Jekyll.html#安装完成",
    "href": "content/blogs/entries/Mac安装Jekyll.html#安装完成",
    "title": "Mac安装Jekyll",
    "section": "",
    "text": "恭喜！现在你已经在 macOS 上成功安装并运行了 Jekyll。后续可以在 _config.yml 中调整主题与配置、在 _posts 中编写文章，用 bundle exec jekyll build 生成静态文件进行部署。"
  },
  {
    "objectID": "content/blogs/entries/pc的快捷指令.html",
    "href": "content/blogs/entries/pc的快捷指令.html",
    "title": "PC的快捷指令",
    "section": "",
    "text": "记录一下常见PC的快捷指令，主要是博主经常忘记，这里记录一下，方便后续查看。"
  },
  {
    "objectID": "content/blogs/entries/pc的快捷指令.html#windows",
    "href": "content/blogs/entries/pc的快捷指令.html#windows",
    "title": "PC的快捷指令",
    "section": "Windows",
    "text": "Windows"
  },
  {
    "objectID": "content/blogs/entries/pc的快捷指令.html#mac",
    "href": "content/blogs/entries/pc的快捷指令.html#mac",
    "title": "PC的快捷指令",
    "section": "Mac",
    "text": "Mac\n\n删除\n\n清空废纸篓：Cmd + Shift + Delete\n直接删除不经过废纸篓：Option + Cmd + Delete\n反向删除：Fn + Delete"
  },
  {
    "objectID": "content/blogs/entries/pc的快捷指令.html#linux",
    "href": "content/blogs/entries/pc的快捷指令.html#linux",
    "title": "PC的快捷指令",
    "section": "Linux",
    "text": "Linux"
  },
  {
    "objectID": "content/blogs/entries/一种免费、高清、安全、但是很麻烦的远程桌面连接方案.html",
    "href": "content/blogs/entries/一种免费、高清、安全、但是很麻烦的远程桌面连接方案.html",
    "title": "一种免费、高清、安全、但是很麻烦的远程桌面连接方案",
    "section": "",
    "text": "该方案能够解决的问题\n1、远程连接不受距离限制，通过tailscale实现，但是一定要保证网络的稳定\n2、免费高清串流，通过sunshine和moonlight实现\n3、安全，本方案中安全指的是远端的电脑屏幕在串流期间能够保持黑屏，能有效保护隐私，通过ParsecVDisplay诱骗电脑分屏实现\n\n\n\n\n通过上面的几个工具，大概能够推测出实现的原理 串流指的是将远程计算机的桌面环境、应用程序界面、音频和鼠标键盘输入等实时传输到另一台计算机或设备的过程。 在本方案中，通过ParsecVDisplay诱骗远端的分屏，然后将分屏串流到本地电脑，串流通过sunshine和moonlight实现。 在电脑上设置只在分屏显示，就可以实现主屏幕全程黑屏，保护隐私。然后通过tailscale将两个设备拉到同一个虚拟局域网中，实现不受距离限制的远程连接。\n\n基本原理如下图所示（画的比较糙了）\n\n相较于已有的方法，这个设置起来比较麻烦，但是免费、高清和安全还是非常诱人的。\n同时，这个方案有一个非常之名的缺点，这是由于分屏工具的一个BUG引起的。需要按照严格步骤才能防止意外地发生。\n\n\n\n这个工具的安装没有什么特别的，按照步骤进行安装即可，，可以点击下面的链接找到工具下载地址，如果是在Windows的环境中运行，可以按照图中的版本进行下载，实测有效。\n1、sunshine \n2、moonlight \n3、ParsecVDisplay \n4、tailscale \n注意： 1、sunshine要安装在远端的电脑上\n2、moonlight要安装在本地的电脑上\n3、ParsecVDisplay要安装在远端的电脑上\n4、tailscale在两个电脑上都要安装，注册完成后，登陆同一个账号即可\n\n\n\n在工具安装完成后，我们能够实现基本的串流，然后就是我们方案的实施\n\n\n打开moonlight，在右上角点击添加计算机，然后在框中输入远端主机的IP地址即可。 \n关于ip地址的获取：Win+R，输入cmd，回车，输入ipconfig，回车，找到IPv4地址即可。 \n同时为了能够更好的实现远程的连接推荐使用tailscale安装完成后分配的地址吗，这样可以实现更稳定的远程连接，电脑的ip地址离开局域网之后就不能用了。会自动更换其他地址，这会导致远程连接的失败。\n点击计算机列表中需要远程的电脑，第一次需要输入一个验证码，看到验证码后，在远程主机点击sunshine弹出的框，在框中输入就行。  \n输入完成后，就能实现最基本的电脑远程了。\n\n\n\n保持远程连接的状态下，打开ParsecVDisplay，右下角添加分屏，不过要记住分屏的名称 \n\n需要注意的是，分屏名称会发生变化，这也是 必要按照这个步骤执行的原因\n\n\n\n\n打开sunshine\n在配置中选择Audio/Video，将输出名称改成之前设置分屏的名称，然后重启sunshine\n\n\n这个时候会断连一次\n\n\n\n等待远程电脑的感叹号消失，连接回复正常，连接远程电脑 \n\n\n\n在设置里设置屏幕只在屏2显示，然后就可以实现远程电脑全程黑屏了。 \n\n\n\n先在设置中将原本的只在屏2显示改成复制这些屏幕，然后关闭ParsecVDisplay，然后将远端的电脑锁定，保证下次能正常连接。 \n之后用ctrl+alt+shift+Q退出moonlight就可以了\n\n只有按照上部步骤才能实现稳定连接，不然分屏工具会随机改变分屏名称，这是导致出现意外地原因，可以使用其他分屏工具进行实验 还有关于tailscale的配置和安装，可以参照相关教程\n\n\n\n\n\n\n这件事的灵感来源于跟师兄的聊天，由于初次接触远程连接，感觉很有趣，然后产生了能不能保护隐私的想法，从网上没找到合适方案。由此问师兄，师兄说不能实现吗，串流本质就是投屏，屏幕亮着才能实现吗，然后我就想起了可以借助分屏工具实现，最后测试一番才成功。 个人感觉很有趣，但是限制比较多，也很容易失败，但是也很实用不是吗。"
  },
  {
    "objectID": "content/blogs/entries/一种免费、高清、安全、但是很麻烦的远程桌面连接方案.html#基本原理",
    "href": "content/blogs/entries/一种免费、高清、安全、但是很麻烦的远程桌面连接方案.html#基本原理",
    "title": "一种免费、高清、安全、但是很麻烦的远程桌面连接方案",
    "section": "",
    "text": "通过上面的几个工具，大概能够推测出实现的原理 串流指的是将远程计算机的桌面环境、应用程序界面、音频和鼠标键盘输入等实时传输到另一台计算机或设备的过程。 在本方案中，通过ParsecVDisplay诱骗远端的分屏，然后将分屏串流到本地电脑，串流通过sunshine和moonlight实现。 在电脑上设置只在分屏显示，就可以实现主屏幕全程黑屏，保护隐私。然后通过tailscale将两个设备拉到同一个虚拟局域网中，实现不受距离限制的远程连接。\n\n基本原理如下图所示（画的比较糙了）\n\n相较于已有的方法，这个设置起来比较麻烦，但是免费、高清和安全还是非常诱人的。\n同时，这个方案有一个非常之名的缺点，这是由于分屏工具的一个BUG引起的。需要按照严格步骤才能防止意外地发生。"
  },
  {
    "objectID": "content/blogs/entries/一种免费、高清、安全、但是很麻烦的远程桌面连接方案.html#工具安装",
    "href": "content/blogs/entries/一种免费、高清、安全、但是很麻烦的远程桌面连接方案.html#工具安装",
    "title": "一种免费、高清、安全、但是很麻烦的远程桌面连接方案",
    "section": "",
    "text": "这个工具的安装没有什么特别的，按照步骤进行安装即可，，可以点击下面的链接找到工具下载地址，如果是在Windows的环境中运行，可以按照图中的版本进行下载，实测有效。\n1、sunshine \n2、moonlight \n3、ParsecVDisplay \n4、tailscale \n注意： 1、sunshine要安装在远端的电脑上\n2、moonlight要安装在本地的电脑上\n3、ParsecVDisplay要安装在远端的电脑上\n4、tailscale在两个电脑上都要安装，注册完成后，登陆同一个账号即可"
  },
  {
    "objectID": "content/blogs/entries/一种免费、高清、安全、但是很麻烦的远程桌面连接方案.html#实施步骤",
    "href": "content/blogs/entries/一种免费、高清、安全、但是很麻烦的远程桌面连接方案.html#实施步骤",
    "title": "一种免费、高清、安全、但是很麻烦的远程桌面连接方案",
    "section": "",
    "text": "在工具安装完成后，我们能够实现基本的串流，然后就是我们方案的实施\n\n\n打开moonlight，在右上角点击添加计算机，然后在框中输入远端主机的IP地址即可。 \n关于ip地址的获取：Win+R，输入cmd，回车，输入ipconfig，回车，找到IPv4地址即可。 \n同时为了能够更好的实现远程的连接推荐使用tailscale安装完成后分配的地址吗，这样可以实现更稳定的远程连接，电脑的ip地址离开局域网之后就不能用了。会自动更换其他地址，这会导致远程连接的失败。\n点击计算机列表中需要远程的电脑，第一次需要输入一个验证码，看到验证码后，在远程主机点击sunshine弹出的框，在框中输入就行。  \n输入完成后，就能实现最基本的电脑远程了。\n\n\n\n保持远程连接的状态下，打开ParsecVDisplay，右下角添加分屏，不过要记住分屏的名称 \n\n需要注意的是，分屏名称会发生变化，这也是 必要按照这个步骤执行的原因\n\n\n\n\n打开sunshine\n在配置中选择Audio/Video，将输出名称改成之前设置分屏的名称，然后重启sunshine\n\n\n这个时候会断连一次\n\n\n\n等待远程电脑的感叹号消失，连接回复正常，连接远程电脑 \n\n\n\n在设置里设置屏幕只在屏2显示，然后就可以实现远程电脑全程黑屏了。 \n\n\n\n先在设置中将原本的只在屏2显示改成复制这些屏幕，然后关闭ParsecVDisplay，然后将远端的电脑锁定，保证下次能正常连接。 \n之后用ctrl+alt+shift+Q退出moonlight就可以了\n\n只有按照上部步骤才能实现稳定连接，不然分屏工具会随机改变分屏名称，这是导致出现意外地原因，可以使用其他分屏工具进行实验 还有关于tailscale的配置和安装，可以参照相关教程"
  },
  {
    "objectID": "content/blogs/entries/一种免费、高清、安全、但是很麻烦的远程桌面连接方案.html#总结",
    "href": "content/blogs/entries/一种免费、高清、安全、但是很麻烦的远程桌面连接方案.html#总结",
    "title": "一种免费、高清、安全、但是很麻烦的远程桌面连接方案",
    "section": "",
    "text": "这件事的灵感来源于跟师兄的聊天，由于初次接触远程连接，感觉很有趣，然后产生了能不能保护隐私的想法，从网上没找到合适方案。由此问师兄，师兄说不能实现吗，串流本质就是投屏，屏幕亮着才能实现吗，然后我就想起了可以借助分屏工具实现，最后测试一番才成功。 个人感觉很有趣，但是限制比较多，也很容易失败，但是也很实用不是吗。"
  },
  {
    "objectID": "content/blogs/entries/基于BM25检索算法构建RAG智能文档问答助手--学习和实践.html",
    "href": "content/blogs/entries/基于BM25检索算法构建RAG智能文档问答助手--学习和实践.html",
    "title": "基于BM25检索算法构建RAG智能文档问答助手–学习和实践",
    "section": "",
    "text": "本篇文章记录DataWhale微学习中课程–从零打造RAG检索系统\n\n\n推一波DataWhale的学习内容，可以关注DataWhale公众号，选择自己喜欢的内容\n\n\n学习内容原作者的公众号: 从零打造RAG检索系统：BM25让检索快到飞起 github仓库地址: XiaokeAILabs\n\n\n文章重点是了解RAG检索的基础，运行作者代码测试工具效果\n\n\n\n\n\nRAG（Retrieval-Augmented Generation，检索增强生成）是一种结合检索和自然语言生成的技术，旨在提高生成模型的性能和效果。RAG的基本思想是在生成模型的输入中同时包含检索到的相关信息，从而提高生成模型的生成质量和准确性。\n想起之前使用过Langchain结合ChatGLM3-6B模型，实现过一个智能漏洞问答系统，用的应该就是RAG，不过当时对这些概念并不了解。\n在日常使用中的kimi、豆包和加入联网功能的DeepSeek，应该都应用到了这种技术，不过他们的实现原理和算法应该更加复杂，实现细节上可能也有不同。\n\n\n\nRAG的基本流程还是比较简单的，可以分成两个阶段：\n\n索引阶段:预处理并存储文档数据，构建检索索引\n查询阶段:接收用户查询，检索相关文档，将文档信息作为生成模型的输入，生成相应的回答\n\n\n\n\n想要实现一个完整的RAG过程需要上传并处理额外的文档和数据，这些数据可以是文本、图像、音频、视频等。然后要对这些数据进行处理，比如对文本进行分词、去除停用词、向量化……\n之后要构建检索索引，这一步可以使用多种算法，比如BM25、TF-IDF、向量检索等。\n最后就是生成模型，根据用户输入的信息，检索额外数据，将检索到的信息与用户查询结合，通过LLM生成最终答案。\n核心部分可以分成 1. 数据处理 2. 检索索引 3. 生成模型\n当然这是我自己的概括，不准确\n\n\n\nBM25（Best Matching 25）是一种经典的信息检索算法，是基于Okapi TF-IDF算法的改进版本，旨在解决Okapi TF-IDF算法的一些不足之处。它被广泛应用于信息检索领域的排名函数，用于估计文档D与用户查询Q之间的相关性。BM25是一种基于概率检索框架的改进，特别是在处理长文档和短查询时表现出色。它旨在评估一组查询项与文档的相关性，并为每个文档计算一个分数，该分数决定了文档在搜索结果中的排名。BM25的核心思想是基于词频（TF）和逆文档频率（IDF），同时还引入了文档的长度信息来计算文档D和查询Q之间的相关性。目前被广泛运用的搜索引擎ES就内置了BM25算法进行全文检索。\n具体计算公式就不详细介绍了。\n除了BM25，还有很多其他的检索算法，比如TF-IDF、向量检索、语义检索等。\n\n\n\n\n\n\n环境配置的过程一波三折，可能用linux环境运行更好？\nPython版本: 3.10+\n环境管理工具: conda\n打开cmd，使用下面的命令直接创建环境\nconda create --name RAG python=3.10\n\n\n\n原作者的github仓库地址XiaokeAILabs\n可以使用下面的指令直接git到本地\ngit clone https://github.com/li-xiu-qi/XiaokeAILabs.git\n\n\n\n先进入项目中的xiaoke_doc_assist_by_bm25文件夹，然后在该目录下进入cmd\n首先使用下面的指令安装依赖\npip install -r requirements.txt\n安装完成后在当前目录下创建 .env 文件，文件内容可以复制 .env.example 中的\n这里要配置调用模型的API，我之前在硅基流动免费领过额度，所以跟作者一样使用硅基流动的API和密钥\n如果使用硅基流动，直接修改 API_KEY=your_api_key\n\n也可以使用其他平台的API，比如 OpenAI、火山等，要修改 API_KEY 和 BASE_URL\n配置好后还要下载MinerU模型，用于高质量PDF解析\n在当前目录下使用下面指令，如果开了IDE也可以直接运行python文件\npython download_mineru_models.py\n\n\n\n\n在当前目录下使用下面指令运行项目\nstreamlit run main.py\n\n当然，这只是开始，我们仍旧有很多潜在的依赖没有安装，由于不知道安装啥，只能一遍遍运行启动项目的指令，根据报错信息安装，直到最后项目成功启动。\n\n总的来说，缺啥补啥，最后会运行成功的。\n下面是我的辛路历程\n1、缺少magic-pdf\n\n检查后这里需要升级magic-pdf\n使用指令\npip install --upgrade magic-pdf\n\n2、缺少paddle \n安装paddle\npip install paddle\n但是还会报错，缺少paddle的依赖 \n安装依赖\npip install common dual tight data prox\n安装之后发现还是报错\n\n搜索发现paddle太老了，应该升级安装paddlepaddle\n安装指令\npip install --upgrade paddlepaddle\n3、缺少cv2\n\n安装依赖\npip install opencv-python\n\n4、缺少ultralytics\n\n安装依赖\npip install ultralytics\n\n5、缺少doclayout_yolo\n\n安装依赖\npip install doclayout_yolo\n\n6、缺少pycocotools\n\n安装依赖\npip install pycocotools\n\n7、缺少detectron2\n\n安装依赖\n这个依赖的安装可以参考博客Windows11安装detectron2全流程记录帖（含torch安装）\n这个过程中可能会报错，缺少ninja\n使用下面指令安装\npip install ninja\n还会报错要安装Microsoft C++ Build Tools，可能是缺少C++编译器？\n如果有这个报错点击连接，安装就行，在安装的时候一定要勾选C++桌面开的部分\n解决上面两个问题后安装应该不会有问题\n8、缺少timm\n\n安装依赖\npip install timm\n\n9、缺少unimernet\n\n安装依赖\npip install unimernet\n\n10、缺少paddleocr \n安装依赖\npip install paddleocr\n\n11、缺少rapid_table\n\n安装依赖\npip install rapid_table\n12、缺少struct_eqtable\n\n安装依赖\npip install struct_eqtable\n\n13、缺少Stemmer\n\n安装依赖\npip install PyStemmer\n\n\n现在应该能正常运行项目了？\n\n在运行起来之后，我尝试上传文件，还有一个报错安装依赖\n\n安装依赖\npip install rapidocr_onnxruntime\n\n\n现在确实可以运行了\n\n\n\n\n\n在运行完成后，我上传了自己桌面上的一个论文，经过测试可以成功解析，但是不能够检索内容并喂给大模型，还没找到原因。\n之后我用作者提供的测试论文，发现可以成功运行。\n贴一张图：\n\n\n\n\n这是一个非常简单（可能也没那么简单），但是非常有意思的RAG检索系统，但是可以作为一个学习的起点，了解RAG检索的基本流程和原理。\n在实际应用中，RAG检索系统的实现可能会更加复杂，需要考虑更多的因素，比如数据处理、检索索引、生成模型等。\n现在运行项目还会有很多问题，后续我也会发现原因，或许实践构建一个自己的RAG检索系统？"
  },
  {
    "objectID": "content/blogs/entries/基于BM25检索算法构建RAG智能文档问答助手--学习和实践.html#rag及相关基础概念",
    "href": "content/blogs/entries/基于BM25检索算法构建RAG智能文档问答助手--学习和实践.html#rag及相关基础概念",
    "title": "基于BM25检索算法构建RAG智能文档问答助手–学习和实践",
    "section": "",
    "text": "RAG（Retrieval-Augmented Generation，检索增强生成）是一种结合检索和自然语言生成的技术，旨在提高生成模型的性能和效果。RAG的基本思想是在生成模型的输入中同时包含检索到的相关信息，从而提高生成模型的生成质量和准确性。\n想起之前使用过Langchain结合ChatGLM3-6B模型，实现过一个智能漏洞问答系统，用的应该就是RAG，不过当时对这些概念并不了解。\n在日常使用中的kimi、豆包和加入联网功能的DeepSeek，应该都应用到了这种技术，不过他们的实现原理和算法应该更加复杂，实现细节上可能也有不同。\n\n\n\nRAG的基本流程还是比较简单的，可以分成两个阶段：\n\n索引阶段:预处理并存储文档数据，构建检索索引\n查询阶段:接收用户查询，检索相关文档，将文档信息作为生成模型的输入，生成相应的回答\n\n\n\n\n想要实现一个完整的RAG过程需要上传并处理额外的文档和数据，这些数据可以是文本、图像、音频、视频等。然后要对这些数据进行处理，比如对文本进行分词、去除停用词、向量化……\n之后要构建检索索引，这一步可以使用多种算法，比如BM25、TF-IDF、向量检索等。\n最后就是生成模型，根据用户输入的信息，检索额外数据，将检索到的信息与用户查询结合，通过LLM生成最终答案。\n核心部分可以分成 1. 数据处理 2. 检索索引 3. 生成模型\n当然这是我自己的概括，不准确\n\n\n\nBM25（Best Matching 25）是一种经典的信息检索算法，是基于Okapi TF-IDF算法的改进版本，旨在解决Okapi TF-IDF算法的一些不足之处。它被广泛应用于信息检索领域的排名函数，用于估计文档D与用户查询Q之间的相关性。BM25是一种基于概率检索框架的改进，特别是在处理长文档和短查询时表现出色。它旨在评估一组查询项与文档的相关性，并为每个文档计算一个分数，该分数决定了文档在搜索结果中的排名。BM25的核心思想是基于词频（TF）和逆文档频率（IDF），同时还引入了文档的长度信息来计算文档D和查询Q之间的相关性。目前被广泛运用的搜索引擎ES就内置了BM25算法进行全文检索。\n具体计算公式就不详细介绍了。\n除了BM25，还有很多其他的检索算法，比如TF-IDF、向量检索、语义检索等。"
  },
  {
    "objectID": "content/blogs/entries/基于BM25检索算法构建RAG智能文档问答助手--学习和实践.html#基于bm25的rag检索系统运行",
    "href": "content/blogs/entries/基于BM25检索算法构建RAG智能文档问答助手--学习和实践.html#基于bm25的rag检索系统运行",
    "title": "基于BM25检索算法构建RAG智能文档问答助手–学习和实践",
    "section": "",
    "text": "环境配置的过程一波三折，可能用linux环境运行更好？\nPython版本: 3.10+\n环境管理工具: conda\n打开cmd，使用下面的命令直接创建环境\nconda create --name RAG python=3.10\n\n\n\n原作者的github仓库地址XiaokeAILabs\n可以使用下面的指令直接git到本地\ngit clone https://github.com/li-xiu-qi/XiaokeAILabs.git\n\n\n\n先进入项目中的xiaoke_doc_assist_by_bm25文件夹，然后在该目录下进入cmd\n首先使用下面的指令安装依赖\npip install -r requirements.txt\n安装完成后在当前目录下创建 .env 文件，文件内容可以复制 .env.example 中的\n这里要配置调用模型的API，我之前在硅基流动免费领过额度，所以跟作者一样使用硅基流动的API和密钥\n如果使用硅基流动，直接修改 API_KEY=your_api_key\n\n也可以使用其他平台的API，比如 OpenAI、火山等，要修改 API_KEY 和 BASE_URL\n配置好后还要下载MinerU模型，用于高质量PDF解析\n在当前目录下使用下面指令，如果开了IDE也可以直接运行python文件\npython download_mineru_models.py\n\n\n\n\n在当前目录下使用下面指令运行项目\nstreamlit run main.py\n\n当然，这只是开始，我们仍旧有很多潜在的依赖没有安装，由于不知道安装啥，只能一遍遍运行启动项目的指令，根据报错信息安装，直到最后项目成功启动。\n\n总的来说，缺啥补啥，最后会运行成功的。\n下面是我的辛路历程\n1、缺少magic-pdf\n\n检查后这里需要升级magic-pdf\n使用指令\npip install --upgrade magic-pdf\n\n2、缺少paddle \n安装paddle\npip install paddle\n但是还会报错，缺少paddle的依赖 \n安装依赖\npip install common dual tight data prox\n安装之后发现还是报错\n\n搜索发现paddle太老了，应该升级安装paddlepaddle\n安装指令\npip install --upgrade paddlepaddle\n3、缺少cv2\n\n安装依赖\npip install opencv-python\n\n4、缺少ultralytics\n\n安装依赖\npip install ultralytics\n\n5、缺少doclayout_yolo\n\n安装依赖\npip install doclayout_yolo\n\n6、缺少pycocotools\n\n安装依赖\npip install pycocotools\n\n7、缺少detectron2\n\n安装依赖\n这个依赖的安装可以参考博客Windows11安装detectron2全流程记录帖（含torch安装）\n这个过程中可能会报错，缺少ninja\n使用下面指令安装\npip install ninja\n还会报错要安装Microsoft C++ Build Tools，可能是缺少C++编译器？\n如果有这个报错点击连接，安装就行，在安装的时候一定要勾选C++桌面开的部分\n解决上面两个问题后安装应该不会有问题\n8、缺少timm\n\n安装依赖\npip install timm\n\n9、缺少unimernet\n\n安装依赖\npip install unimernet\n\n10、缺少paddleocr \n安装依赖\npip install paddleocr\n\n11、缺少rapid_table\n\n安装依赖\npip install rapid_table\n12、缺少struct_eqtable\n\n安装依赖\npip install struct_eqtable\n\n13、缺少Stemmer\n\n安装依赖\npip install PyStemmer\n\n\n现在应该能正常运行项目了？\n\n在运行起来之后，我尝试上传文件，还有一个报错安装依赖\n\n安装依赖\npip install rapidocr_onnxruntime\n\n\n现在确实可以运行了"
  },
  {
    "objectID": "content/blogs/entries/基于BM25检索算法构建RAG智能文档问答助手--学习和实践.html#项目效果",
    "href": "content/blogs/entries/基于BM25检索算法构建RAG智能文档问答助手--学习和实践.html#项目效果",
    "title": "基于BM25检索算法构建RAG智能文档问答助手–学习和实践",
    "section": "",
    "text": "在运行完成后，我上传了自己桌面上的一个论文，经过测试可以成功解析，但是不能够检索内容并喂给大模型，还没找到原因。\n之后我用作者提供的测试论文，发现可以成功运行。\n贴一张图："
  },
  {
    "objectID": "content/blogs/entries/基于BM25检索算法构建RAG智能文档问答助手--学习和实践.html#总结",
    "href": "content/blogs/entries/基于BM25检索算法构建RAG智能文档问答助手--学习和实践.html#总结",
    "title": "基于BM25检索算法构建RAG智能文档问答助手–学习和实践",
    "section": "",
    "text": "这是一个非常简单（可能也没那么简单），但是非常有意思的RAG检索系统，但是可以作为一个学习的起点，了解RAG检索的基本流程和原理。\n在实际应用中，RAG检索系统的实现可能会更加复杂，需要考虑更多的因素，比如数据处理、检索索引、生成模型等。\n现在运行项目还会有很多问题，后续我也会发现原因，或许实践构建一个自己的RAG检索系统？"
  },
  {
    "objectID": "content/blogs/entries/开源协议.html",
    "href": "content/blogs/entries/开源协议.html",
    "title": "开源协议",
    "section": "",
    "text": "开源协议是软件开发与分发中的重要组成部分。它们不仅影响软件的使用方式，还影响开发者、用户及整个社区的权利与责任。本文将深入探讨开源协议的定义、类型、重要性及其对软件生态的影响。\n\n\n开源协议是一种法律协议，允许软件的源代码被自由使用、修改和分发。开源协议的核心理念在于促进协作与创新，确保用户和开发者可以自由地利用软件，同时保护原作者的权利。\n\n\n开源软件与自由软件的概念常常被混淆。开源软件强调源代码的可得性，而自由软件则更强调用户的自由。根据自由软件基金会（FSF）的定义，自由软件不仅要允许用户使用软件，还要允许他们修改和分发软件。\n\n\n\n\n开源协议通常分为两大类：宽松型协议和严格型协议。\n\n\n宽松型协议允许用户自由使用、修改和分发软件，同时对后续衍生作品的限制较少。常见的宽松型协议包括：\n\nMIT 许可证：该协议极为简单，允许几乎任何人以任何方式使用、复制、修改和分发软件，只需附上原许可证即可。\nApache 许可证：与MIT许可证类似，Apache许可证允许用户自由使用、修改和分发，但还附加了一些对专利权的保障。\nBSD 许可证：BSD许可证有多个版本，通常允许自由使用和分发，且对源代码的修改并没有严格要求。\n\n\n\n\n严格型协议通常要求任何派生作品都必须遵循相同的协议，保持开源。这类协议包括：\n\nGNU 通用公共许可证（GPL）：GPL是最著名的严格型开源协议之一。它要求任何基于GPL软件的衍生作品也必须以GPL的方式发布，确保用户的自由。\nGNU 较宽松公共许可证（LGPL）：LGPL允许将开源库与闭源软件链接，但任何对库本身的修改仍需以LGPL发布。\nAGPL：与GPL类似，但还要求任何通过网络提供软件的用户也必须开放源代码。\n\n\n\n\n\n\n\n开源协议允许开发者在已有软件的基础上进行修改和扩展。这种开放性促进了技术创新，使得社区成员能够快速迭代和共享最佳实践。\n\n\n\n开放源代码使得任何人都可以检查和审计代码。这种透明性有助于快速发现和修复安全漏洞，增强软件的整体安全性。\n\n\n\n开源协议明确了用户的权利，确保用户能够自由使用、修改和分发软件。这对保护用户的自由和选择权至关重要。\n\n\n\n开源协议吸引了大量开发者和用户参与到软件的开发和维护中。通过社区的合作，软件通常能得到更快的更新和更高的质量。\n\n\n\n\n选择合适的开源协议对于开发者和项目至关重要。以下是选择协议时需要考虑的一些因素：\n\n使用场景：考虑软件的使用场景和目标用户群体，选择适合的协议。\n社区支持：某些协议在特定社区或行业中更受欢迎，选择这样的协议可能更容易获得支持。\n法律风险：了解不同协议在法律上的含义，选择能够保护自己和用户权利的协议。\n兼容性：确保所选协议与项目中使用的其他开源软件的协议兼容，避免法律问题。\n\n\n\n\n\n\nLinux 是一个典型的开源软件项目，采用了 GNU GPL 许可证。这使得任何人都可以使用和修改 Linux 内核，同时要求所有衍生作品也必须以 GPL 发布。Linux 的成功离不开全球开发者社区的贡献，使其成为服务器和嵌入式设备的主流操作系统。\n\n\n\nApache HTTP Server 采用了 Apache 许可证，属于宽松型协议。这使得企业和开发者可以自由使用和修改 Apache，同时也能将其与闭源软件结合使用。Apache 的成功在于其灵活性和广泛的支持，成为了全球使用最广泛的 web 服务器。\n\n\n\n\n随着开源软件的普及，开源协议的未来也在不断演变。以下是一些可能的趋势：\n\n增加透明度：更多的开源项目将会采用透明的审计机制，以增强用户对软件安全性的信任。\n法律合规：随着开源软件使用的增多，法律合规性将变得尤为重要。开发者需要更加重视许可协议的理解与遵循。\n新兴协议：随着技术的发展，新兴的开源协议可能会不断涌现，以适应新的需求和挑战。\n\n\n\n\n开源协议是软件开发的基础，它们不仅定义了软件的使用方式，还塑造了整个技术生态。因此，理解开源协议的作用和选择合适的协议，对于开发者和用户都是至关重要的。随着开源运动的不断发展，开源协议将继续在促进创新、保护用户权利以及推动社区合作中发挥重要作用。希望本文能帮助读者更好地理解开源协议，并在未来的项目中做出明智的选择。"
  },
  {
    "objectID": "content/blogs/entries/开源协议.html#什么是开源协议",
    "href": "content/blogs/entries/开源协议.html#什么是开源协议",
    "title": "开源协议",
    "section": "",
    "text": "开源协议是一种法律协议，允许软件的源代码被自由使用、修改和分发。开源协议的核心理念在于促进协作与创新，确保用户和开发者可以自由地利用软件，同时保护原作者的权利。\n\n\n开源软件与自由软件的概念常常被混淆。开源软件强调源代码的可得性，而自由软件则更强调用户的自由。根据自由软件基金会（FSF）的定义，自由软件不仅要允许用户使用软件，还要允许他们修改和分发软件。"
  },
  {
    "objectID": "content/blogs/entries/开源协议.html#开源协议的类型",
    "href": "content/blogs/entries/开源协议.html#开源协议的类型",
    "title": "开源协议",
    "section": "",
    "text": "开源协议通常分为两大类：宽松型协议和严格型协议。\n\n\n宽松型协议允许用户自由使用、修改和分发软件，同时对后续衍生作品的限制较少。常见的宽松型协议包括：\n\nMIT 许可证：该协议极为简单，允许几乎任何人以任何方式使用、复制、修改和分发软件，只需附上原许可证即可。\nApache 许可证：与MIT许可证类似，Apache许可证允许用户自由使用、修改和分发，但还附加了一些对专利权的保障。\nBSD 许可证：BSD许可证有多个版本，通常允许自由使用和分发，且对源代码的修改并没有严格要求。\n\n\n\n\n严格型协议通常要求任何派生作品都必须遵循相同的协议，保持开源。这类协议包括：\n\nGNU 通用公共许可证（GPL）：GPL是最著名的严格型开源协议之一。它要求任何基于GPL软件的衍生作品也必须以GPL的方式发布，确保用户的自由。\nGNU 较宽松公共许可证（LGPL）：LGPL允许将开源库与闭源软件链接，但任何对库本身的修改仍需以LGPL发布。\nAGPL：与GPL类似，但还要求任何通过网络提供软件的用户也必须开放源代码。"
  },
  {
    "objectID": "content/blogs/entries/开源协议.html#开源协议的重要性",
    "href": "content/blogs/entries/开源协议.html#开源协议的重要性",
    "title": "开源协议",
    "section": "",
    "text": "开源协议允许开发者在已有软件的基础上进行修改和扩展。这种开放性促进了技术创新，使得社区成员能够快速迭代和共享最佳实践。\n\n\n\n开放源代码使得任何人都可以检查和审计代码。这种透明性有助于快速发现和修复安全漏洞，增强软件的整体安全性。\n\n\n\n开源协议明确了用户的权利，确保用户能够自由使用、修改和分发软件。这对保护用户的自由和选择权至关重要。\n\n\n\n开源协议吸引了大量开发者和用户参与到软件的开发和维护中。通过社区的合作，软件通常能得到更快的更新和更高的质量。"
  },
  {
    "objectID": "content/blogs/entries/开源协议.html#开源协议的选择",
    "href": "content/blogs/entries/开源协议.html#开源协议的选择",
    "title": "开源协议",
    "section": "",
    "text": "选择合适的开源协议对于开发者和项目至关重要。以下是选择协议时需要考虑的一些因素：\n\n使用场景：考虑软件的使用场景和目标用户群体，选择适合的协议。\n社区支持：某些协议在特定社区或行业中更受欢迎，选择这样的协议可能更容易获得支持。\n法律风险：了解不同协议在法律上的含义，选择能够保护自己和用户权利的协议。\n兼容性：确保所选协议与项目中使用的其他开源软件的协议兼容，避免法律问题。"
  },
  {
    "objectID": "content/blogs/entries/开源协议.html#开源协议的案例分析",
    "href": "content/blogs/entries/开源协议.html#开源协议的案例分析",
    "title": "开源协议",
    "section": "",
    "text": "Linux 是一个典型的开源软件项目，采用了 GNU GPL 许可证。这使得任何人都可以使用和修改 Linux 内核，同时要求所有衍生作品也必须以 GPL 发布。Linux 的成功离不开全球开发者社区的贡献，使其成为服务器和嵌入式设备的主流操作系统。\n\n\n\nApache HTTP Server 采用了 Apache 许可证，属于宽松型协议。这使得企业和开发者可以自由使用和修改 Apache，同时也能将其与闭源软件结合使用。Apache 的成功在于其灵活性和广泛的支持，成为了全球使用最广泛的 web 服务器。"
  },
  {
    "objectID": "content/blogs/entries/开源协议.html#开源协议的未来",
    "href": "content/blogs/entries/开源协议.html#开源协议的未来",
    "title": "开源协议",
    "section": "",
    "text": "随着开源软件的普及，开源协议的未来也在不断演变。以下是一些可能的趋势：\n\n增加透明度：更多的开源项目将会采用透明的审计机制，以增强用户对软件安全性的信任。\n法律合规：随着开源软件使用的增多，法律合规性将变得尤为重要。开发者需要更加重视许可协议的理解与遵循。\n新兴协议：随着技术的发展，新兴的开源协议可能会不断涌现，以适应新的需求和挑战。"
  },
  {
    "objectID": "content/blogs/entries/开源协议.html#结语",
    "href": "content/blogs/entries/开源协议.html#结语",
    "title": "开源协议",
    "section": "",
    "text": "开源协议是软件开发的基础，它们不仅定义了软件的使用方式，还塑造了整个技术生态。因此，理解开源协议的作用和选择合适的协议，对于开发者和用户都是至关重要的。随着开源运动的不断发展，开源协议将继续在促进创新、保护用户权利以及推动社区合作中发挥重要作用。希望本文能帮助读者更好地理解开源协议，并在未来的项目中做出明智的选择。"
  },
  {
    "objectID": "content/learning-notes/algorithm/entries/滑动窗口与双指针-定长滑动窗口-基础.html",
    "href": "content/learning-notes/algorithm/entries/滑动窗口与双指针-定长滑动窗口-基础.html",
    "title": "leetcode-灵神跟练-滑动窗口与双指针-定长滑动窗口-基础",
    "section": "",
    "text": "定长滑动窗口-基础\n\n1456. 定长子串中元音的最大数目\n\n题面\n给你字符串 s 和整数 k 。 请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。 英文中的 元音字母 为（a, e, i, o, u）。\n示例 1： 输入：s = “abciiidef”, k = 3 输出：3 解释：子字符串 “iii” 包含 3 个元音字母。\n示例 2： 输入：s = “aeiou”, k = 2 输出：2 解释：任意长度为 2 的子字符串都包含 2 个元音字母。\n示例 3： 输入：s = “leetcode”, k = 3 输出：2 解释：“lee”、“eet” 和 “ode” 都包含 2 个元音字母。\n示例 4： 输入：s = “rhythms”, k = 4 输出：0 解释：字符串 s 中不含任何元音字母。\n示例 5： 输入：s = “tryhard”, k = 4 输出：1\n提示： 1 &lt;= s.length &lt;= 10^5 s 由小写英文字母组成 1 &lt;= k &lt;= s.length\n\n\n思路说明\n本题是一个比较简单的滑动窗口，窗口的大小固定不变是K，要做的是判断窗口内元音字母的个数\n首先我们构建一个变量用来统计当前窗口内元音字母的数量，设置为cnt\n窗口只要不断向右滑动的，还需要一个变量存储所有经历过的窗口中元音字母数的最大值，也就是我们最后需要的结果，设置为ans\n然后我们就是对字符串进行遍历\n针对定长滑动窗口的类型，我们可以简单总结一个规律 - 先进行条件判断，修改对应变量值 - 判断窗口是否需要移动，如果移动修改对应值 - 判断窗口是否已经达到了固定长度，如果达到了，进行结果更新\n一个简单的总结，仅供参考\n针对我们现在的题目 - 创建一个变量记录当前窗口内元音字母的个数，设置为cnt - 创建一个变量记录所有经历过的窗口内元音字母数最大值，设置为ans - 然后进行遍历 - 先判断是不是元音字母，如果是窗口内元音字母个数cnt+1 - 然后判断窗口是否需要滑动，如果需要，判断最左边元素是不是元音字母，如果是cnt-1，如果不是，不需要进行更新 - 最后，判断当前窗口长度是不是达到要求，如果是，进行最大值的更新 - 返回最终结果ans\n\n\n题解\npackage main\n\nimport \"fmt\"\n\nfunc judge(ch byte) bool {\n    if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n        return true\n    }\n\n    return false\n}\n\nfunc maxVowels(s string, k int) int {\n    ans := 0\n    cnt := 0\n\n    for i := 0; i &lt; len(s); i++ {\n        if judge(s[i]) {\n            cnt++\n        }\n        if i &gt;= k {\n            if judge(s[i-k]) {\n                cnt -= 1\n            }\n        }\n        if i &gt;= k-1 {\n            ans = max(ans, cnt)\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        s string\n        k int\n    }{\n        {\"abciiidef\", 3},\n        {\"aeiou\", 2},\n        {\"leetcode\", 3},\n        {\"rhythms\", 4},\n        {\"tryhard\", 4},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(maxVowels(testCase.s, testCase.k))\n    }\n}\n\n\n\n\n\n643. 子数组最大平均数 I\n\n题面\n给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。 请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。 任何误差小于 10-5 的答案都将被视为正确答案。\n示例 1：\n输入：nums = [1,12,-5,-6,50,3], k = 4\n输出：12.75\n解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75\n示例 2：\n输入：nums = [5], k = 1\n输出：5.00000\n提示：\nn == nums.length\n1 &lt;= k &lt;= n &lt;= 10^5\n-10^4 &lt;= nums[i] &lt;= 10^4\n\n\n思路说明\n构建长度为k的滑动窗口，设置变量计算窗口内数字的和，当窗口滑动的时候更新变量\n设置变量动态更新最大平均数，注意这个变量初始化的时候设置成 math.MinInt\n\n\n题解\n\n// 643.子数组最大平均数I\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc findMaxAverage(nums []int, k int) float64 {\n    ans, cnt := math.MinInt, 0\n\n    for i, num := range nums {\n        cnt += num\n\n        if i &gt;= k {\n            cnt -= nums[i-k]\n        }\n\n        if i &gt;= k-1 {\n            ans = max(ans, cnt)\n        }\n    }\n\n    return float64(ans) / float64(k)\n}\n\nfunc main() {\n    testCases := []struct {\n        nums []int\n        k    int\n    }{\n        {[]int{1, 12, -5, -6, 50, 3}, 4},\n        {[]int{5}, 1},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(findMaxAverage(testCase.nums, testCase.k))\n    }\n}\n\n\n\n\n1343. 大小为 K 且平均值大于等于阈值的子数组数目\n\n题面\n给你一个整数数组 arr 和两个整数 k 和 threshold 。\n请你返回长度为 k 且平均值大于等于 threshold 的子数组数目。\n示例 1：\n输入：arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4\n输出：3\n解释：子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4，5 和 6 。其他长度为 3 的子数组的平均值都小于 4 （threshold 的值)。\n示例 2：\n输入：arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5\n输出：6\n解释：前 6 个长度为 3 的子数组平均值都大于 5 。注意平均值不是整数。\n提示：\n1 &lt;= arr.length &lt;= 10^5\n1 &lt;= arr[i] &lt;= 10^4\n1 &lt;= k &lt;= arr.length\n0 &lt;= threshold &lt;= 10^4\n\n\n思路说明\n基本思路就是构建大小为k的窗口，计算窗口内元素的和，然后计算平均值是否大于等于某个阈值\n还是按照咱们的步骤来\n\n\n题解\n\n// 1343.大小为K且平均值大于等于阈值的子数组数目\npackage main\n\nimport \"fmt\"\n\nfunc numOfSubarrays(arr []int, k, threshold int) int {\n    ans, cnt := 0, 0\n\n    for i, num := range arr {\n        cnt += num\n        if i &gt;= k {\n            cnt -= arr[i-k]\n        }\n\n        if i &gt;= k-1 && cnt &gt;= k*threshold {\n            ans += 1\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        arr       []int\n        k         int\n        threshold int\n    }{\n        {[]int{2, 2, 2, 2, 5, 5, 5, 8}, 3, 4},\n        {[]int{11, 13, 17, 23, 29, 31, 7, 5, 2, 3}, 3, 5},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(numOfSubarrays(testCase.arr, testCase.k, testCase.threshold))\n    }\n}\n\n\n\n\n\n2090. 半径为 k 的子数组平均值\n\n题面\n给你一个下标从 0 开始的数组 nums ，数组中有 n 个整数，另给你一个整数 k 。\n半径为 k 的子数组平均值 是指：nums 中一个以下标 i 为 中心 且 半径 为 k 的子数组中所有元素的平均值，即下标在 i - k 和 i + k 范围（含 i - k 和 i + k）内所有元素的平均值。如果在下标 i 前或后不足 k 个元素，那么 半径为 k 的子数组平均值 是 -1 。\n构建并返回一个长度为 n 的数组 avgs ，其中 avgs[i] 是以下标 i 为中心的子数组的 半径为 k 的子数组平均值 。\nx 个元素的 平均值 是 x 个元素相加之和除以 x ，此时使用截断式 整数除法 ，即需要去掉结果的小数部分。\n例如，四个元素 2、3、1 和 5 的平均值是 (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75，截断后得到 2 。\n示例 1：\n输入：nums = [7,4,3,9,1,8,5,2,6], k = 3\n输出：[-1,-1,-1,5,4,4,-1,-1,-1]\n解释： - avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。 - 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。 使用截断式 整数除法，avg[3] = 37 / 7 = 5 。 - 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。 - 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。 - avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。\n示例 2：\n输入：nums = [100000], k = 0\n输出：[100000]\n解释： - 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。 avg[0] = 100000 / 1 = 100000 。\n示例 3：\n输入：nums = [8], k = 100000\n输出：[-1]\n解释： - avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。\n提示：\nn == nums.length\n1 &lt;= n &lt;= 10^5\n0 &lt;= nums[i], k &lt;= 10^5\n\n\n思路说明\n本题提出了一个概念，半径为k的字数组\n这个时候滑动窗口的实际大小是k * 2 + 1\n之后能作为圆心的点才能够有平均值，其他的都是-1\n所以，先设置答案存储的数组 ans 然后将全部的值初始化为-1\n之后还是按照我们之前总结的思路来\n\n\n题解\n// 2090.半径为k的子数组平均值\npackage main\n\nimport \"fmt\"\n\nfunc getAverages(nums []int, k int) []int {\n    ans := make([]int, len(nums))\n\n    for i := range ans {\n        ans[i] = -1\n    }\n\n    cnt := 0\n\n    for i, num := range nums {\n        cnt += num\n\n        if i &gt;= 2*k {\n            ans[i-k] = cnt / (k*2 + 1)\n            cnt -= nums[i-2*k]\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        nums []int\n        k    int\n    }{\n        {[]int{7, 4, 3, 9, 1, 8, 5, 2, 6}, 3},\n        {[]int{100000}, 0},\n        {[]int{8}, 100000},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(getAverages(testCase.nums, testCase.k))\n    }\n}\n\n\n\n\n\n2379. 得到 K 个黑块的最少涂色次数\n\n题面\n给你一个长度为 n 下标从 0 开始的字符串 blocks ，blocks[i] 要么是 ‘W’ 要么是 ‘B’ ，表示第 i 块的颜色。字符 ‘W’ 和 ‘B’ 分别表示白色和黑色。\n给你一个整数 k ，表示想要 连续 黑色块的数目。\n每一次操作中，你可以选择一个白色块将它 涂成 黑色块。\n请你返回至少出现 一次 连续 k 个黑色块的 最少 操作次数。\n示例 1：\n输入：blocks = “WBBWWBBWBW”, k = 7\n输出：3\n解释： 一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色。\n得到 blocks = “BBBBBBBWBW” 。\n可以证明无法用少于 3 次操作得到 7 个连续的黑块。\n所以我们返回 3 。\n示例 2：\n输入：blocks = “WBWBBBW”, k = 2\n输出：0\n解释：\n不需要任何操作，因为已经有 2 个连续的黑块。\n所以我们返回 0 。\n提示：\nn == blocks.length\n1 &lt;= n &lt;= 100\nblocks[i] 要么是 ‘W’ ，要么是 ‘B’ 。\n1 &lt;= k &lt;= n\n\n\n思路说明\n我们需要的是K个连续的黑色块，也就是把大小为k的窗口中的白色块全部涂黑\n我们要到这个最小的涂色数，也是黑色块最多，白色块最少\n我们找到黑色块最多的然后用k减去这个数量即可\n\n\n题解\n// 2379.得到K个黑块的最少涂色次数\npackage main\n\nimport \"fmt\"\n\nfunc minimumRecolors(blocks string, k int) int {\n    ans, cnt := 0, 0\n\n    for i, block := range blocks {\n        if block == 'B' {\n            cnt += 1\n        }\n\n        if i &gt;= k {\n            if blocks[i-k] == 'B' {\n                cnt -= 1\n            }\n        }\n\n        if i &gt;= k-1 {\n            ans = max(ans, cnt)\n        }\n    }\n\n    return k - ans\n}\n\nfunc main() {\n    testCases := []struct {\n        blocks string\n        k      int\n    }{\n        {\"WBBWWBBWBW\", 7},\n        {\"WBWBBBW\", 2},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(minimumRecolors(testCase.blocks, testCase.k))\n    }\n}\n\n\n\n\n\n2841. 几乎唯一子数组的最大和\n\n题面\n给你一个整数数组 nums 和两个正整数 m 和 k 。\n请你返回 nums 中长度为 k 的 几乎唯一 子数组的 最大和 ，如果不存在几乎唯一子数组，请你返回 0 。\n如果 nums 的一个子数组有至少 m 个互不相同的元素，我们称它是 几乎唯一 子数组。\n子数组指的是一个数组中一段连续 非空 的元素序列。\n示例 1：\n输入：nums = [2,6,7,3,1,7], m = 3, k = 4\n输出：18\n解释：总共有 3 个长度为 k = 4 的几乎唯一子数组。分别为 [2, 6, 7, 3] ，[6, 7, 3, 1] 和 [7, 3, 1, 7] 。这些子数组中，和最大的是 [2, 6, 7, 3] ，和为 18 。\n示例 2：\n输入：nums = [5,9,9,2,4,5,4], m = 1, k = 3\n输出：23\n解释：总共有 5 个长度为 k = 3 的几乎唯一子数组。分别为 [5, 9, 9] ，[9, 9, 2] ，[9, 2, 4] ，[2, 4, 5] 和 [4, 5, 4] 。这些子数组中，和最大的是 [5, 9, 9] ，和为 23 。\n示例 3：\n输入：nums = [1,2,1,2,1,2,1], m = 3, k = 3\n输出：0\n解释：输入数组中不存在长度为 k = 3 的子数组含有至少 m = 3 个互不相同元素的子数组。所以不存在几乎唯一子数组，最大和为 0 。\n提示：\n1 &lt;= nums.length &lt;= 2 * 10^4\n1 &lt;= m &lt;= k &lt;= nums.length\n1 &lt;= nums[i] &lt;= 10^9\n\n\n思路说明\n从这道题开始引入一个变量，开始对窗口中元素的数量进行控制\n对数量的统计和控制可以通过引入哈希表实现，在golang中，我们可以使用map[type]type 来表示哈希表\n通过map[num]可以统计num的数量，通过len(map)可以控制元素的种类，这也是最常用的两种方式\n在本题中，我们要把len(map)控制在m以内\n然后其他的逻辑都是固定的\n\n\n题解\n\n// 2841.几乎唯一子数组的最大和\npackage main\n\nimport \"fmt\"\n\nfunc maxSum(nums []int, m, k int) int64 {\n    mp := make(map[int]int)\n    var ans, cnt int64\n    for i, num := range nums {\n        cnt += int64(num)\n        mp[num] += 1\n\n        if i &gt;= k {\n            cnt -= int64(nums[i-k])\n            mp[nums[i-k]] -= 1\n            if mp[nums[i-k]] == 0 {\n                delete(mp, nums[i-k])\n            }\n        }\n\n        if i &gt;= k-1 && len(mp) &gt;= m {\n            ans = max(ans, cnt)\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        nums []int\n        m    int\n        k    int\n    }{\n        {[]int{2, 6, 7, 3, 1, 7}, 3, 4},\n        {[]int{5, 9, 9, 2, 4, 5, 4}, 1, 3},\n        {[]int{1, 2, 1, 2, 1, 2, 1}, 3, 3},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(maxSum(testCase.nums, testCase.m, testCase.k))\n    }\n}\n\n\n\n\n\n2461. 长度为 K 子数组中的最大和\n\n题面\n给你一个整数数组 nums 和一个整数 k 。请你从 nums 中满足下述条件的全部子数组中找出最大子数组和：\n子数组的长度是 k，且\n子数组中的所有元素 各不相同 。\n返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 0 。\n子数组 是数组中一段连续非空的元素序列。\n示例 1：\n输入：nums = [1,5,4,2,9,9,9], k = 3\n输出：15\n解释：nums 中长度为 3 的子数组是： - [1,5,4] 满足全部条件，和为 10 。 - [5,4,2] 满足全部条件，和为 11 。 - [4,2,9] 满足全部条件，和为 15 。 - [2,9,9] 不满足全部条件，因为元素 9 出现重复。 - [9,9,9] 不满足全部条件，因为元素 9 出现重复。\n因为 15 是满足全部条件的所有子数组中的最大子数组和，所以返回 15 。\n示例 2：\n输入：nums = [4,4,4], k = 3\n输出：0\n解释：nums 中长度为 3 的子数组是： - [4,4,4] 不满足全部条件，因为元素 4 出现重复。\n因为不存在满足全部条件的子数组，所以返回 0 。\n提示：\n1 &lt;= k &lt;= nums.length &lt;= 10^5\n1 &lt;= nums[i] &lt;= 10^5\n\n\n思路说明\n通过哈希表大小控制所有元素各不相同的要求，通过滑动窗口控制字数组的长度k\n\n\n题解\n\n// 2461.长度为K子数组中的最大和\npackage main\n\nimport \"fmt\"\n\nfunc maximumSubarraySum(nums []int, k int) int64 {\n    mp := make(map[int]int)\n    var ans, cnt int64\n\n    for i, num := range nums {\n        cnt += int64(num)\n        mp[num] += 1\n\n        if i &gt;= k {\n            cnt -= int64(nums[i-k])\n            mp[nums[i-k]] -= 1\n            if mp[nums[i-k]] == 0 {\n                delete(mp, nums[i-k])\n            }\n\n        }\n\n        if i &gt;= k-1 && len(mp) == k {\n            ans = max(ans, cnt)\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        nums []int\n        k    int\n    }{\n        {[]int{1, 5, 4, 2, 9, 9, 9}, 3},\n        {[]int{4, 4, 4}, 3},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(maximumSubarraySum(testCase.nums, testCase.k))\n    }\n}\n\n\n\n\n1423. 可获得的最大点数\n\n题面\n几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。\n每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。\n你的点数就是你拿到手中的所有卡牌的点数之和。\n给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。\n示例 1：\n输入：cardPoints = [1,2,3,4,5,6,1], k = 3\n输出：12\n解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。\n示例 2：\n输入：cardPoints = [2,2,2], k = 2\n输出：4\n解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。\n示例 3：\n输入：cardPoints = [9,7,7,9,7,7,9], k = 7\n输出：55\n解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。\n示例 4：\n输入：cardPoints = [1,1000,1], k = 1\n输出：1\n解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。\n示例 5：\n输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3\n输出：202\n提示：\n1 &lt;= cardPoints.length &lt;= 10^5\n1 &lt;= cardPoints[i] &lt;= 10^4\n1 &lt;= k &lt;= cardPoints.length\n\n\n思路说明\n这道题同样归类于滑动窗口，它是首尾构成一个滑动窗口\n我的做法现在数组首部构建一个长度为k的滑动窗口\n然后移动窗口开始尾部移动，直到尾部移动k\n\n\n题解\n\n// 1423.可获得的最大点数\npackage main\n\nimport \"fmt\"\n\nfunc maxScore(cardPoints []int, k int) int {\n    left := k - 1\n    ans, cnt := 0, 0\n\n    for i := 0; i &lt; k; i++ {\n        cnt += cardPoints[i]\n    }\n\n    ans = cnt\n\n    for i := len(cardPoints) - 1; i &gt;= len(cardPoints)-k; i-- {\n        cnt -= cardPoints[left]\n        left -= 1\n        cnt += cardPoints[i]\n\n        ans = max(ans, cnt)\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        nums []int\n        k    int\n    }{\n        {[]int{1, 2, 3, 4, 5, 6, 1}, 3},\n        {[]int{2, 2, 2}, 2},\n        {[]int{9, 7, 7, 9, 7, 7, 9}, 7},\n        {[]int{1, 1000, 1}, 1},\n        {[]int{1, 79, 80, 1, 1, 1, 200, 1}, 3},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(maxSore(testCase.nums, testCase.k))\n    }\n}\n\n\n\n\n\n1176. 健身计划评估\n\n题面\n你的好友是一位健身爱好者。前段日子，他给自己制定了一份健身计划。现在想请你帮他评估一下这份计划是否合理。\n他会有一份计划消耗的卡路里表，其中 calories[i] 给出了你的这位好友在第 i 天需要消耗的卡路里总量。\n为了更好地评估这份计划，对于卡路里表中的每一天，你都需要计算他 「这一天以及之后的连续几天」 （共 k 天）内消耗的总卡路里 T：\n如果 T &lt; lower，那么这份计划相对糟糕，并失去 1 分；\n如果 T &gt; upper，那么这份计划相对优秀，并获得 1 分；\n否则，这份计划普普通通，分值不做变动。\n请返回统计完所有 calories.length 天后得到的总分作为评估结果。\n注意：总分可能是负数。\n示例 1：\n输入：calories = [1,2,3,4,5], k = 1, lower = 3, upper = 3\n输出：0\n解释：calories[0], calories[1] &lt; lower 而 calories[3], calories[4] &gt; upper, 总分 = 0.\n示例 2：\n输入：calories = [3,2], k = 2, lower = 0, upper = 1\n输出：1\n解释：calories[0] + calories[1] &gt; upper, 总分 = 1.\n示例 3：\n输入：calories = [6,5,0,0], k = 2, lower = 1, upper = 5\n输出：0\n解释：calories[0] + calories[1] &gt; upper, calories[2] + calories[3] &lt; lower, 总分 = 0.\n提示：\n1 &lt;= k &lt;= calories.length &lt;= 10^5\n0 &lt;= calories[i] &lt;= 20000\n0 &lt;= lower &lt;= upper\n\n\n思路说明\n构建滑动窗口，统计窗口中消耗的卡路里，然后判断\n基本思路还是按照之前的步骤\n\n\n题解\n\n// 1176.健身计划评估\npackage main\n\nimport \"fmt\"\n\nfunc dietPlanPerformance(calories []int, k, lower, upper int) int {\n    ans, cnt := 0, 0\n\n    for i, calorie := range calories {\n        cnt += calorie\n\n        if i &gt;= k {\n            cnt -= calories[i-k]\n        }\n\n        if i &gt;= k-1 {\n            if cnt &gt; upper {\n                ans += 1\n            }\n\n            if cnt &lt; lower {\n                ans -= 1\n            }\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        calories []int\n        k        int\n        lower    int\n        upper    int\n    }{\n        {[]int{1, 2, 3, 4, 5}, 1, 3, 3},\n        {[]int{3, 2}, 2, 0, 1},\n        {[]int{6, 5, 0, 0}, 2, 1, 5},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(dietPlanPerformance(testCase.calories, testCase.k, testCase.lower, testCase.upper))\n    }\n}\n\n\n\n\n1100. 长度为 K 的无重复字符子串\n\n题面\n给你一个字符串 S，找出所有长度为 K 且不含重复字符的子串，请你返回全部满足要求的子串的 数目。\n示例 1：\n输入：S = “havefunonleetcode”, K = 5\n输出：6\n解释： 这里有 6 个满足题意的子串，分别是：‘havef’,‘avefu’,‘vefun’,‘efuno’,‘etcod’,‘tcode’。\n示例 2：\n输入：S = “home”, K = 5\n输出：0\n解释： 注意：K 可能会大于 S 的长度。在这种情况下，就无法找到任何长度为 K 的子串。\n提示：\n1 &lt;= S.length &lt;= 10^4\nS 中的所有字符均为小写英文字母\n1 &lt;= K &lt;= 10^4\n\n\n思路说明\n使用哈希表控制字符串是否重复\n使用滑动窗口构建长度为k的子串\n\n\n题解\n\n// 1100.长度为K的无重复字符子串\npackage main\n\nimport \"fmt\"\n\nfunc numKLenSubstrNoRepeats(s string, k int) int {\n    mp := make(map[byte]int)\n    ans := 0\n\n    for i := 0; i &lt; len(s); i++ {\n        mp[s[i]] += 1\n\n        if i &gt;= k {\n            mp[s[i-k]] -= 1\n            if mp[s[i-k]] == 0 {\n                delete(mp, s[i-k])\n            }\n        }\n\n        if i &gt;= k-1 && len(mp) == k {\n            ans += 1\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        s string\n        k int\n    }{\n        {\"havefunonleetcode\", 5},\n        {\"home\", 5},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(numKLenSubstrNoRepeats(testCase.s, testCase.k))\n    }\n}\n\n\n\n\n1852. 每个子数组的数字种类数\n\n题面\n给你一个长度为 n 的整数数组 nums 与一个整数 k。你的任务是找到 nums 所有 长度为 k 的子数组中 不同 元素的数量。\n返回一个数组 ans，其中 ans[i] 是对于每个索引 0 &lt;= i &lt; n - k，nums[i..(i + k - 1)] 中不同元素的数量。\n示例 1:\n输入: nums = [1,2,3,2,2,1,3], k = 3\n输出: [3,2,2,2,3]\n解释：每个子数组的数字种类计算方法如下： - nums[0..2] = [1,2,3] 所以 ans[0] = 3 - nums[1..3] = [2,3,2] 所以 ans[1] = 2 - nums[2..4] = [3,2,2] 所以 ans[2] = 2 - nums[3..5] = [2,2,1] 所以 ans[3] = 2 - nums[4..6] = [2,1,3] 所以 ans[4] = 3\n示例 2:\n输入: nums = [1,1,1,1,2,3,4], k = 4\n输出: [1,2,3,4]\n解释: 每个子数组的数字种类计算方法如下： - nums[0..3] = [1,1,1,1] 所以 ans[0] = 1 - nums[1..4] = [1,1,1,2] 所以 ans[1] = 2 - nums[2..5] = [1,1,2,3] 所以 ans[2] = 3 - nums[3..6] = [1,2,3,4] 所以 ans[3] = 4\n提示:\n1 &lt;= k &lt;= nums.length &lt;= 10^5\n1 &lt;= nums[i] &lt;= 10^5\n\n\n思路说明\n构建滑动窗口，长度固定为k\n使用哈希表记录一下窗口内数字的种类，并实时更新\n\n\n题解\n\n// 1852.每个子数组的数字种类数\npackage main\n\nimport \"fmt\"\n\nfunc distinctNumbers(nums []int, k int) []int {\n    mp := make(map[int]int)\n    ans := make([]int, len(nums)-k+1)\n\n    for i, num := range nums {\n        mp[num] += 1\n\n        if i &gt;= k {\n            mp[nums[i-k]] -= 1\n            if mp[nums[i-k]] == 0 {\n                delete(mp, nums[i-k])\n            }\n        }\n\n        if i &gt;= k-1 {\n            ans[i-k+1] = len(mp)\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        nums []int\n        k    int\n    }{\n        {[]int{1, 2, 3, 2, 2, 1, 3}, 3},\n        {[]int{1, 1, 1, 1, 2, 3, 4}, 4},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(distinctNumbers(testCase.nums, testCase.k))\n    }\n}\n\n\n\n\n1151. 最少交换次数来组合所有的 1\n\n题面\n给出一个二进制数组 data，你需要通过交换位置，将数组中 任何位置 上的 1 组合到一起，并返回所有可能中所需 最少的交换次数。\n示例 1:\n输入: data = [1,0,1,0,1]\n输出: 1\n解释:\n有三种可能的方法可以把所有的 1 组合在一起：\n[1,1,1,0,0]，交换 1 次；\n[0,1,1,1,0]，交换 2 次；\n[0,0,1,1,1]，交换 1 次。\n所以最少的交换次数为 1。\n示例 2:\n输入：data = [0,0,0,1,0]\n输出：0\n解释：\n由于数组中只有一个 1，所以不需要交换。\n示例 3:\n输入：data = [1,0,1,0,1,0,0,1,1,0,1]\n输出：3\n解释：\n交换 3 次，一种可行的只用 3 次交换的解决方案是 [0,0,0,0,0,1,1,1,1,1,1]。\n示例 4:\n输入: data = [1,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,0,0,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,0,1]\n输出: 8\n提示:\n1 &lt;= data.length &lt;= 10^5\ndata[i] == 0 or 1.\n\n\n思路说明\n题目的要求是把所有的1都组合在一起，并返回所需要的最少交换次数\n我们首先需要知道数组中1的个数，将这个数量作为滑动窗口的大小\n我们已经得到滑动窗口的大小，然后统计窗口中最大的1的数量，用窗口大小减去这个最大值，就是我们需要的最少交换次数\n\n\n题解\n\n// 1151.最少交换次数来组合所有的1\npackage main\n\nimport \"fmt\"\n\nfunc minSwaps(data []int) int {\n    k := 0 // 滑动窗口的大小\n    for _, val := range data {\n        k += val\n    }\n\n    ans, cnt := 0, 0\n\n    for i, val := range data {\n        cnt += val\n\n        if i &gt;= k {\n            cnt -= data[i-k]\n        }\n\n        if i &gt;= k-1 {\n            ans = max(ans, cnt)\n        }\n    }\n\n    return k - ans\n}\n\nfunc main() {\n    testCases := [][]int{\n        []int{1, 0, 1, 0, 1},\n        []int{0, 0, 0, 1, 0},\n        []int{1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1},\n        []int{1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(minSwaps(testCase))\n    }\n}\n\n\n\n\n2107. 分享 K 个糖果后独特口味的数量\n\n题面\n您将获得一个 从0开始的 整数数组 candies ，其中 candies[i] 表示第 i 个糖果的味道。你妈妈想让你和你妹妹分享这些糖果，给她 k 个 连续 的糖果，但你想保留尽可能多的糖果口味。\n在与妹妹分享后，返回 最多 可保留的 独特 口味的糖果。\n示例 1：\n输入: candies = [1,2,2,3,4,3], k = 3\n输出: 3\n解释: 将[1,3]（含[2,2,3]）范围内的糖果加入[2,2,3]口味。 你可以吃各种口味的糖果[1,4,3]。 有3种独特的口味，所以返回3。\n示例 2:\n输入: candies = [2,2,2,2,3,3], k = 2\n输出: 2\n解释: 在[3,4]范围内（含[2,3]）的糖果中加入[2,3]口味。 你可以吃各种口味的糖果[2,2,2,3]。 有两种独特的口味，所以返回2。 请注意，你也可以分享口味为[2,2]的糖果，吃口味为[2,2,3,3]的糖果。\n示例 3:\n输入: candies = [2,4,5], k = 0\n输出: 3\n解释: 你不必给任何糖果。 你可以吃各种口味的糖果[2,4,5]。 有3种独特的口味，所以返回3。\n提示:\n0 &lt;= candies.length &lt;= 10^5\n1 &lt;= candies[i] &lt;= 10^5\n0 &lt;= k &lt;= candies.length\n\n\n思路说明\n这个题目比较特殊，是要构建一个连续数组，数组长度为k，删除这个数组后剩余的数字种类尽量多\n这样就使用哈希表存储剩余种类和对应数量即可\n还是按照三步进行即可\n\n\n题解\n\n// 2107.分享K个糖果后独特口味的数量\npackage main\n\nimport \"fmt\"\n\nfunc shareCandies(candies []int, k int) int {\n    mp := make(map[int]int)\n    ans := 0\n\n    for _, candie := range candies {\n        mp[candie] += 1\n    }\n\n    for i, candie := range candies {\n        mp[candie] -= 1\n\n        if mp[candie] == 0 {\n            delete(mp, candie)\n        }\n\n        if i &gt;= k {\n            mp[candies[i-k]] += 1\n        }\n\n        if i &gt;= k-1 {\n            ans = max(ans, len(mp))\n        }\n    }\n\n    return ans\n}\n\nfunc main() {\n    testCases := []struct {\n        candies []int\n        k       int\n    }{\n        {[]int{1, 2, 2, 3, 4, 3}, 3},\n        {[]int{2, 2, 2, 2, 3, 3}, 2},\n        {[]int{2, 4, 5}, 0},\n    }\n\n    for _, testCase := range testCases {\n        fmt.Println(shareCandies(testCase.candies, testCase.k))\n    }\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（10）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（10）.html",
    "title": "golang学习记录（10）",
    "section": "",
    "text": "指针是一个变量，其值为另一个变量的地址，即，内存地址。\n指针类型的数据大小为固定值，32位系统为4字节，64位系统为8字节。\n\n\n\n\n取址符号：&\n指针：*\n传过去一个地址，通过指针进行接收\n\n定义一个指针：\nvar a int = 10\nvar p *int = &a\n// 定义了一个指针，p的类型为*int，p指向a的地址\n\n//通过指针修改值\n*p = 20\nfmt.Println(a) //20\n\n不同于C/C++语言中的指针，go语言中的指针限制了指针的运算，不能通过修改指针运算的方式访问其他内存的值\n但是go语言在unsafe包中提供了一些方法，可以通过指针运算的方式访问其他内存的值，但是这种方式是不安全的，不建议使用。\n\n\n\n\n\n指针未初始化时，默认值为nil\n在定义指针时需要进行初始化\n\n指针初始化方式：\nvar a int = 10\n\nvar p *int = &a\n\nvar p2 = new(int) //new函数返回一个指针，指向一个新的int类型的值，值为0\n\n// 如果是结构体还能用下面的方式\np := &Person{}\n\n指针的初始化最好使用new的方式\nmap、slice、channel的初始化最好使用make方式\n指针必须要初始化\nmap必须初始化\n\n\n\n\nfunc swap(a, b *int) {\n    t := *a\n    *a = *b\n    *b = t\n}\n\nfunc main() {\n    var a int = 10\n    var b int = 20\n    swap(&a, &b)\n    fmt.Println(a, b) //20 10\n}\n\n\n\n\n在go中nil代表某一些数据类型中的零值，不同类型数据中的零值是不一样的\n在结构体中nil代表结构体的零值，即所有字段都为零值，他是一个集合体，同时结构体可以通过 == 进行比较，比较的是结构体中的所有字段是否相等。\nnil的slice本质上还是一个结构体，他是slice类型的零值，各个字段都是自己的零值。在make之后地址不是空值，而是指向一个地址（很重要）\nnil的slice不能通过append进行添加元素，否则会报错，因为其地址元素为空。empty的slice可以通过append进行添加元素。（很重要）"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（10）.html#指针的定义和使用",
    "href": "content/learning-notes/golang/entries/golang学习记录（10）.html#指针的定义和使用",
    "title": "golang学习记录（10）",
    "section": "",
    "text": "取址符号：&\n指针：*\n传过去一个地址，通过指针进行接收\n\n定义一个指针：\nvar a int = 10\nvar p *int = &a\n// 定义了一个指针，p的类型为*int，p指向a的地址\n\n//通过指针修改值\n*p = 20\nfmt.Println(a) //20\n\n不同于C/C++语言中的指针，go语言中的指针限制了指针的运算，不能通过修改指针运算的方式访问其他内存的值\n但是go语言在unsafe包中提供了一些方法，可以通过指针运算的方式访问其他内存的值，但是这种方式是不安全的，不建议使用。"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（10）.html#指针的初始化",
    "href": "content/learning-notes/golang/entries/golang学习记录（10）.html#指针的初始化",
    "title": "golang学习记录（10）",
    "section": "",
    "text": "指针未初始化时，默认值为nil\n在定义指针时需要进行初始化\n\n指针初始化方式：\nvar a int = 10\n\nvar p *int = &a\n\nvar p2 = new(int) //new函数返回一个指针，指向一个新的int类型的值，值为0\n\n// 如果是结构体还能用下面的方式\np := &Person{}\n\n指针的初始化最好使用new的方式\nmap、slice、channel的初始化最好使用make方式\n指针必须要初始化\nmap必须初始化"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（10）.html#swap与指针",
    "href": "content/learning-notes/golang/entries/golang学习记录（10）.html#swap与指针",
    "title": "golang学习记录（10）",
    "section": "",
    "text": "func swap(a, b *int) {\n    t := *a\n    *a = *b\n    *b = t\n}\n\nfunc main() {\n    var a int = 10\n    var b int = 20\n    swap(&a, &b)\n    fmt.Println(a, b) //20 10\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（10）.html#go中的nil",
    "href": "content/learning-notes/golang/entries/golang学习记录（10）.html#go中的nil",
    "title": "golang学习记录（10）",
    "section": "",
    "text": "在go中nil代表某一些数据类型中的零值，不同类型数据中的零值是不一样的\n在结构体中nil代表结构体的零值，即所有字段都为零值，他是一个集合体，同时结构体可以通过 == 进行比较，比较的是结构体中的所有字段是否相等。\nnil的slice本质上还是一个结构体，他是slice类型的零值，各个字段都是自己的零值。在make之后地址不是空值，而是指向一个地址（很重要）\nnil的slice不能通过append进行添加元素，否则会报错，因为其地址元素为空。empty的slice可以通过append进行添加元素。（很重要）"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（12）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（12）.html",
    "title": "golang学习记录（12）",
    "section": "",
    "text": "在go中，package是一个非常重要的概念，它是go语言中的一个基本单位，它可以包含多个.go文件，每个.go文件都必须属于一个package，这也是代码复用的基础，其中fmt、os、io等都是一个包\n每个源码文件的第一行都是package xxx，xxx就是这个文件所属的包名\n同一目录之下的源码可以直接使用，不需要import\n\n\n\n\n\n1、import “路径名称”\n2、import 别名 “路径名称”\n3、import .”路径名称”\n\n注意包名称不能重复\n\n\n\n\n1、go.mod是go语言中的一个文件，它是go语言的一个依赖管理文件，它的作用是管理go语言的依赖关系\n2、这个文件的内容是自动维护的\n3、go.mod维护内容下载到一个固定位置中\n\n\n\n\n\n在命令行中设置成国内镜像即可\n\n\n\n\n\n\ngo get 指令用于下载包，它会自动下载包的依赖包\ngo get 依赖地址\ngo get - u 指令用于更新包，它会自动更新包的依赖包\ngo get -u=patch 指令用于更新包到修订版本\n\n\ngo mod help查看能使用的指令，如下：\n\n\n\ngo mod tidy\n\n\n\n\n\ngo mod replace 指令用于替换包，它会自动替换包的依赖包"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（12）.html#package的定义和导入",
    "href": "content/learning-notes/golang/entries/golang学习记录（12）.html#package的定义和导入",
    "title": "golang学习记录（12）",
    "section": "",
    "text": "在go中，package是一个非常重要的概念，它是go语言中的一个基本单位，它可以包含多个.go文件，每个.go文件都必须属于一个package，这也是代码复用的基础，其中fmt、os、io等都是一个包\n每个源码文件的第一行都是package xxx，xxx就是这个文件所属的包名\n同一目录之下的源码可以直接使用，不需要import"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（12）.html#import的方式",
    "href": "content/learning-notes/golang/entries/golang学习记录（12）.html#import的方式",
    "title": "golang学习记录（12）",
    "section": "",
    "text": "1、import “路径名称”\n2、import 别名 “路径名称”\n3、import .”路径名称”\n\n注意包名称不能重复"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（12）.html#go.mod",
    "href": "content/learning-notes/golang/entries/golang学习记录（12）.html#go.mod",
    "title": "golang学习记录（12）",
    "section": "",
    "text": "1、go.mod是go语言中的一个文件，它是go语言的一个依赖管理文件，它的作用是管理go语言的依赖关系\n2、这个文件的内容是自动维护的\n3、go.mod维护内容下载到一个固定位置中"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（12）.html#设置goproxy的国内镜像",
    "href": "content/learning-notes/golang/entries/golang学习记录（12）.html#设置goproxy的国内镜像",
    "title": "golang学习记录（12）",
    "section": "",
    "text": "在命令行中设置成国内镜像即可"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（12）.html#goget与gomod相关指令",
    "href": "content/learning-notes/golang/entries/golang学习记录（12）.html#goget与gomod相关指令",
    "title": "golang学习记录（12）",
    "section": "",
    "text": "go get 指令用于下载包，它会自动下载包的依赖包\ngo get 依赖地址\ngo get - u 指令用于更新包，它会自动更新包的依赖包\ngo get -u=patch 指令用于更新包到修订版本\n\n\ngo mod help查看能使用的指令，如下：\n\n\n\ngo mod tidy"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（12）.html#gomodreplace",
    "href": "content/learning-notes/golang/entries/golang学习记录（12）.html#gomodreplace",
    "title": "golang学习记录（12）",
    "section": "",
    "text": "go mod replace 指令用于替换包，它会自动替换包的依赖包"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（1）-在win搭建go环境.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（1）-在win搭建go环境.html",
    "title": "golang学习记录（1）-在win搭建go环境",
    "section": "",
    "text": "SDK（Soft Development Kit, 软件开发工具包）：是一套工具得集合，方便开发者在特定的编程语言环境下进行开发\n工具通常包含库、框架、文档和使用指导……\n\n\n\n工具包下载网址\n根据自己的需要可以选择不同的工具包，我的是Windows10 64位，选择下载“go1.17.3.windows-arm64.zip” \n下载完成后，在电脑中选择一个地方解压文件即可，尽量解压在D盘中，解压后安装包删除即可，节省空间。\n解压后的目录是下面这样，其中最重要的是bin目录下的“go.exe”，在我们的程序写完之后，需要通过它来编译运行. \n进入到bin目录下，在上方输入cmd，回车进入命令行模式，输入指令,查看go的版本\ngo version\n如果能够正常显示版本号，就表示安装成功 \n\n\n\n\n在安装成功后还需要进行环境变量的配置\n在我的电脑，右击选择属性，之后点击右侧的高级系统设置，点击下方的环境变量，进入环境变量配置\n\ngo需要进行三个环境变量的配置，如下表\n\n\n\n环境变量名称\n作用\n\n\n\n\nGOROOT\n表明go安装的位置\n\n\nPath\n表明go.exe的位置\n\n\nGOPATH\n表明go项目的位置\n\n\n\n配置示例如下：\nGOROOT \nPath \nGOPATH \n测试环境变量是否配置成功： win+R 输入cmd，打开命令行，输入命令查看\ngo version\n 如果能够正常显示版本号，就表示环境变量配置成功。\n\n\n这是我们使用的是“宇宙最强IDE”–VsCode 直接在插件市场选择插件就行，这里我们安装了下面几个： \n在这了我们使用ctrl+shift+p，输入Go: install/update tools后回车即可自动安装。"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（1）-在win搭建go环境.html#golong环境搭建",
    "href": "content/learning-notes/golang/entries/golang学习记录（1）-在win搭建go环境.html#golong环境搭建",
    "title": "golang学习记录（1）-在win搭建go环境",
    "section": "",
    "text": "SDK（Soft Development Kit, 软件开发工具包）：是一套工具得集合，方便开发者在特定的编程语言环境下进行开发\n工具通常包含库、框架、文档和使用指导……\n\n\n\n工具包下载网址\n根据自己的需要可以选择不同的工具包，我的是Windows10 64位，选择下载“go1.17.3.windows-arm64.zip” \n下载完成后，在电脑中选择一个地方解压文件即可，尽量解压在D盘中，解压后安装包删除即可，节省空间。\n解压后的目录是下面这样，其中最重要的是bin目录下的“go.exe”，在我们的程序写完之后，需要通过它来编译运行. \n进入到bin目录下，在上方输入cmd，回车进入命令行模式，输入指令,查看go的版本\ngo version\n如果能够正常显示版本号，就表示安装成功 \n\n\n\n\n在安装成功后还需要进行环境变量的配置\n在我的电脑，右击选择属性，之后点击右侧的高级系统设置，点击下方的环境变量，进入环境变量配置\n\ngo需要进行三个环境变量的配置，如下表\n\n\n\n环境变量名称\n作用\n\n\n\n\nGOROOT\n表明go安装的位置\n\n\nPath\n表明go.exe的位置\n\n\nGOPATH\n表明go项目的位置\n\n\n\n配置示例如下：\nGOROOT \nPath \nGOPATH \n测试环境变量是否配置成功： win+R 输入cmd，打开命令行，输入命令查看\ngo version\n 如果能够正常显示版本号，就表示环境变量配置成功。\n\n\n这是我们使用的是“宇宙最强IDE”–VsCode 直接在插件市场选择插件就行，这里我们安装了下面几个： \n在这了我们使用ctrl+shift+p，输入Go: install/update tools后回车即可自动安装。"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（3）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（3）.html",
    "title": "golang学习记录（3）",
    "section": "",
    "text": "go是一种静态语言，变量的类型是在编译阶段确定的。 &gt; 变量必须先定义后使用 &gt; &gt; 变量必须要有类型 &gt; &gt; 变量类型定下来后不能改变\n\n\n\n\n// 第一种\nvar age int (string bool 等)\nage = 10\n// 第二种\nvar age = 10\n// 第三种\nage := 10\n\n\n\n\n全局变量：在函数外部定义的变量，作用域为整个包\n局部变量：在函数内部定义的变量，作用域为函数内部\n\n注：全局变量定义之后可以不使用，但是局部变量定义之后必须要使用\n\n\n\n// 第一种\nvar user1, user2, user3 string\n// 第二种\nvar user1, user2, user3 = \"user1\", 1, true\n// 第三种\nvar (\n    user1 string\n    user2 int\n    user3 bool\n)\n\n\n\n1、变量必须事先定义 2、公式静态语言，要求变量类型和赋值类型一致 3、变量名不能冲突 4、简介变量定义不能作为全局变量（age := 1） 5、变量有零值，也就是默认值\nvar age int //age默认为0\nvar name string //name默认为\"\"\nvar isOk bool //isOk默认为false\n6、全局变量定义之后可以不使用，但是局部变量定义之后必须要使用，否则会报错\n\n\n\n\n\n常量，是在定义的时候就指定的值，不能修改\n在go语言中，常量定义的时候尽量全部大写，便于区分 ### 2.1、定义常量的方式\n\n// 第一种\nconst PI float32 = 3.1415926 //显示定义\nconst PI = 3.1415926 //隐式定义\n// 之后PI不能改变\nPI = 3.1415926 //报错\n\n\n变量在成组进行定义是也有多种方式\nconst(\n    PI float32 = 3.1415926\n    PI2 = 'a'\n    PI3 = 3\n)\n特别的：\ncosnt(\n    x int  = 1p\n    y\n    s = 'a'\n    z\n    m\n)\n\n\n\n\n1、常量类型只能是bool、数值和字符串 2、常量没有强制使用的要求，定义之后可以选择不使用 3、显示指定类型的时候，必须保证常量左右值类型一致\n\n\n\n\n\n一种能够被编译器修改的特殊常量\n\n\n\n//写法1\nconst (\n    ERR0 = iota\n    ERR1 = iota\n    ERR2 = iota\n    ERR3 = iota\n    ERR4 = iota\n)\n// 输出为：0、1、2、3、4\n//写法2\nconst (\n    ERR0 = iota\n    ERR1\n    ERR2\n    ERR3\n    ERR4\n)\n// 输出也为0、1、2、3、4\n有关iota的计数器特性，如下图 \n\niota内部有同一个计数器，自己递增，不受赋值的影响\n出现新的const时，iota会归零 ### 3.2、注意事项 1、如果中断了iota必须显示恢复，后续会自动递增 2、iota默认类型是int型 3、iota能简化const类型的定义 4、每次出现新的const之后iota会归0\n\n\n\n\n\n用下划线进行标识，不使用不会报错\n如：var _ int = 10\n在go语言中，匿名变量是指没有名字的变量。匿名变量在函数中经常被用作占位符，用于接收函数返回的多个值中的一部分。 下面是一个应用场景的举例： \n\n\n\n\n\n\n在函数外部定义的变量，作用域为整个包。\n\n\n\n在函数内部定义的变量，作用域为函数内部。\n有严格限制，在使用的时候需要注意。"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（3）.html#变量",
    "href": "content/learning-notes/golang/entries/golang学习记录（3）.html#变量",
    "title": "golang学习记录（3）",
    "section": "",
    "text": "// 第一种\nvar age int (string bool 等)\nage = 10\n// 第二种\nvar age = 10\n// 第三种\nage := 10\n\n\n\n\n全局变量：在函数外部定义的变量，作用域为整个包\n局部变量：在函数内部定义的变量，作用域为函数内部\n\n注：全局变量定义之后可以不使用，但是局部变量定义之后必须要使用\n\n\n\n// 第一种\nvar user1, user2, user3 string\n// 第二种\nvar user1, user2, user3 = \"user1\", 1, true\n// 第三种\nvar (\n    user1 string\n    user2 int\n    user3 bool\n)\n\n\n\n1、变量必须事先定义 2、公式静态语言，要求变量类型和赋值类型一致 3、变量名不能冲突 4、简介变量定义不能作为全局变量（age := 1） 5、变量有零值，也就是默认值\nvar age int //age默认为0\nvar name string //name默认为\"\"\nvar isOk bool //isOk默认为false\n6、全局变量定义之后可以不使用，但是局部变量定义之后必须要使用，否则会报错"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（3）.html#常量",
    "href": "content/learning-notes/golang/entries/golang学习记录（3）.html#常量",
    "title": "golang学习记录（3）",
    "section": "",
    "text": "常量，是在定义的时候就指定的值，不能修改\n在go语言中，常量定义的时候尽量全部大写，便于区分 ### 2.1、定义常量的方式\n\n// 第一种\nconst PI float32 = 3.1415926 //显示定义\nconst PI = 3.1415926 //隐式定义\n// 之后PI不能改变\nPI = 3.1415926 //报错\n\n\n变量在成组进行定义是也有多种方式\nconst(\n    PI float32 = 3.1415926\n    PI2 = 'a'\n    PI3 = 3\n)\n特别的：\ncosnt(\n    x int  = 1p\n    y\n    s = 'a'\n    z\n    m\n)\n\n\n\n\n1、常量类型只能是bool、数值和字符串 2、常量没有强制使用的要求，定义之后可以选择不使用 3、显示指定类型的时候，必须保证常量左右值类型一致"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（3）.html#iota",
    "href": "content/learning-notes/golang/entries/golang学习记录（3）.html#iota",
    "title": "golang学习记录（3）",
    "section": "",
    "text": "一种能够被编译器修改的特殊常量\n\n\n\n//写法1\nconst (\n    ERR0 = iota\n    ERR1 = iota\n    ERR2 = iota\n    ERR3 = iota\n    ERR4 = iota\n)\n// 输出为：0、1、2、3、4\n//写法2\nconst (\n    ERR0 = iota\n    ERR1\n    ERR2\n    ERR3\n    ERR4\n)\n// 输出也为0、1、2、3、4\n有关iota的计数器特性，如下图 \n\niota内部有同一个计数器，自己递增，不受赋值的影响\n出现新的const时，iota会归零 ### 3.2、注意事项 1、如果中断了iota必须显示恢复，后续会自动递增 2、iota默认类型是int型 3、iota能简化const类型的定义 4、每次出现新的const之后iota会归0"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（3）.html#匿名变量",
    "href": "content/learning-notes/golang/entries/golang学习记录（3）.html#匿名变量",
    "title": "golang学习记录（3）",
    "section": "",
    "text": "用下划线进行标识，不使用不会报错\n如：var _ int = 10\n在go语言中，匿名变量是指没有名字的变量。匿名变量在函数中经常被用作占位符，用于接收函数返回的多个值中的一部分。 下面是一个应用场景的举例："
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（3）.html#变量的作用域",
    "href": "content/learning-notes/golang/entries/golang学习记录（3）.html#变量的作用域",
    "title": "golang学习记录（3）",
    "section": "",
    "text": "在函数外部定义的变量，作用域为整个包。\n\n\n\n在函数内部定义的变量，作用域为函数内部。\n有严格限制，在使用的时候需要注意。"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（5）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（5）.html",
    "title": "golang学习记录（5）",
    "section": "",
    "text": "通常在各种语言中转义符都是同一个：，千万不要写反\n\n举例：\nname := \"你可真是个\\\"小机灵鬼\\\"\"\n//在这里直接使用\"小机灵鬼\"会报错，因为双引号是字符串的标志，所以需要使用转义符来表示引号：\\\"\n\n\n\n在golang中常用的转义符如下：\n\n\n\n\n\nPrintln:表示输出换行 Print:表示输出不换行 ### 2.1、基本使用\n通常情况下使用平凑方法进行输出非常麻烦： \n使用格式化输出的方法–Printf:\nfmt.Printf(\"用户名：%s， 年龄：%d，地址：%s， 电话：%s\\r\\n\",username, age, address, mobile )\n\n\n优点：易读易维护\n缺点：性能相对较低\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n计算字符串的长度也有很多种情况\n\n\nname := \"hello world\"\nfmt.Println(len(name))\n\n\n\nname := \"hello 世界\"\nbytes := []byte(name)\nfmt.Println(len(bytes))\n\n\n\n\n\n\nusername := \"user\" + \"name\"\n\n\n\nfmt.Printf(\"用户名：%s， 年龄：%d，地址：%s， 电话：%s\\r\\n\",username, age, address, mobile )\n\n\n\n\n这是一种高性能的方式\n\nvar builder strings.Builder\nbuilder.WriteString(\"hello\")\nbuilder.WriteString(\"world\")\nresult := builder.String()\nfmt.Println(result)\n\n\n\n\n//等于\na := \"hello\"\nb := \"hello\"\nfmt.Println(a == b)\n\n//不等于\na = \"hello\"\nb = \"world\"\nfmt.Println(a != b)\n\n//大于\na = \"hello\"\nb = \"world\"\nfmt.Println(a &gt; b)\n\n//小于\na = \"hello\"\nb = \"world\"\nfmt.Println(a &lt; b)\n\n//大于等于\n//小于等于\n//……\n\n\n\n\n\nimport {\n    \"fmt\"\n    \"strings\"\n}\n\n\n\n(1)、是否包含指定字符串\nstrings.Contains(\"hello world\", \"world\")\n(2)、字符串的长度\nname := \"hello world\"\nlen(name)\n(3)、查询字串出现的次数\nstrings.Count(\"hello world\", \"l\")\n(4)、分割字符串\n//以空格为分隔符进行分割\nstrings.Split(\"hello world\", \" \")\n(5)、字符串是否包含前后缀\n//前缀\nstrings.HasPrefix(\"hello world\", \"he\")\n\n//后缀\nstrings.HasSuffix(\"hello world\", \"ld\")\n(6)、查询字串出现的位置\n//英文\nstrings.Index(\"hello world\", \"lo\")\n(7)、字串替换\n//把字符串里的所有l替换成a，替换前2个\n//-1表示全部替换\nstrings.Replace(\"hello world\", \"l\", \"a\", 2)\n(8)、大小写转换\n//全转成小写\nstrings.ToLower(\"HELLO WORLD\")\n\n//全转成大写\nstrings.ToUpper(\"hello world\")\n(9)、去掉特殊字符\n//去掉左右两边指定的字符，指定的字符可以是多个，比如空格，#，*等\nstrings.Trim(\"#hello #world#\", \"#\")\n//得到的结果是：hello #world\n\n//左边的特殊字符\nstrings.TrimLeft(\"#hello #world#\", \"#\")\n//得到的结果是：hello #world#\n\n//右边的特殊字符\nstrings.TrimRight(\"#hello #world#\", \"#\")\n//得到的结果是：#hello #world\n\n更多方法可以查看源码，在ide中点击显示的函数可以直接转换到源码"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（5）.html#转义符",
    "href": "content/learning-notes/golang/entries/golang学习记录（5）.html#转义符",
    "title": "golang学习记录（5）",
    "section": "",
    "text": "通常在各种语言中转义符都是同一个：，千万不要写反\n\n举例：\nname := \"你可真是个\\\"小机灵鬼\\\"\"\n//在这里直接使用\"小机灵鬼\"会报错，因为双引号是字符串的标志，所以需要使用转义符来表示引号：\\\"\n\n\n\n在golang中常用的转义符如下："
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（5）.html#格式化输出",
    "href": "content/learning-notes/golang/entries/golang学习记录（5）.html#格式化输出",
    "title": "golang学习记录（5）",
    "section": "",
    "text": "Println:表示输出换行 Print:表示输出不换行 ### 2.1、基本使用\n通常情况下使用平凑方法进行输出非常麻烦： \n使用格式化输出的方法–Printf:\nfmt.Printf(\"用户名：%s， 年龄：%d，地址：%s， 电话：%s\\r\\n\",username, age, address, mobile )\n\n\n优点：易读易维护\n缺点：性能相对较低"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（5）.html#字符串操作常用方法",
    "href": "content/learning-notes/golang/entries/golang学习记录（5）.html#字符串操作常用方法",
    "title": "golang学习记录（5）",
    "section": "",
    "text": "计算字符串的长度也有很多种情况\n\n\nname := \"hello world\"\nfmt.Println(len(name))\n\n\n\nname := \"hello 世界\"\nbytes := []byte(name)\nfmt.Println(len(bytes))\n\n\n\n\n\n\nusername := \"user\" + \"name\"\n\n\n\nfmt.Printf(\"用户名：%s， 年龄：%d，地址：%s， 电话：%s\\r\\n\",username, age, address, mobile )\n\n\n\n\n这是一种高性能的方式\n\nvar builder strings.Builder\nbuilder.WriteString(\"hello\")\nbuilder.WriteString(\"world\")\nresult := builder.String()\nfmt.Println(result)\n\n\n\n\n//等于\na := \"hello\"\nb := \"hello\"\nfmt.Println(a == b)\n\n//不等于\na = \"hello\"\nb = \"world\"\nfmt.Println(a != b)\n\n//大于\na = \"hello\"\nb = \"world\"\nfmt.Println(a &gt; b)\n\n//小于\na = \"hello\"\nb = \"world\"\nfmt.Println(a &lt; b)\n\n//大于等于\n//小于等于\n//……\n\n\n\n\n\nimport {\n    \"fmt\"\n    \"strings\"\n}\n\n\n\n(1)、是否包含指定字符串\nstrings.Contains(\"hello world\", \"world\")\n(2)、字符串的长度\nname := \"hello world\"\nlen(name)\n(3)、查询字串出现的次数\nstrings.Count(\"hello world\", \"l\")\n(4)、分割字符串\n//以空格为分隔符进行分割\nstrings.Split(\"hello world\", \" \")\n(5)、字符串是否包含前后缀\n//前缀\nstrings.HasPrefix(\"hello world\", \"he\")\n\n//后缀\nstrings.HasSuffix(\"hello world\", \"ld\")\n(6)、查询字串出现的位置\n//英文\nstrings.Index(\"hello world\", \"lo\")\n(7)、字串替换\n//把字符串里的所有l替换成a，替换前2个\n//-1表示全部替换\nstrings.Replace(\"hello world\", \"l\", \"a\", 2)\n(8)、大小写转换\n//全转成小写\nstrings.ToLower(\"HELLO WORLD\")\n\n//全转成大写\nstrings.ToUpper(\"hello world\")\n(9)、去掉特殊字符\n//去掉左右两边指定的字符，指定的字符可以是多个，比如空格，#，*等\nstrings.Trim(\"#hello #world#\", \"#\")\n//得到的结果是：hello #world\n\n//左边的特殊字符\nstrings.TrimLeft(\"#hello #world#\", \"#\")\n//得到的结果是：hello #world#\n\n//右边的特殊字符\nstrings.TrimRight(\"#hello #world#\", \"#\")\n//得到的结果是：#hello #world\n\n更多方法可以查看源码，在ide中点击显示的函数可以直接转换到源码"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（7）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（7）.html",
    "title": "golang学习记录（7）",
    "section": "",
    "text": "数组的定义： var name [length] type\n举个例子： var name [5] int\n当中括号内没有length，就表示数组的长度是不确定的，这种数组叫做切片。\n\n\n\n\nfmt.Println(name)，可以打印数组的所有元素\n数组的长度是固定的\n\n数组的遍历：\nfor _, value := range name{\n    fmt.Prinntln(value)\n}\n\n\n\n//多种初始化方式\nvar name [5] int = [5]int{1, 2, 3, 4, 5}\nvar name = [5]int{1, 2, 3, 4, 5}\nname := [5]int{1, 2, 3, 4, 5}\n\n//只初始化部分元素\nname := [3]int{2:3}\n//前面的都为0，name[2] = 3\n\n//数组的长度是不确定的\nname := [...]int{1, 2, 3, 4, 5}\nname := [...]int{1, 2, 3}\n\n相同类型，长度相同的数据可以相互赋值，字符串类型的可以相互比较\n\n\n\n\n//基本定义方式\nvar name [3][4] string\nname[0] = [4]string{\"a\", \"b\", \"c\", \"d\"}\nname[0][0] = \"a\"\n\n\n\n\n\n切片就是没有长度的数组，切片的长度是不固定的，切片是数组的一个引用，切片是引用类型。\n\n\n\n\n\nvar name []string\nfmt.Printf(%T, name)\n//输出结果为[]string，本质是切片\n\n\n\n// 使用append来增加元素，注意书写的格式\nname = append(name, \"a\")\n\n\n\n\n\n初始化一共有三种方式\n1、数组直接创建\n2、使用string{}\n3、使用make\n\n// 第一种\nallName := [5]string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\nnameSlice := allName[0:2] // \"左闭右开，包含0，不包含2\"\n\n//第二种\nallName := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\n//在切片上也可以进行切片创建\n\n//第三种\n//第一个参数是切片的类型，第二个参数是预分配的空间（长度）\nallName := make([]string, 5)\n\n\n\nallName := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\n\nsliceName := allName[start:end] //左闭右开\n//如果没有end，默认是到最后一个元素\n//没有start,有end，默认是从第一个元素开始到end之前的元素\n//冒号一定存在\n\n\n\n\n再append得使用过程中，添加的元素可以是多个\n可以通过直接添加元素的方式加入\n也可以通过使用数组或者切片加省略号的方式加入（通过加入省略号将原来的元素打散）\n// 直接列出元素的情况\nname := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\nname = append(name, \"fff\", \"ggg\", \"hhh\")\n\n// 通过切片加入的情况\nname := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\nname2 := []string{\"fff\", \"ggg\", \"hhh\"}\nname = append(name, name2...)\n\n// 通过数组加入的情况\nname := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\nname2 := [3]string{\"fff\", \"ggg\", \"hhh\"}\nname = append(name, name2[:]...)\n\n\n\n\n\n\n切片的删除操作是append或者其他重新生成slice的方式进行\n\n// 切片的删除操作\nname := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\n// 删除一个中间的元素\nnewName = append(name[:2], name[3:]...)\n\n// 删除后面的元素\nnewName := name[:3]\nnewName = append(name[:3])\n\n\n\n\n拷贝也有多种方式\n\nname := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\n\n// 第一种切片赋值\nname2 := name[:]\n\n// 第二种使用copy函数\nvar name3 = make([]string, len(name))\ncopy(name3, name)\n\n不同切片复制的方式会有不同的效果\n\n示例如下： \n从图中可以看出，改变原来的切片，切片赋值的方式，会改变新的切片，而copy函数的方式，不会改变新的切片。\n本质上是因为切片赋值的方式，是将原来的切片的地址赋值给了新的切片，而copy函数的方式，是将原来的切片的元素复制到了新的切片中（地址是新分配的）。\n\n\n\n\n\ngo的slice在函数参数传递的时候是值传递还是引用传递\n本质上是值传递，但是呈现出引用的效果，这涉及slice的底层原理\n在go中，slice的底层是一个结构体，结构体中有三个字段，分别是指向底层数组的指针，切片的长度和切片的容量\n\n\n\n// slice的底层结构如下：\ntype slice struct {\n    array unsafe.Pointer   //用来存储实际数据的数组指针只想一块连续的内存\n    len int                //切片中元素的数量\n    cap int                //array数组的长度\n}\n\n\n\n刚开始的时候slice会申请一个较大的容量，扩容是一个非常麻烦的过程：\n\n扩容的时候刚开始是成倍的扩容，等到空间变大时扩容会减缓\n\n\n\n\n在参数传递的时候会将原来的结构体整体复制一份，多以指向数组的指针也复制了，指针指向原来切片指向的位置\n之后随着元素的加入会发生扩容，会将原来的数组复制到一个新的数组中，然后将原来的数组的指针指向新的数组，然后将原来的数组的长度和容量都改为原来的两倍。这个时候指针的位置发生变化\n所以参数传递后能改变原来切片的元素，但是不能改变原来切片的长度和容量。参数传递扩容后不会改变原来切片的元素。 {: .prompt-tip }\n\n下面是一个例子：\n\n\n\n\n\n\n\n\nmap是一个key-value的无序集合，主要是为了查询方便，时间复杂度为O(1)\nmap中的key是唯一的，value可以重复\nmap中key的类型可以是bool、数字、string、指针、channel、还可以是只包含前面几个类型的接口、结构体、数组，但是不能是slice、map、function，value可以是任意类型\n\n\n\n举个例子：\nvar courseMap map[string]string{\n    \"courseName\": \"golang\",\n    \"courseType\": \"backend\",\n}\n// 其中基本格式是map[key_type] value_type\n\n\n\nmap类型想要使用必须先要初始化，不然map为nil(空指针)，会报错，不能使用\n初始化的方式主要有两种，一种是在定义的时候直接赋值，第二种是使用make函数进行初始化，分配空间，创建一个空的map\n\n// 第一种初始化方式\nvar courseMap map[string]string{\n    \"courseName\": \"golang\",\n    \"courseType\": \"backend\",\n}\n\n// 第二种初始化方式\nvar courseMap = make(map[string] string, 10)//make是一个内置函数\ncoueseMap[\"courseName\"] = \"golang\"\n相比之下，slice可以不进行初始化\n\n\n\n\nmap的获取元素的方式是通过key来获取value\n如果key不存在，会返回value的零值\n\nvar courseMap map[string]string{\n    \"courseName\": \"golang\",\n    \"courseType\": \"backend\",\n}\nfmt.Println(courseMap[\"courseName\"])\n\n// 第二种获取元素的方式\nvalue, ok := courseMap[\"courseName\"]\nif ok{\n    fmt.Println(value)\n}else{\n    fmt.Println(\"key不存在\")\n}\n\nif value, ok := courseMap[\"courseName\"]; ok{\n    fmt.Println(value)\n}else{\n    fmt.Println(\"key不存在\")\n}\n\n\n\n\nmap有一个内置的delete函数，用来删除map中的元素\n如果删除的元素不存在也不会报错\n\ndelete(courseMap, \"courseName\")\n//delete(map_name, key)\n\n\n\n\n\nmap的遍历是通过for-range的方式进行遍历\nmap是无序的，所以遍历的顺序是不确定的，每次打印的顺序可能不一样\n\n//第一种遍历方式，两个参数\nfor _, value := range courseMap{\n    fmt.Println(value)\n}\n\n// 第二种遍历方式，一个参数，key，然后通过key访问value\nfor key := range courseMap{\n    fmt.Println(key, courseMap[key])\n}\n\n\n\n\n\n\n\nlist是一个”双向链表”，是一个有序的集合，主要是为了插入和删除方便，利用不连续空间\nlist占用空间比较多，会额外存储指针，指向前后的元素\n列表插入和删除比较方便，查询比较麻烦，时间复杂度为O(n)\n\n\n\n\nvar mylist list.List\nmylist.PushBack(\"go\")\nmylist.PushBack(\"java\")\nmylist.PushBack(\"python\")\n\n// 遍历list(正向)\nfor i := mylist.Front(); i!= nil; i = i.Next(){\n    fmt.Println(i.Value)\n}\n\n// 反向遍历\nfor i:= mtlist.Back(); i != nil; i = i.Prev(){\n    fmt.Println(i.Value)\n}\n\nmylist.PushFront(\"c++\")//头部插入元素\nmylist.PushBack(\"c\")//尾部插入元素\nmylist.InsertAfter(\"c#\", mylist.Front())//在指定元素后面插入元素\nmylist.InsertBefore(\"c#\", mylist.Back())//在指定元素前面插入元素\n\nmylist.Remove(mylist.Front())//删除头部元素\nmylist.Remove(mylist.Back())//删除尾部元素\\\nmylist.Remove(i))//删除指定元素"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（7）.html#数组",
    "href": "content/learning-notes/golang/entries/golang学习记录（7）.html#数组",
    "title": "golang学习记录（7）",
    "section": "",
    "text": "数组的定义： var name [length] type\n举个例子： var name [5] int\n当中括号内没有length，就表示数组的长度是不确定的，这种数组叫做切片。\n\n\n\n\nfmt.Println(name)，可以打印数组的所有元素\n数组的长度是固定的\n\n数组的遍历：\nfor _, value := range name{\n    fmt.Prinntln(value)\n}\n\n\n\n//多种初始化方式\nvar name [5] int = [5]int{1, 2, 3, 4, 5}\nvar name = [5]int{1, 2, 3, 4, 5}\nname := [5]int{1, 2, 3, 4, 5}\n\n//只初始化部分元素\nname := [3]int{2:3}\n//前面的都为0，name[2] = 3\n\n//数组的长度是不确定的\nname := [...]int{1, 2, 3, 4, 5}\nname := [...]int{1, 2, 3}\n\n相同类型，长度相同的数据可以相互赋值，字符串类型的可以相互比较\n\n\n\n\n//基本定义方式\nvar name [3][4] string\nname[0] = [4]string{\"a\", \"b\", \"c\", \"d\"}\nname[0][0] = \"a\""
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（7）.html#切片",
    "href": "content/learning-notes/golang/entries/golang学习记录（7）.html#切片",
    "title": "golang学习记录（7）",
    "section": "",
    "text": "切片就是没有长度的数组，切片的长度是不固定的，切片是数组的一个引用，切片是引用类型。\n\n\n\n\n\nvar name []string\nfmt.Printf(%T, name)\n//输出结果为[]string，本质是切片\n\n\n\n// 使用append来增加元素，注意书写的格式\nname = append(name, \"a\")\n\n\n\n\n\n初始化一共有三种方式\n1、数组直接创建\n2、使用string{}\n3、使用make\n\n// 第一种\nallName := [5]string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\nnameSlice := allName[0:2] // \"左闭右开，包含0，不包含2\"\n\n//第二种\nallName := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\n//在切片上也可以进行切片创建\n\n//第三种\n//第一个参数是切片的类型，第二个参数是预分配的空间（长度）\nallName := make([]string, 5)\n\n\n\nallName := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\n\nsliceName := allName[start:end] //左闭右开\n//如果没有end，默认是到最后一个元素\n//没有start,有end，默认是从第一个元素开始到end之前的元素\n//冒号一定存在\n\n\n\n\n再append得使用过程中，添加的元素可以是多个\n可以通过直接添加元素的方式加入\n也可以通过使用数组或者切片加省略号的方式加入（通过加入省略号将原来的元素打散）\n// 直接列出元素的情况\nname := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\nname = append(name, \"fff\", \"ggg\", \"hhh\")\n\n// 通过切片加入的情况\nname := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\nname2 := []string{\"fff\", \"ggg\", \"hhh\"}\nname = append(name, name2...)\n\n// 通过数组加入的情况\nname := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\nname2 := [3]string{\"fff\", \"ggg\", \"hhh\"}\nname = append(name, name2[:]...)\n\n\n\n\n\n\n切片的删除操作是append或者其他重新生成slice的方式进行\n\n// 切片的删除操作\nname := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\n// 删除一个中间的元素\nnewName = append(name[:2], name[3:]...)\n\n// 删除后面的元素\nnewName := name[:3]\nnewName = append(name[:3])\n\n\n\n\n拷贝也有多种方式\n\nname := []string{\"aaa\", \"bbb\", \"ccc\", \"ddd\", \"eee\"}\n\n// 第一种切片赋值\nname2 := name[:]\n\n// 第二种使用copy函数\nvar name3 = make([]string, len(name))\ncopy(name3, name)\n\n不同切片复制的方式会有不同的效果\n\n示例如下： \n从图中可以看出，改变原来的切片，切片赋值的方式，会改变新的切片，而copy函数的方式，不会改变新的切片。\n本质上是因为切片赋值的方式，是将原来的切片的地址赋值给了新的切片，而copy函数的方式，是将原来的切片的元素复制到了新的切片中（地址是新分配的）。\n\n\n\n\n\ngo的slice在函数参数传递的时候是值传递还是引用传递\n本质上是值传递，但是呈现出引用的效果，这涉及slice的底层原理\n在go中，slice的底层是一个结构体，结构体中有三个字段，分别是指向底层数组的指针，切片的长度和切片的容量\n\n\n\n// slice的底层结构如下：\ntype slice struct {\n    array unsafe.Pointer   //用来存储实际数据的数组指针只想一块连续的内存\n    len int                //切片中元素的数量\n    cap int                //array数组的长度\n}\n\n\n\n刚开始的时候slice会申请一个较大的容量，扩容是一个非常麻烦的过程：\n\n扩容的时候刚开始是成倍的扩容，等到空间变大时扩容会减缓\n\n\n\n\n在参数传递的时候会将原来的结构体整体复制一份，多以指向数组的指针也复制了，指针指向原来切片指向的位置\n之后随着元素的加入会发生扩容，会将原来的数组复制到一个新的数组中，然后将原来的数组的指针指向新的数组，然后将原来的数组的长度和容量都改为原来的两倍。这个时候指针的位置发生变化\n所以参数传递后能改变原来切片的元素，但是不能改变原来切片的长度和容量。参数传递扩容后不会改变原来切片的元素。 {: .prompt-tip }\n\n下面是一个例子："
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（7）.html#map",
    "href": "content/learning-notes/golang/entries/golang学习记录（7）.html#map",
    "title": "golang学习记录（7）",
    "section": "",
    "text": "map是一个key-value的无序集合，主要是为了查询方便，时间复杂度为O(1)\nmap中的key是唯一的，value可以重复\nmap中key的类型可以是bool、数字、string、指针、channel、还可以是只包含前面几个类型的接口、结构体、数组，但是不能是slice、map、function，value可以是任意类型\n\n\n\n举个例子：\nvar courseMap map[string]string{\n    \"courseName\": \"golang\",\n    \"courseType\": \"backend\",\n}\n// 其中基本格式是map[key_type] value_type\n\n\n\nmap类型想要使用必须先要初始化，不然map为nil(空指针)，会报错，不能使用\n初始化的方式主要有两种，一种是在定义的时候直接赋值，第二种是使用make函数进行初始化，分配空间，创建一个空的map\n\n// 第一种初始化方式\nvar courseMap map[string]string{\n    \"courseName\": \"golang\",\n    \"courseType\": \"backend\",\n}\n\n// 第二种初始化方式\nvar courseMap = make(map[string] string, 10)//make是一个内置函数\ncoueseMap[\"courseName\"] = \"golang\"\n相比之下，slice可以不进行初始化\n\n\n\n\nmap的获取元素的方式是通过key来获取value\n如果key不存在，会返回value的零值\n\nvar courseMap map[string]string{\n    \"courseName\": \"golang\",\n    \"courseType\": \"backend\",\n}\nfmt.Println(courseMap[\"courseName\"])\n\n// 第二种获取元素的方式\nvalue, ok := courseMap[\"courseName\"]\nif ok{\n    fmt.Println(value)\n}else{\n    fmt.Println(\"key不存在\")\n}\n\nif value, ok := courseMap[\"courseName\"]; ok{\n    fmt.Println(value)\n}else{\n    fmt.Println(\"key不存在\")\n}\n\n\n\n\nmap有一个内置的delete函数，用来删除map中的元素\n如果删除的元素不存在也不会报错\n\ndelete(courseMap, \"courseName\")\n//delete(map_name, key)\n\n\n\n\n\nmap的遍历是通过for-range的方式进行遍历\nmap是无序的，所以遍历的顺序是不确定的，每次打印的顺序可能不一样\n\n//第一种遍历方式，两个参数\nfor _, value := range courseMap{\n    fmt.Println(value)\n}\n\n// 第二种遍历方式，一个参数，key，然后通过key访问value\nfor key := range courseMap{\n    fmt.Println(key, courseMap[key])\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（7）.html#list",
    "href": "content/learning-notes/golang/entries/golang学习记录（7）.html#list",
    "title": "golang学习记录（7）",
    "section": "",
    "text": "list是一个”双向链表”，是一个有序的集合，主要是为了插入和删除方便，利用不连续空间\nlist占用空间比较多，会额外存储指针，指向前后的元素\n列表插入和删除比较方便，查询比较麻烦，时间复杂度为O(n)\n\n\n\n\nvar mylist list.List\nmylist.PushBack(\"go\")\nmylist.PushBack(\"java\")\nmylist.PushBack(\"python\")\n\n// 遍历list(正向)\nfor i := mylist.Front(); i!= nil; i = i.Next(){\n    fmt.Println(i.Value)\n}\n\n// 反向遍历\nfor i:= mtlist.Back(); i != nil; i = i.Prev(){\n    fmt.Println(i.Value)\n}\n\nmylist.PushFront(\"c++\")//头部插入元素\nmylist.PushBack(\"c\")//尾部插入元素\nmylist.InsertAfter(\"c#\", mylist.Front())//在指定元素后面插入元素\nmylist.InsertBefore(\"c#\", mylist.Back())//在指定元素前面插入元素\n\nmylist.Remove(mylist.Front())//删除头部元素\nmylist.Remove(mylist.Back())//删除尾部元素\\\nmylist.Remove(i))//删除指定元素"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（9）.html",
    "href": "content/learning-notes/golang/entries/golang学习记录（9）.html",
    "title": "golang学习记录（9）",
    "section": "",
    "text": "type关键字常用于\n定义结构体\n定义接口\n定义类型别名\n类型定义\n类型判断\n\n\n\n\n别名可以让使用者更好理解代码，提高代码的可读性和可维护性，在编译的时候，会将别名编译为原来的类型\n\n//以定义int的别名举例\ntype MyInt = int\nvar i MyInt\nfmt.Println(\"%T\\n\", i)\n//上面代码输出的结果为int，相当一给int取了一个小名，MyInt本质上还是int\n\n\n\n\n自定义类型是一种新的数据类型，它是基于已有的类型（如int、string等）创建的，它可以包含多个字段，每个字段都有自己的名称和类型。自定义类型可以用于创建更复杂的数据结构，以满足特定的需求。\n\ntype MyInt int // 相比于类型别名，没有等号\nvar i MyInt\nfmt.Println(\"%T\\n\", i)\n//上面代码输出的结果为xxxx.MyInt\n自定义类型有什么意义？\n可以给数据类型增加方法，使用更加灵活\nfunc (mi MyInt) string() string{\n    return strconv.Itoa(int(mi))\n}\n\nfunc main(){\n    var i MyInt = 10\n    fmt.Println(i.string())\n}\n// 上面的代码给MyInt增加了一个string方法，这样就可以将MyInt类型转换为string类型\n\n\n\n\n\ngo中的结构体借鉴了面向对象的特性和C语言结构体的简洁性\n\n假设要设计一个结构体存储个人信息，包括name、age、address、mobile等，那么可以使用如下方式定义结构体：\ntype Person struct{\n    name string\n    age int\n    address string\n    mobile string\n}\n\nfunc main(){\n    //结构体的初始化方式\n    p1 := Person{\"小明\", 18, \"北京\", \"13812345678\"} //省略写法每个元素都要写\n    p2 := Person{name: \"小红\", age: 19, address: \"上海\", mobile: \"13812345679\"} //能够填部分元素，更灵活\n    var p3 Person\n    p3.name = \"小刚\"\n\n    var persons []Person\n    persons = append(persons, p1)\n    persons = append(persons, Person{\"小刚\", 20, \"广州\", \"13812345680\"})\n}\n\n\n\n\n定义临时的一次性的结构体\n\naddress := struct{\n    province string\n    city string\n    district string\n}{\n    \"北京\",\n     \"北京\", \n     \"海淀区\"\n}\nfmt.Println(address.city)\n\n\n\n\n结构体可以在一个结构体中嵌套另一个结构体\n\ntype Person struct{\n    name string\n    age int\n}\n// 可以不用重复定义\ntype Student struct{\n    // 第一种嵌套方式\n    p Person\n    score float32\n}\n\nfunc main() {\n    // 第一种初始化方式\n    s := Student{\n        p: Person{\n            name: \"小明\",\n            age: 18,\n        },\n        score: 90,\n    }\n    fmt.Println(s.p.name)\n\n    // 第二种初始化方式\n    s := Student{}\n    s.p.name = \"小明\"\n}\n匿名嵌套\ntype Person struct{\n    name string\n    age int\n}\n// 可以不用重复定义\ntype Student struct{\n    // 第二种嵌套方式--匿名嵌套\n    Person\n    score float32\n}\n\nfunc main() {\n    // 初始化方式\n    s.name = \"小明\"\n}\n\n\n\n\n给结构体定义一个方法\n在go中定义结构体的方法是在结构体外进行定义的\n\ntype Person struct{\n    name string\n    age int\n}\n\nfunc (p Person) print(){\n    fmt.Printf(\"姓名：%s， 年龄：%d\\r\\n\", p.name, p.age)\n}\n\nfunc main() {\n    p := Person{\n        name: \"小明\",\n        age: 18,\n    }\n    p.print()\n}\n想要在结构体方法中修改结构体的属性，需要使用指针类型的结构体\ntype Person struct{\n    name string\n    age int\n}\n\nfunc (p *Person) print(){\n    p.age = 19\n    fmt.Printf(\"姓名：%s， 年龄：%d\\r\\n\", p.name, p.age)\n}\n\nfunc main() {\n    p := Person{\n        name: \"小明\",\n        age: 18,\n    }\n    p.print()\n}\n//此时输出的结果为：姓名：小明， 年龄：19"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（9）.html#type关键字",
    "href": "content/learning-notes/golang/entries/golang学习记录（9）.html#type关键字",
    "title": "golang学习记录（9）",
    "section": "",
    "text": "type关键字常用于\n定义结构体\n定义接口\n定义类型别名\n类型定义\n类型判断\n\n\n\n\n别名可以让使用者更好理解代码，提高代码的可读性和可维护性，在编译的时候，会将别名编译为原来的类型\n\n//以定义int的别名举例\ntype MyInt = int\nvar i MyInt\nfmt.Println(\"%T\\n\", i)\n//上面代码输出的结果为int，相当一给int取了一个小名，MyInt本质上还是int\n\n\n\n\n自定义类型是一种新的数据类型，它是基于已有的类型（如int、string等）创建的，它可以包含多个字段，每个字段都有自己的名称和类型。自定义类型可以用于创建更复杂的数据结构，以满足特定的需求。\n\ntype MyInt int // 相比于类型别名，没有等号\nvar i MyInt\nfmt.Println(\"%T\\n\", i)\n//上面代码输出的结果为xxxx.MyInt\n自定义类型有什么意义？\n可以给数据类型增加方法，使用更加灵活\nfunc (mi MyInt) string() string{\n    return strconv.Itoa(int(mi))\n}\n\nfunc main(){\n    var i MyInt = 10\n    fmt.Println(i.string())\n}\n// 上面的代码给MyInt增加了一个string方法，这样就可以将MyInt类型转换为string类型"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（9）.html#结构体的定义和初始化",
    "href": "content/learning-notes/golang/entries/golang学习记录（9）.html#结构体的定义和初始化",
    "title": "golang学习记录（9）",
    "section": "",
    "text": "go中的结构体借鉴了面向对象的特性和C语言结构体的简洁性\n\n假设要设计一个结构体存储个人信息，包括name、age、address、mobile等，那么可以使用如下方式定义结构体：\ntype Person struct{\n    name string\n    age int\n    address string\n    mobile string\n}\n\nfunc main(){\n    //结构体的初始化方式\n    p1 := Person{\"小明\", 18, \"北京\", \"13812345678\"} //省略写法每个元素都要写\n    p2 := Person{name: \"小红\", age: 19, address: \"上海\", mobile: \"13812345679\"} //能够填部分元素，更灵活\n    var p3 Person\n    p3.name = \"小刚\"\n\n    var persons []Person\n    persons = append(persons, p1)\n    persons = append(persons, Person{\"小刚\", 20, \"广州\", \"13812345680\"})\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（9）.html#匿名结构体",
    "href": "content/learning-notes/golang/entries/golang学习记录（9）.html#匿名结构体",
    "title": "golang学习记录（9）",
    "section": "",
    "text": "定义临时的一次性的结构体\n\naddress := struct{\n    province string\n    city string\n    district string\n}{\n    \"北京\",\n     \"北京\", \n     \"海淀区\"\n}\nfmt.Println(address.city)"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（9）.html#结构体嵌套",
    "href": "content/learning-notes/golang/entries/golang学习记录（9）.html#结构体嵌套",
    "title": "golang学习记录（9）",
    "section": "",
    "text": "结构体可以在一个结构体中嵌套另一个结构体\n\ntype Person struct{\n    name string\n    age int\n}\n// 可以不用重复定义\ntype Student struct{\n    // 第一种嵌套方式\n    p Person\n    score float32\n}\n\nfunc main() {\n    // 第一种初始化方式\n    s := Student{\n        p: Person{\n            name: \"小明\",\n            age: 18,\n        },\n        score: 90,\n    }\n    fmt.Println(s.p.name)\n\n    // 第二种初始化方式\n    s := Student{}\n    s.p.name = \"小明\"\n}\n匿名嵌套\ntype Person struct{\n    name string\n    age int\n}\n// 可以不用重复定义\ntype Student struct{\n    // 第二种嵌套方式--匿名嵌套\n    Person\n    score float32\n}\n\nfunc main() {\n    // 初始化方式\n    s.name = \"小明\"\n}"
  },
  {
    "objectID": "content/learning-notes/golang/entries/golang学习记录（9）.html#结构体-定义-方法",
    "href": "content/learning-notes/golang/entries/golang学习记录（9）.html#结构体-定义-方法",
    "title": "golang学习记录（9）",
    "section": "",
    "text": "给结构体定义一个方法\n在go中定义结构体的方法是在结构体外进行定义的\n\ntype Person struct{\n    name string\n    age int\n}\n\nfunc (p Person) print(){\n    fmt.Printf(\"姓名：%s， 年龄：%d\\r\\n\", p.name, p.age)\n}\n\nfunc main() {\n    p := Person{\n        name: \"小明\",\n        age: 18,\n    }\n    p.print()\n}\n想要在结构体方法中修改结构体的属性，需要使用指针类型的结构体\ntype Person struct{\n    name string\n    age int\n}\n\nfunc (p *Person) print(){\n    p.age = 19\n    fmt.Printf(\"姓名：%s， 年龄：%d\\r\\n\", p.name, p.age)\n}\n\nfunc main() {\n    p := Person{\n        name: \"小明\",\n        age: 18,\n    }\n    p.print()\n}\n//此时输出的结果为：姓名：小明， 年龄：19"
  },
  {
    "objectID": "content/learning-notes/infrastructure/entries/Consul.html",
    "href": "content/learning-notes/infrastructure/entries/Consul.html",
    "title": "Consul",
    "section": "",
    "text": "Consul 是 HashiCorp 开发的一款基于 Go 语言的开源基础设施，旨在为微服务架构提供一站式的服务治理能力。"
  },
  {
    "objectID": "content/learning-notes/infrastructure/entries/Consul.html#简介",
    "href": "content/learning-notes/infrastructure/entries/Consul.html#简介",
    "title": "Consul",
    "section": "简介",
    "text": "简介\nConsul 是 HashiCorp 开发的一款基于 Go 语言的开源基础设施，旨在为微服务架构提供一站式的服务治理能力：它通过服务发现机制实现了服务实例的自动注册与动态查找（DNS/HTTP），并结合实时的健康检查自动隔离故障节点，确保流量的高可用性；同时，它内置了分布式的 Key/Value 存储，可直接作为动态配置中心使用；此外，其原生支持的多数据中心架构，使其能够轻松打通跨机房或跨云环境的服务连接，是云原生生态中极具竞争力的基础设施组件。"
  },
  {
    "objectID": "content/learning-notes/infrastructure/entries/Consul.html#安装和启动",
    "href": "content/learning-notes/infrastructure/entries/Consul.html#安装和启动",
    "title": "Consul",
    "section": "安装和启动",
    "text": "安装和启动\n我在使用的时候选择通过docker安装和启动，下面是相关的指令\n# 安装\ndocker pull hashicorp/consul:latest\n\n# 启动\ndocker run -d \\\n  --name=dev-consul \\\n  -p 8500:8500 \\\n  hashicorp/consul:latest agent -dev -client=0.0.0.0\n\n之后在localhost:8500就可以进行访问"
  },
  {
    "objectID": "content/learning-notes/infrastructure/entries/Consul.html#在golang中使用consul",
    "href": "content/learning-notes/infrastructure/entries/Consul.html#在golang中使用consul",
    "title": "Consul",
    "section": "在golang中使用consul",
    "text": "在golang中使用consul\n官方提供相应的接口和库供开发人员调用: Hashicorp/consul\nimport \"github.com/hashicorp/consul/api\""
  },
  {
    "objectID": "content/learning-notes/infrastructure/entries/Consul.html#参考文献",
    "href": "content/learning-notes/infrastructure/entries/Consul.html#参考文献",
    "title": "Consul",
    "section": "参考文献",
    "text": "参考文献"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/api语言.html",
    "href": "content/learning-notes/microservices/entries/api语言.html",
    "title": "go-zero的API语言",
    "section": "",
    "text": "api 是 go-zero 自研的领域特性语言，旨在实现人性化的基础描述原因，作为生成 HTTP 服务最基本的描述语言。可以通过官方提供的 goctl 工具实现 api 向结构化项目的转换。"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/api语言.html#概述",
    "href": "content/learning-notes/microservices/entries/api语言.html#概述",
    "title": "go-zero的API语言",
    "section": "概述",
    "text": "概述\napi 领域特性语言包含语法版本，info 块，结构体声明，服务描述等几大块语法组成，其中结构体和 Golang 结构体语法几乎一样，只是移除了 struct 关键字。"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/api语言.html#syntax-语句",
    "href": "content/learning-notes/microservices/entries/api语言.html#syntax-语句",
    "title": "go-zero的API语言",
    "section": "syntax 语句",
    "text": "syntax 语句\nsyntax 语句用于标记 api 语言的版本，不同的版本可能语法结构有所不同，随着版本的提升会做不断的优化，当前版本为 v1。\nsyntax = \"v1\""
  },
  {
    "objectID": "content/learning-notes/microservices/entries/api语言.html#info-语句",
    "href": "content/learning-notes/microservices/entries/api语言.html#info-语句",
    "title": "go-zero的API语言",
    "section": "info 语句",
    "text": "info 语句\ninfo 语句是 api 语言的 meta 信息，其仅用于对当前 api 文件进行描述，暂不参与代码生成，其和注释还是有一些区别，注释一般是依附某个 syntax 语句存在，而 info 语句是用于描述整个 api 信息的。\n// 不包含 key-value 的 info 块\ninfo ()\n\n// 包含 key-value 的 info 块\ninfo (\n    foo: \"bar\"\n    bar:\n)"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/api语言.html#import语句",
    "href": "content/learning-notes/microservices/entries/api语言.html#import语句",
    "title": "go-zero的API语言",
    "section": "import语句",
    "text": "import语句\nimport 语句是在 api 中引入其他 api 文件的语法块，其支持相对路径和绝对路径，不支持 package 设计。\n// 单行 import\nimport \"foo\"\nimport \"/path/to/file\"\n\n// import 组\nimport ()\nimport (\n    \"bar\"\n    \"relative/to/file\"\n)"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/api语言.html#数据类型",
    "href": "content/learning-notes/microservices/entries/api语言.html#数据类型",
    "title": "go-zero的API语言",
    "section": "数据类型",
    "text": "数据类型\napi 中的数据类型基本沿用了 Golang 的数据类型，用于对 rest 服务的请求/响应体结构的描述，不支持 package 如 time.Time。\n// 空结构体\ntype Foo {}\n\n// 单个结构体\ntype Bar {\n    Foo int               `json:\"foo\"`\n    Bar bool              `json:\"bar\"`\n    Baz []string          `json:\"baz\"`\n    Qux map[string]string `json:\"qux\"`\n}\n\ntype Baz {\n    Bar    `json:\"baz\"`\n    Array [3]int `json:\"array\"`\n    // 结构体内嵌 goctl 1.6.8 版本支持\n    Qux {\n        Foo string `json:\"foo\"`\n        Bar bool   `json:\"bar\"`\n    } `json:\"baz\"`\n}\n\n// 空结构体组\ntype ()\n\n// 结构体组\ntype (\n    Int int\n    Integer = int\n    Bar {\n        Foo int               `json:\"foo\"`\n        Bar bool              `json:\"bar\"`\n        Baz []string          `json:\"baz\"`\n        Qux map[string]string `json:\"qux\"`\n    }\n)"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/api语言.html#service语句-service",
    "href": "content/learning-notes/microservices/entries/api语言.html#service语句-service",
    "title": "go-zero的API语言",
    "section": "service语句-@service",
    "text": "service语句-@service\nservice 语句是对 HTTP 服务的直观描述，包含请求 handler，请求方法，请求路由，请求体，响应体，jwt 开关，中间件声明等定义。\n// 空内容\n@server()\n\n// 有内容\n@server (\n    // jwt 声明\n    // 如果 key 固定为 “jwt:”，则代表开启 jwt 鉴权声明\n    // value 则为配置文件的结构体名称\n    jwt: Auth\n\n    // 路由前缀\n    // 如果 key 固定为 “prefix:”\n    // 则代表路由前缀声明，value 则为具体的路由前缀值，字符串中没让必须以 / 开头\n    prefix: /v1\n\n    // 路由分组\n    // 如果 key 固定为 “group:”，则代表路由分组声明\n    // value 则为具体分组名称，在 goctl生成代码后会根据此值进行文件夹分组\n    group: Foo\n\n    // 中间件\n    // 如果 key 固定为 middleware:”，则代表中间件声明\n    // value 则为具体中间件函数名称，在 goctl生成代码后会根据此值进生成对应的中间件函数\n    middleware: AuthInterceptor\n\n    // 超时控制\n    // 如果 key 固定为  timeout:”，则代表超时配置\n    // value 则为具体中duration，在 goctl生成代码后会根据此值进生成对应的超时配置\n    timeout: 3s\n\n    // 其他 key-value，除上述几个内置 key 外，其他 key-value\n    // 也可以在作为 annotation 信息传递给 goctl 及其插件，但就\n    // 目前来看，goctl 并未使用。\n    foo: bar\n)"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/api语言.html#服务条目",
    "href": "content/learning-notes/microservices/entries/api语言.html#服务条目",
    "title": "go-zero的API语言",
    "section": "服务条目",
    "text": "服务条目\n服务条目（ServiceItemStmt）是对单个 HTTP 请求的描述，包括 @doc 语句，@handler 语句，路由语句信息。\n\n@doc 语句\n@doc 语句是对单个路由的 meta 信息描述，一般为 key-value 值，可以传递给 goctl 及其插件来进行扩展生成。\n// 单行 @doc\n@doc \"foo\"\n\n// 空 @doc 组\n@doc ()\n\n// 有内容的 @doc 组\n@doc (\n    foo: \"bar\"\n    bar: \"baz\"\n)\n\n\n@handler 语句\n@handler 语句是对单个路由的 handler 信息控制，主要用于生成 golang http.HandleFunc 的实现转换方法。\n@handler foo\n\n\n路由语句\n路由语句是对单此 HTTP 请求的具体描述，包括请求方法，请求路径，请求体，响应体信息。\n// 没有请求体和响应体的写法\nget /ping\n\n// 只有请求体的写法\nget /foo (foo)\n\n// 只有响应体的写法\npost /foo returns (foo)\n\n// 有请求体和响应体的写法\npost /foo (foo) returns (bar)\n\n\n一个完整service\n// 带 @server 的写法\n@server (\n    prefix: /v1\n    group: Login\n)\nservice user {\n    @doc \"登录\"\n    @handler login\n    post /user/login (LoginReq) returns (LoginResp)\n\n    @handler getUserInfo\n    get /user/info/:id (GetUserInfoReq) returns (GetUserInfoResp)\n}\n@server (\n    prefix: /v1\n    middleware: AuthInterceptor\n)\nservice user {\n    @doc \"登录\"\n    @handler login\n    post /user/login (LoginReq) returns (LoginResp)\n\n    @handler getUserInfo\n    get /user/info/:id (GetUserInfoReq) returns (GetUserInfoResp)\n}\n\n\n// 不带 @server 的写法\nservice user {\n    @doc \"登录\"\n    @handler login\n    post /user/login (LoginReq) returns (LoginResp)\n\n    @handler getUserInfo\n    get /user/info/:id (GetUserInfoReq) returns (GetUserInfoResp)\n}"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/api语言.html#完整示例",
    "href": "content/learning-notes/microservices/entries/api语言.html#完整示例",
    "title": "go-zero的API语言",
    "section": "完整示例",
    "text": "完整示例\nsyntax = \"v1\"\n\ninfo (\n    title:   \"api 文件完整示例写法\"\n    desc:    \"演示如何编写 api 文件\"\n    author:  \"keson.an\"\n    date:    \"2022 年 12 月 26 日\"\n    version: \"v1\"\n)\n\ntype UpdateReq {\n    Arg1 string `json:\"arg1\"`\n}\n\ntype ListItem {\n    Value1 string `json:\"value1\"`\n}\n\ntype LoginReq {\n    Username string `json:\"username\"`\n    Password string `json:\"password\"`\n}\n\ntype LoginResp {\n    Name string `json:\"name\"`\n}\n\ntype FormExampleReq {\n    Name string `form:\"name\"`\n}\n\ntype PathExampleReq {\n    // path 标签修饰的 id 必须与请求路由中的片段对应，如\n    // id 在 service 语法块的请求路径上一定会有 :id 对应，见下文。\n    ID string `path:\"id\"`\n}\n\ntype PathExampleResp {\n    Name string `json:\"name\"`\n}\n\n@server (\n    jwt:        Auth // 对当前 Foo 语法块下的所有路由，开启 jwt 认证，不需要则请删除此行\n    prefix:     /v1 // 对当前 Foo 语法块下的所有路由，新增 /v1 路由前缀，不需要则请删除此行\n    group:      g1 // 对当前 Foo 语法块下的所有路由，路由归并到 g1 目录下，不需要则请删除此行\n    timeout:    3s // 对当前 Foo 语法块下的所有路由进行超时配置，不需要则请删除此行\n    middleware: AuthInterceptor // 对当前 Foo 语法块下的所有路由添加中间件，不需要则请删除此行\n    maxBytes:   1048576 // 对当前 Foo 语法块下的所有路由添加请求体大小控制，单位为 byte,goctl 版本 &gt;= 1.5.0 才支持\n)\nservice Foo {\n    // 定义没有请求体和响应体的接口，如 ping\n    @handler ping\n    get /ping\n\n    // 定义只有请求体的接口，如更新信息\n    @handler update\n    post /update (UpdateReq)\n\n    // 定义只有响应体的结构，如获取全部信息列表\n    @handler list\n    get /list returns ([]ListItem)\n\n    // 定义有结构体和响应体的接口，如登录\n    @handler login\n    post /login (LoginReq) returns (LoginResp)\n\n    // 定义表单请求\n    @handler formExample\n    post /form/example (FormExampleReq)\n\n    // 定义 path 参数\n    @handler pathExample\n    get /path/example/:id (PathExampleReq) returns (PathExampleResp)\n}"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/api语言.html#参考资料",
    "href": "content/learning-notes/microservices/entries/api语言.html#参考资料",
    "title": "go-zero的API语言",
    "section": "参考资料",
    "text": "参考资料\nAPI 规范\nAPI 定义完整示例"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-zero.html#简介",
    "href": "content/learning-notes/microservices/entries/go-zero.html#简介",
    "title": "Go-Zero 微服务框架",
    "section": "简介",
    "text": "简介\ngo-zero是一个集成了各种工程实践的 web 和 rpc 框架。通过弹性设计保障了大并发服务端的稳定性，经受了充分的实战检验。\ngo-zero 包含极简的 API 定义和生成工具 goctl，可以根据定义的 api 文件一键生成 Go, iOS, Android, Kotlin, Dart, TypeScript, JavaScript 代码，并可直接运行。\ngo-zero框架能轻松获得支撑千万日活服务的稳定性，内建级联超时控制、限流、自适应熔断、自适应降载等微服务治理能力，无需配置和额外代码，微服务治理中间件可无缝集成到其它现有框架使用，极简的 API 描述，一键生成各端代码，自动校验客户端请求参数合法性，大量微服务治理和并发工具包。\ngo-zero框架具有强大的工具支持，尽可能少的代码编写，极简的接口，完全兼容 net/http，支持中间件，方便扩展，高性能，面向故障编程，弹性设计，内建服务发现、负载均衡，内建限流、熔断、降载，且自动触发，自动恢复，API 参数自动校验，超时级联控制，自动缓存控制，链路跟踪、统计报警等，高并发支撑，稳定保障了疫情期间每天的流量洪峰。\n下面是官方给的架构图"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-zero.html#安装和快速使用",
    "href": "content/learning-notes/microservices/entries/go-zero.html#安装和快速使用",
    "title": "Go-Zero 微服务框架",
    "section": "安装和快速使用",
    "text": "安装和快速使用\n\n安装\n这里主要是go-zero、goctl和go-zero的安装指令，可以参照官方的文档：快速开始\n注意先安装go，关于go的安装和配置可以见博客：g的安装和使用\n# go-zero安装\ngo get -u github.com/zeromicro/go-zero@latest\n# goctl安装\ngo install github.com/zeromicro/go-zero/tools/goctl@latest\n# protoc安装\ngoctl env check --install --verbose --force\n\n\n\n快速使用\n\nApi demo\n在这里我创建了一个文件夹GoZeroDemo存放go-zero微服务框架学习期间的相关代码，之后初始化项目，并使用gpctl自动生成简单API相关文件\n# 创建并进入项目\nmkdir GoZeroDemo && cd GoZeroDemo\n# 初始化项目并命名\ngo mod init gozerodemo\n# 使用goctl创建API服务\ngoctl api new greet\n# 安装缺失的依赖\ngo mod tidy\n下面是生成的代码框架，包括配置文件、main文件、配置定义文件、网络路由相关文件、请求逻辑文件、业务逻辑相关文件以及业务相关结构体文件等等。\n\n之后我们根据官方说明，在greetlogic.go中实现Greet，做简单的 Say Hello，测试效果如下，一个简单的单体服务就构建完成了。\n\n通过简单的使用go-zero我们可以发现，框架的作用就是帮你生成配套代码，你只需要完成相应的业务逻辑。\n\n\ngRPC demo\n继续在GoZeroDemo目录下创建gRPC服务aorange\n# 使用goctl创建RPC服务\ngoctl rpc new aorange\n# 安装缺失的依赖\ngo mod tidy\n\n之后按照文档进行简单修改测试：gRPC-demo\n\n\n\nMySQL\n创建sql文件，之后通过goctl生成对应的golang文件和操作方法，具体参考：mysql代码生成\ngoctl model mysql ddl --src user.sql --dir .\n\n\n\nMongo\nmongo 不像 mysql 一样有建表语句，索引等集中有规律的约束信息，因此 mongo 代码的生成无需类似 sql 或者数据库链接一样的信息。，具体参考：mongo代码生成\ngoctl model mongo --type user --dir .\n\n\n\nformat\n还可以通过goctl进行格式化，具体见：api文件格式化\ngoctl api format --dir demo.api"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-zero.html#goctl",
    "href": "content/learning-notes/microservices/entries/go-zero.html#goctl",
    "title": "Go-Zero 微服务框架",
    "section": "Goctl",
    "text": "Goctl\n下面是goctl相关的指令和说明，我们常用的就是api和rpc\n\n\nApi\n\n参考官方给的api示例，我们使用goctl通过api文件创建服务\n首先创建项目文件夹添加user.api\n之后在终端输入指令\ngoctl api go -api user.api -dir . -style goZero\nsyntax = \"v1\"\n\ntype (\n        // 定义登录接口的 json 请求体\n        LoginReq {\n                Username string `json:\"username\"`\n                Password string `json:\"password\"`\n        }\n        // 定义登录接口的 json 响应体\n        LoginResp {\n                Id       int64  `json:\"id\"`\n                Name     string `json:\"name\"`\n                Token    string `json:\"token\"`\n                ExpireAt string `json:\"expireAt\"`\n        }\n)\n\ntype (\n        // 定义获取用户信息的 json 请求体\n        GetUserInfoReq {\n                Id int64 `json:\"id\"`\n        }\n        // 定义获取用户信息的 json 响应体\n        GetUserInfoResp {\n                Id   int64  `json:\"id\"`\n                Name string `json:\"name\"`\n                Desc string `json:\"desc\"`\n        }\n        // 定义更新用户信息的 json 请求体\n        UpdateUserInfoReq {\n                Id   int64  `json:\"id\"`\n                Name string `json:\"name\"`\n                Desc string `json:\"desc\"`\n        }\n)\n\n// 定义 HTTP 服务\n// @server 语法块主要用于控制对 HTTP 服务生成时 meta 信息，目前支持功能有：\n// 1. 路由分组\n// 2. 中间件声明\n// 3. 路由前缀\n// 4. 超时配置\n// 5. jwt 鉴权开关\n// 所有声明仅对当前 service 中的路由有效\n@server (\n        // 代表当前 service 代码块下的路由生成代码时都会被放到 login 目录下\n        group: login\n        // 定义路由前缀为 \"/v1\"\n        prefix: /v1\n)\n// 微服务名称为 user，生成的代码目录和配置文件将和 user 值相关\nservice user {\n        // 定义 http.HandleFunc 转换的 go 文件名称及方法，每个接口都会跟一个 handler\n        @handler login\n        // 定义接口\n        // 请求方法为 post\n        // 路由为 /user/login\n        // 请求体为 LoginReq\n        // 响应体为 LoginResp，响应体必须有 returns 关键字修饰\n        post /user/login (LoginReq) returns (LoginResp)\n}\n\n// @server 语法块主要用于控制对 HTTP 服务生成时 meta 信息，目前支持功能有：\n// 1. 路由分组\n// 2. 中间件声明\n// 3. 路由前缀\n// 4. 超时配置\n// 5. jwt 鉴权开关\n// 所有声明仅对当前 service 中的路由有效\n@server (\n        // 代表当前 service 代码块下的所有路由均需要 jwt 鉴权\n        // goctl 生成代码时会将当前 service 代码块下的接口\n        // 信息添加上 jwt 相关代码，Auth 值为 jwt 密钥，过期\n        // 等信息配置的 golang 结构体名称\n        jwt: Auth\n        // 代表当前 service 代码块下的路由生成代码时都会被放到 user 目录下\n        group: user\n        // 定义路由前缀为 \"/v1\"\n        prefix: /v1\n)\n// 注意，定义多个 service 代码块时，服务名称必须一致，因此这里的服务名称必须\n// 和上文的 service 名称一样，为 user 服务。\nservice user {\n        // 定义 http.HandleFunc 转换的 go 文件名称及方法，每个接口都会跟一个 handler\n        @handler getUserInfo\n        // 定义接口\n        // 请求方法为 post\n        // 路由为 /user/info\n        // 请求体为 GetUserInfoReq\n        // 响应体为 GetUserInfoResp，响应体必须有 returns 关键字修饰\n        post /user/info (GetUserInfoReq) returns (GetUserInfoResp)\n\n        // 定义 http.HandleFunc 转换的 go 文件名称及方法，每个接口都会跟一个 handler\n        @handler updateUserInfo\n        // 定义接口\n        // 请求方法为 post\n        // 路由为 /user/info/update\n        // 请求体为 UpdateUserInfoReq\n        // 由于不需要响应体，因此可以忽略不写\n        post /user/info/update (UpdateUserInfoReq)\n}\n\n\n\nRPC\n\nrpc采用同样的方式\n相关指令和代码如下：\ngoctl rpc protoc user.proto --go_out=. --go-grpc_out=. --zrpc_out=.\n// 声明 proto 语法版本，固定值\nsyntax = \"proto3\";\n\n// proto 包名\npackage greet;\n\n// 生成 golang 代码后的包名\noption go_package = \"example/proto/greet\";\n\n// 定义枚举\n\nenum Status{\n  UNSPECIFIED = 0;\n  SUCCESS = 1;\n  FAILED = 2;\n}\n\n// 定义结构体\n\nmessage Base{\n  int32 code = 1;\n  string msg = 2;\n}\n\nmessage SendMessageReq{\n  string message = 1;\n}\n\nmessage SendMessage{\n  // 使用枚举\n  Status status = 1;\n  // 数组\n  repeated string array = 2;\n  // map\n  map&lt;string,int32&gt; map = 3;\n  // 布尔类型\n  bool boolean = 4;\n  // 序列号保留\n  reserved 5;\n}\n\nmessage SendMessageResp{\n  Base base = 1;\n  SendMessage data = 2;\n}\n\n// 定义 Greet 服务\nservice Greet {\n  // 定义客户端流式 rpc\n  rpc SendMessage(stream SendMessageReq) returns (SendMessageResp);\n}\n\n\n\nModel\n\n以SQL为例，创建sql文件，通过下面指令生成相关代码\ngoctl model mysql ddl -src\"./user.sql\" -dir=\"./sql/model\" -c"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/go-zero.html#参考资料",
    "href": "content/learning-notes/microservices/entries/go-zero.html#参考资料",
    "title": "Go-Zero 微服务框架",
    "section": "参考资料",
    "text": "参考资料\ngo-zero\ngo-zero官方文档\ngo的版本管理工具-g的安装和使用"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/微服务框架(golang).html",
    "href": "content/learning-notes/microservices/entries/微服务框架(golang).html",
    "title": "微服务框架(golang)",
    "section": "",
    "text": "框架，英文名称framework，可以看作一种脚手架或者是一种标准化模版\n框架中该有的组件都已经设定好，方便干活，减少重复工作，同时项目的风格和目录一致，看起来也更加方便\n在公司中使用统一的框架，接手起来更加方便，维护起来也更加方便，如果使用同一个框架，发现了漏洞，更新一个框架即可。同时很多业务中存在重复代码，像是日志、监控系统，使用统一框架，负责开发的程序员不需要考虑其他，只管自己业务代码的开发，这样自己写的代码量减少，不容易出现问题。\n在开发的主流语言中，Java应用是最广泛的，它有一个统一的框架Spring，全世界都在用，很多问题前辈可能都遇到过，相应的技术博客也比较完善，这是它独特的优势。"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/微服务框架(golang).html#框架是什么",
    "href": "content/learning-notes/microservices/entries/微服务框架(golang).html#框架是什么",
    "title": "微服务框架(golang)",
    "section": "",
    "text": "框架，英文名称framework，可以看作一种脚手架或者是一种标准化模版\n框架中该有的组件都已经设定好，方便干活，减少重复工作，同时项目的风格和目录一致，看起来也更加方便\n在公司中使用统一的框架，接手起来更加方便，维护起来也更加方便，如果使用同一个框架，发现了漏洞，更新一个框架即可。同时很多业务中存在重复代码，像是日志、监控系统，使用统一框架，负责开发的程序员不需要考虑其他，只管自己业务代码的开发，这样自己写的代码量减少，不容易出现问题。\n在开发的主流语言中，Java应用是最广泛的，它有一个统一的框架Spring，全世界都在用，很多问题前辈可能都遇到过，相应的技术博客也比较完善，这是它独特的优势。"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/微服务框架(golang).html#golang开发常用的框架",
    "href": "content/learning-notes/microservices/entries/微服务框架(golang).html#golang开发常用的框架",
    "title": "微服务框架(golang)",
    "section": "golang开发常用的框架",
    "text": "golang开发常用的框架\ngolang是一门比较新的语言，2009年正式发布，作为一门新兴的语言，没有像Java一样形成一个大一统的框架，很多大厂都有自己的框架，还有一些开源团队维护自己的框架。\n这样在大厂中会有一些岗位是做基础架构的，专门为公司开发新的适用于公司业务的框架，开发框架也并不简单，需要根据自己公司的业务需求进行开发，还要考虑跟公司其他业务的连通性，公司内部私有协议的适配性，还有框架的使用友好性、稳定性、安全性等等。\n我们在学习的时候更多的是要学习框架实现的思想，不要只单纯学怎么使用，要学会自己造轮子-&gt;造汽车。"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/微服务框架(golang).html#微服务框架基本组件",
    "href": "content/learning-notes/microservices/entries/微服务框架(golang).html#微服务框架基本组件",
    "title": "微服务框架(golang)",
    "section": "微服务框架基本组件",
    "text": "微服务框架基本组件\n\n日志（一个框架能支持不同的日志配置）\n配置中心（在配置中心进行微服务配置的设定，不用一个个单独设置）\n数据库（支持数据库的交互）\n消息队列（各种消息队列，Kafka、RabbitMQ等）\nmetrics（指标监控）\ntracing（链路追踪，单个请求完整的生命周期，找出性能瓶颈之类的）\n服务注册发现\n依赖注入\nRPC框架（远程过程调用，微服务之间数据的交互处理）\n熔断和限流（维持微服务的运行，防止崩溃）\n……"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/微服务框架(golang).html#开源社区常用的框架",
    "href": "content/learning-notes/microservices/entries/微服务框架(golang).html#开源社区常用的框架",
    "title": "微服务框架(golang)",
    "section": "开源社区常用的框架",
    "text": "开源社区常用的框架\n\nGo-kit\n\ngo微服务套件库，简单的组件库，能用来实现微服务项目\n\nGo-micro\n\n比较早的go微服务框架，可能不兼容新的更新\n\nGo-kratos\n\nB站开源的框架，可以自己选择组件，也可以使用自己的\n\nKitex\n\n字节开源，自定义netpoll，对使用者要求比较高，性能高\n\nGo-zero\n\n好未来开源的，一站式微服务框架（之前吃饭路过好未来，下班好像挺早的）"
  },
  {
    "objectID": "content/learning-notes/microservices/entries/微服务框架(golang).html#参考资料",
    "href": "content/learning-notes/microservices/entries/微服务框架(golang).html#参考资料",
    "title": "微服务框架(golang)",
    "section": "参考资料",
    "text": "参考资料\n\nGo-kit\nGo-micro\nGo-kratos\nKitex\nGo-zero"
  },
  {
    "objectID": "content/projects/entries/Gesture-Fireworks.html",
    "href": "content/projects/entries/Gesture-Fireworks.html",
    "title": "Gesture-Fireworks",
    "section": "",
    "text": "「用手点燃烟花」——Gesture Fireworks ✨"
  },
  {
    "objectID": "content/projects/entries/Gesture-Fireworks.html#项目地址",
    "href": "content/projects/entries/Gesture-Fireworks.html#项目地址",
    "title": "Gesture-Fireworks",
    "section": "项目地址",
    "text": "项目地址\n\n仓库地址：Gesture Fireworks（基于 MediaPipe 的手势烟花互动小工具）(GitHub)"
  },
  {
    "objectID": "content/projects/entries/Gesture-Fireworks.html#一这个小项目想解决什么",
    "href": "content/projects/entries/Gesture-Fireworks.html#一这个小项目想解决什么",
    "title": "Gesture-Fireworks",
    "section": "一、这个小项目想解决什么？",
    "text": "一、这个小项目想解决什么？\n每年跨年、春节、烟花节，我们总会刷到各种烟花视频，但要么太吵，要么不环保，要么……钱包受不了 😅\n于是我做了一个轻量又好玩的实验项目：Gesture Fireworks（手势烟花）。 它的核心目标是——让你只用一台带摄像头的电脑 + 浏览器，就能用手势在空中「放烟花」。\n你对着摄像头比一个 ✊、✌️ 或比心 ❤️，画面中就会在你的手边绽放对应的烟花效果。 不需要安装客户端，不需要复杂硬件，打开网页、授权摄像头，就能玩。"
  },
  {
    "objectID": "content/projects/entries/Gesture-Fireworks.html#二项目功能一览它到底能干嘛",
    "href": "content/projects/entries/Gesture-Fireworks.html#二项目功能一览它到底能干嘛",
    "title": "Gesture-Fireworks",
    "section": "二、项目功能一览：它到底能干嘛？",
    "text": "二、项目功能一览：它到底能干嘛？\n在目前的版本中，Gesture Fireworks 实现了这几类能力：\n\nAI 手势识别：基于 MediaPipe 的手势识别方案，支持多种不同手势\n绚丽烟花特效：精心设计了多种烟花，包括：\n\n爆炸烟花（FireworkBurst）\n圆环烟花（FireworkCircle）\n心形烟花（FireworkHeart）\n星形烟花（FireworkStar）\n螺旋烟花（FireworkSpiral）\n伞形烟花（FireworkUmbrella）\n等等\n\n多手同时触发：双手可以同时做不同手势，各自单独触发烟花，带有独立冷却机制\n高性能渲染：使用优化过的 Canvas 2D 粒子系统，可以同时渲染数千粒子而保持顺畅\n智能识别算法：多帧平滑、稳定帧判定、动态阈值、冷却机制，尽量减少误判抖动\n响应式页面：同时兼容桌面端 & 移动端"
  },
  {
    "objectID": "content/projects/entries/Gesture-Fireworks.html#三手势和烟花的绑定关系",
    "href": "content/projects/entries/Gesture-Fireworks.html#三手势和烟花的绑定关系",
    "title": "Gesture-Fireworks",
    "section": "三、手势和烟花的「绑定关系」",
    "text": "三、手势和烟花的「绑定关系」\n为了让体验更「直觉」，我为常见手势设计了不同的烟花风格：\n\n\n\n\n\n\n\n\n\n手势\n识别名\n对应烟花\n视觉风格\n\n\n\n\n✊ 拳头\nFIST\nFireworkBurst\n金黄色多层圆形爆炸，冲击感强\n\n\n👌 OK 手势\nOK\nFireworkCircle\n红橙系双环高密度爆裂\n\n\n❤️ 比心\nHEART\nFireworkHeart\n粉色系心形烟花，氛围感拉满\n\n\n👍 竖拇指\nTHUMBS_UP\nFireworkStar\n金白色五角星爆炸，闪烁明显\n\n\n✌️ 剪刀手\nPEACE\nFireworkSpiral\n紫色螺旋扩散，有旋转轨迹\n\n\n👉 指向\nPOINTING\nFireworkUmbrella\n蓝色伞形烟花，拖尾柔和\n\n\n✋ 张开手掌\nOPEN_PALM\nFireworkA\n随机色环形爆裂 + 拖尾，基础通用款\n\n\n\n技术上，在入口逻辑里会根据识别到的手势类型，映射到不同的触发器函数，并传入不同的参数（粒子数量、配色、持续时间等），让每种手势都有明显区别的手感和视觉反馈。"
  },
  {
    "objectID": "content/projects/entries/Gesture-Fireworks.html#四手势识别怎么尽量识别得准一点",
    "href": "content/projects/entries/Gesture-Fireworks.html#四手势识别怎么尽量识别得准一点",
    "title": "Gesture-Fireworks",
    "section": "四、手势识别：怎么尽量识别得「准一点」？",
    "text": "四、手势识别：怎么尽量识别得「准一点」？\n单纯做一个「能识别」的 Demo 很简单，但要做到「好玩、不烦人」，就必须控制误识别率和抖动。为此我做了几层处理逻辑：\n\n1. 多帧平滑 + 稳定帧判定\n\n使用固定长度的历史帧（例如 smoothingFrames = 10）做平滑\n只有连续若干帧（例如 stableFrames = 6）都稳定识别为同一手势时，才视为「真正识别到」\n\n这样可以过滤掉短暂的抖动或过渡帧，让触发更可控。\n\n\n2. 动态置信度阈值\n不同手势本身的易混淆程度不一样，所以采用了区分度更高的阈值设计：\n\n对于容易混的手势（拳头、OK、点赞、剪刀手、指向等），阈值设为 0.85\n对于张开手掌（OPEN_PALM），阈值略低一点 0.8\n\n同时，还会要求第一名和第二名手势的置信度差值 ≥ 0.12，避免「半斤八两」的两种手势乱跳。\n\n\n3. 冷却机制 + 上升沿触发\n\n每个识别器有一个默认冷却时间 cooldownMs = 350ms\n只有当「稳定手势从 A 变为 B」且不在冷却期内，才会触发一次烟花\n\n这意味着你可以保持一个手势不动，烟花不会无限制连发，更像是「一次明确的动作 → 一次清晰的反馈」。"
  },
  {
    "objectID": "content/projects/entries/Gesture-Fireworks.html#五渲染层canvas-粒子系统的设计思路",
    "href": "content/projects/entries/Gesture-Fireworks.html#五渲染层canvas-粒子系统的设计思路",
    "title": "Gesture-Fireworks",
    "section": "五、渲染层：Canvas 粒子系统的设计思路",
    "text": "五、渲染层：Canvas 粒子系统的设计思路\n视觉部分基于 Canvas 2D 实现了一个轻量的粒子系统：\n\n每个烟花本质上是大量粒子（位置、速度、加速度、颜色、透明度等属性）的集合\n每一帧进行：\n\n粒子位置更新（重力、阻尼、初速度方向等）\n透明度 & 尺寸衰减\n组合出光晕、拖尾、闪烁等效果\n\n\n为了保证性能，我做了几件事：\n\n批量更新 & 绘制，减少多余的状态切换\n针对不同烟花类型，限制最大粒子数量，避免堆爆内存\n在多发烟花场景下优先清理已经「看不见」的粒子\n\n在普通笔记本 + 现代浏览器环境下，同时存在数千个粒子仍可以保持比较流畅的体验。"
  },
  {
    "objectID": "content/projects/entries/Gesture-Fireworks.html#六项目结构-技术栈简述",
    "href": "content/projects/entries/Gesture-Fireworks.html#六项目结构-技术栈简述",
    "title": "Gesture-Fireworks",
    "section": "六、项目结构 & 技术栈简述",
    "text": "六、项目结构 & 技术栈简述\n项目整体是一个很标准的前端小应用形态：\n\n技术栈\n\nJavaScript 为主（约 97.7%）\n少量 HTML 结构\nMediaPipe 手势检测（通过 vendor 依赖引入）\n\n主要目录\n\nsrc/hand：手势识别与高级逻辑（置信度、稳定性、冷却等）\nsrc/main.js：应用主入口，负责：\n\n摄像头采集与视频流\n调用识别模块\n根据手势触发不同烟花\n\nsrc/fireworks/*：不同烟花特效的实现\n\n\n目的就是：保持结构清晰，方便以后扩展新的手势 & 新的烟花类型。"
  },
  {
    "objectID": "content/projects/entries/Gesture-Fireworks.html#七如何本地跑起来",
    "href": "content/projects/entries/Gesture-Fireworks.html#七如何本地跑起来",
    "title": "Gesture-Fireworks",
    "section": "七、如何本地跑起来？",
    "text": "七、如何本地跑起来？\n只要你对前端略有了解，就可以很快跑起来。\n\n1. 环境准备\n\n现代浏览器（Chrome 88+、Firefox 85+、Safari 14+、Edge 88+）\n一台带摄像头的设备\n本地 HTTP 服务器（用于获取摄像头权限）\n网络连接（首次加载 MediaPipe 模型）\n\n\n\n2. 启动步骤（示例）\n# 1. 克隆项目\ngit clone https://github.com/your-username/Gesture-fireworks.git\ncd Gesture-fireworks\n\n# 2. 启动本地服务器（Python 3 示例）\npython -m http.server 8000\n# 或者使用 Node.js\nnpx http-server -p 8000 -a localhost\n然后在浏览器中访问：\nhttp://localhost:8000"
  },
  {
    "objectID": "content/projects/entries/Gesture-Fireworks.html#浏览器会弹出摄像头授权请求点击允许即可开始体验",
    "href": "content/projects/entries/Gesture-Fireworks.html#浏览器会弹出摄像头授权请求点击允许即可开始体验",
    "title": "Gesture-Fireworks",
    "section": "浏览器会弹出摄像头授权请求，点击「允许」即可开始体验。",
    "text": "浏览器会弹出摄像头授权请求，点击「允许」即可开始体验。"
  },
  {
    "objectID": "content/projects/entries/Gesture-Fireworks.html#八实际体验怎么玩得更爽",
    "href": "content/projects/entries/Gesture-Fireworks.html#八实际体验怎么玩得更爽",
    "title": "Gesture-Fireworks",
    "section": "八、实际体验：怎么玩得更爽？",
    "text": "八、实际体验：怎么玩得更爽？\n结合调试过程，总结了一些实用的小技巧：\n\n光线充足：正面光最好，避免背光和强阴影\n距离合适：人与摄像头保持 1–2 米，手部占画面约 1/4 效果最佳\n手势清晰稳定：\n\n比完手势后保持 1–2 秒\n手指要伸直 / 收紧到位，避免半吊子动作\n\n居中一点：手尽量在画面中央区域，边缘区域容易畸变、识别不准\n多手玩法：双手分别做不同手势，可以点亮「组合烟花」，非常适合多人一起玩\n\n\n如果你对这个项目有兴趣，欢迎来仓库看看源码、提 Issue 或一起玩"
  }
]