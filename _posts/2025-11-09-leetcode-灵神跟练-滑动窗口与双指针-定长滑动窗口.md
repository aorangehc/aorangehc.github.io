---
title: leetcode-灵神跟练-滑动窗口与双指针-定长滑动窗口
date: 2025-11-09 14:59:31  +0800
categories: [算法, leetcode, 滑动窗口与双指针]
tags: [算法, leetcode, 滑动窗口与双指针]
math: true
pin: true
mermaid: true
---

# 定长滑动窗口

## 1、基础

### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面

给你字符串 s 和整数 k 。
请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。
英文中的 元音字母 为（a, e, i, o, u）。

示例 1：
输入：s = "abciiidef", k = 3
输出：3
解释：子字符串 "iii" 包含 3 个元音字母。

示例 2：
输入：s = "aeiou", k = 2
输出：2
解释：任意长度为 2 的子字符串都包含 2 个元音字母。

示例 3：
输入：s = "leetcode", k = 3
输出：2
解释："lee"、"eet" 和 "ode" 都包含 2 个元音字母。

示例 4：
输入：s = "rhythms", k = 4
输出：0
解释：字符串 s 中不含任何元音字母。

示例 5：
输入：s = "tryhard", k = 4
输出：1
 

提示：
1 <= s.length <= 10^5
s 由小写英文字母组成
1 <= k <= s.length

#### 思路说明

本题是一个比较简单的滑动窗口，窗口的大小固定不变是K，要做的是判断窗口内元音字母的个数

首先我们构建一个变量用来统计当前窗口内元音字母的数量，设置为**cnt**

窗口只要不断向右滑动的，还需要一个变量存储所有经历过的窗口中元音字母数的最大值，也就是我们最后需要的结果，设置为**ans**

然后我们就是对字符串进行遍历

针对定长滑动窗口的类型，我们可以简单总结一个规律
- 先进行条件判断，修改对应变量值
- 判断窗口是否需要移动，如果移动修改对应值
- 判断窗口是否已经达到了固定长度，如果达到了，进行结果更新

一个简单的总结，仅供参考

针对我们现在的题目
- 创建一个变量记录当前窗口内元音字母的个数，设置为**cnt**
- 创建一个变量记录所有经历过的窗口内元音字母数最大值，设置为**ans**
- 然后进行遍历
    - 先判断是不是元音字母，如果是窗口内元音字母个数cnt+1
    - 然后判断窗口是否需要滑动，如果需要，判断最左边元素是不是元音字母，如果是cnt-1，如果不是，不需要进行更新
    - 最后，判断当前窗口长度是不是达到要求，如果是，进行最大值的更新
- 返回最终结果ans

#### 题解

``` golang
package main

import "fmt"

func judge(ch byte) bool {
	if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {
		return true
	}

	return false
}

func maxVowels(s string, k int) int {
	ans := 0
	cnt := 0

	for i := 0; i < len(s); i++ {
		if judge(s[i]) {
			cnt++
		}
		if i >= k {
			if judge(s[i-k]) {
				cnt -= 1
			}
		}
		if i >= k-1 {
			ans = max(ans, cnt)
		}
	}

	return ans
}

func main() {
	testCases := []struct {
		s string
		k int
	}{
		{"abciiidef", 3},
		{"aeiou", 2},
		{"leetcode", 3},
		{"rhythms", 4},
		{"tryhard", 4},
	}

	for _, testCase := range testCases {
		fmt.Println(maxVowels(testCase.s, testCase.k))
	}
}


```

### [643. 子数组最大平均数 I](https://leetcode.cn/problems/maximum-average-subarray-i/description/)

#### 题面

给你一个由 n 个元素组成的整数数组 nums 和一个整数 k 。
请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。
任何误差小于 10-5 的答案都将被视为正确答案。

示例 1：

输入：nums = [1,12,-5,-6,50,3], k = 4

输出：12.75

解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75


示例 2：

输入：nums = [5], k = 1

输出：5.00000
 

提示：

n == nums.length

1 <= k <= n <= 105

-104 <= nums[i] <= 104

#### 思路说明

构建长度为k的滑动窗口，设置变量计算窗口内数字的和，当窗口滑动的时候更新变量

设置变量动态更新最大平均数，注意这个变量初始化的时候设置成 math.MinInt

#### 题解

``` golang

// 643.子数组最大平均数I
package main

import (
	"fmt"
	"math"
)

func findMaxAverage(nums []int, k int) float64 {
	ans, cnt := math.MinInt, 0

	for i, num := range nums {
		cnt += num

		if i >= k {
			cnt -= nums[i-k]
		}

		if i >= k-1 {
			ans = max(ans, cnt)
		}
	}

	return float64(ans) / float64(k)
}

func main() {
	testCases := []struct {
		nums []int
		k    int
	}{
		{[]int{1, 12, -5, -6, 50, 3}, 4},
		{[]int{5}, 1},
	}

	for _, testCase := range testCases {
		fmt.Println(findMaxAverage(testCase.nums, testCase.k))
	}
}

```


### [1343. 大小为 K 且平均值大于等于阈值的子数组数目](https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/description/)

#### 题面

给你一个整数数组 arr 和两个整数 k 和 threshold 。

请你返回长度为 k 且平均值大于等于 threshold 的子数组数目。

示例 1：

输入：arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4

输出：3

解释：子数组 [2,5,5],[5,5,5] 和 [5,5,8] 的平均值分别为 4，5 和 6 。其他长度为 3 的子数组的平均值都小于 4 （threshold 的值)。

示例 2：

输入：arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5

输出：6

解释：前 6 个长度为 3 的子数组平均值都大于 5 。注意平均值不是整数。
 

提示：

1 <= arr.length <= 105

1 <= arr[i] <= 104

1 <= k <= arr.length

0 <= threshold <= 104

#### 思路说明

基本思路就是构建大小为k的窗口，计算窗口内元素的和，然后计算平均值是否大于等于某个阈值

还是按照咱们的步骤来

#### 题解

``` golang

// 1343.大小为K且平均值大于等于阈值的子数组数目
package main

import "fmt"

func numOfSubarrays(arr []int, k, threshold int) int {
	ans, cnt := 0, 0

	for i, num := range arr {
		cnt += num
		if i >= k {
			cnt -= arr[i-k]
		}

		if i >= k-1 && cnt >= k*threshold {
			ans += 1
		}
	}

	return ans
}

func main() {
	testCases := []struct {
		arr       []int
		k         int
		threshold int
	}{
		{[]int{2, 2, 2, 2, 5, 5, 5, 8}, 3, 4},
		{[]int{11, 13, 17, 23, 29, 31, 7, 5, 2, 3}, 3, 5},
	}

	for _, testCase := range testCases {
		fmt.Println(numOfSubarrays(testCase.arr, testCase.k, testCase.threshold))
	}
}


```


### [2090. 半径为 k 的子数组平均值](https://leetcode.cn/problems/k-radius-subarray-averages/description/)

#### 题面

给你一个下标从 0 开始的数组 nums ，数组中有 n 个整数，另给你一个整数 k 。

半径为 k 的子数组平均值 是指：nums 中一个以下标 i 为 中心 且 半径 为 k 的子数组中所有元素的平均值，即下标在 i - k 和 i + k 范围（含 i - k 和 i + k）内所有元素的平均值。如果在下标 i 前或后不足 k 个元素，那么 半径为 k 的子数组平均值 是 -1 。

构建并返回一个长度为 n 的数组 avgs ，其中 avgs[i] 是以下标 i 为中心的子数组的 半径为 k 的子数组平均值 。

x 个元素的 平均值 是 x 个元素相加之和除以 x ，此时使用截断式 整数除法 ，即需要去掉结果的小数部分。

例如，四个元素 2、3、1 和 5 的平均值是 (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75，截断后得到 2 。
 

示例 1：

输入：nums = [7,4,3,9,1,8,5,2,6], k = 3

输出：[-1,-1,-1,5,4,4,-1,-1,-1]

解释：
- avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。
- 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。
  使用截断式 整数除法，avg[3] = 37 / 7 = 5 。
- 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。
- 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。
- avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。

示例 2：

输入：nums = [100000], k = 0

输出：[100000]

解释：
- 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。
  avg[0] = 100000 / 1 = 100000 。

示例 3：

输入：nums = [8], k = 100000

输出：[-1]

解释：
- avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。
 
提示：

n == nums.length

1 <= n <= 105

0 <= nums[i], k <= 105

#### 思路说明

本题提出了一个概念，半径为k的字数组

这个时候滑动窗口的实际大小是**k * 2 + 1**

之后能作为圆心的点才能够有平均值，其他的都是-1

所以，先设置答案存储的数组 ans 然后将全部的值初始化为-1

之后还是按照我们之前总结的思路来

#### 题解

``` golang
// 2090.半径为k的子数组平均值
package main

import "fmt"

func getAverages(nums []int, k int) []int {
	ans := make([]int, len(nums))

	for i := range ans {
		ans[i] = -1
	}

	cnt := 0

	for i, num := range nums {
		cnt += num

		if i >= 2*k {
			ans[i-k] = cnt / (k*2 + 1)
			cnt -= nums[i-2*k]
		}
	}

	return ans
}

func main() {
	testCases := []struct {
		nums []int
		k    int
	}{
		{[]int{7, 4, 3, 9, 1, 8, 5, 2, 6}, 3},
		{[]int{100000}, 0},
		{[]int{8}, 100000},
	}

	for _, testCase := range testCases {
		fmt.Println(getAverages(testCase.nums, testCase.k))
	}
}


```


### [2379. 得到 K 个黑块的最少涂色次数](https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/description/)

#### 题面

给你一个长度为 n 下标从 0 开始的字符串 blocks ，blocks[i] 要么是 'W' 要么是 'B' ，表示第 i 块的颜色。字符 'W' 和 'B' 分别表示白色和黑色。

给你一个整数 k ，表示想要 连续 黑色块的数目。

每一次操作中，你可以选择一个白色块将它 涂成 黑色块。

请你返回至少出现 一次 连续 k 个黑色块的 最少 操作次数。

 

示例 1：

输入：blocks = "WBBWWBBWBW", k = 7

输出：3

解释：
一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色。

得到 blocks = "BBBBBBBWBW" 。

可以证明无法用少于 3 次操作得到 7 个连续的黑块。

所以我们返回 3 。

示例 2：

输入：blocks = "WBWBBBW", k = 2

输出：0

解释：

不需要任何操作，因为已经有 2 个连续的黑块。

所以我们返回 0 。
 

提示：

n == blocks.length

1 <= n <= 100

blocks[i] 要么是 'W' ，要么是 'B' 。

1 <= k <= n

#### 思路说明

我们需要的是K个连续的黑色块，也就是把大小为k的窗口中的白色块全部涂黑

我们要到这个最小的涂色数，也是黑色块最多，白色块最少

我们找到黑色块最多的然后用k减去这个数量即可

#### 题解

``` golang
// 2379.得到K个黑块的最少涂色次数
package main

import "fmt"

func minimumRecolors(blocks string, k int) int {
	ans, cnt := 0, 0

	for i, block := range blocks {
		if block == 'B' {
			cnt += 1
		}

		if i >= k {
			if blocks[i-k] == 'B' {
				cnt -= 1
			}
		}

		if i >= k-1 {
			ans = max(ans, cnt)
		}
	}

	return k - ans
}

func main() {
	testCases := []struct {
		blocks string
		k      int
	}{
		{"WBBWWBBWBW", 7},
		{"WBWBBBW", 2},
	}

	for _, testCase := range testCases {
		fmt.Println(minimumRecolors(testCase.blocks, testCase.k))
	}
}


```


### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```


### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```

### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```


### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```


### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```


### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```


### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```


### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```


### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```


### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```


### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```


### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```


### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```


### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```


### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```


### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```


### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```

### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```


### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```


### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```

### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```


### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```


### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```

### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```


### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```


### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```

### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### 题面


#### 思路说明


#### 题解

``` golang


```
