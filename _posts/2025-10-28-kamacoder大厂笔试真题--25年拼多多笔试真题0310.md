---
title: kamacoder大厂笔试真题--25年拼多多笔试真题0310
date: 2025-10-28 20:27:30  +0800
categories: [算法, kamacoder]
tags: [算法, kamacode]
math: true
pin: true
mermaid: true
---

# kamacoder大厂笔试真题--25年拼多多笔试真题0310

## 312.传送门1

### 题干
``` text
题目描述

多多在玩一个传送门游戏。
游戏开始时多多在一维数轴的x=0处。他有n个传送门，每个传送门都有一个传送值ai，他能使用该传送门从x=t位置传送到x=t+ai，传送门是消耗品，只能使用一次。同时他还有一个"反转"技能，使用该技能可以立即从位置 x=t"反转"到x=-t。
多多可以以任意顺序使用这些传送门，可以在任何时候使用"反转"技能(最多用一次，也可以不用)，问用完所有传送门后，多多到初始位置x=0最远的距离为多少?


输入

第一行为一个正整数 n(1  ≤  n  ≤  10^5)
第二行为n个整数a1,a2, ..., an(-10^4  <  ai  ≤ 10^4)

输出

输出用完所有传送门后，少少到初始位置距离的最大值。

示例

4
1 -2 3 -4
输出：10

```

### 个人思路

首先使用传送门的顺序是自己决定的，所以可以先使用所有负数的传送门，然后使用反转技能，最后使用所有正数传送门

最终得到的效果是所有数的绝对值相加

### 实现代码

``` go
package main

import "fmt"

func main() {
	var n int
	fmt.Scanf("%d", &n)

	ans := 0
	for i := 0; i < n; i++ {
		var num int
		fmt.Scanf("%d", &num)

		if num < 0 {
			ans -= num
		} else {
			ans += num
		}
	}

	fmt.Println(ans)
}
```

**然而上面的代码超时**

优化一下输入输出

``` go
package main

import (
	"fmt"
	"bufio"
	"os"
)

func main() {
	const bufferSize = 1 << 20
	reader := bufio.NewReaderSize(os.Stdin, bufferSize)
	writer := bufio.NewWriterSize(os.Stdout, bufferSize)

	defer writer.Flush()

	var n int

	fmt.Fscan(reader, &n)

	ans := 0

	for i := 0; i < n; i++ {
		var num int

		fmt.Fscan(reader, &num)

		if num < 0 {
			ans -= num
		} else {
			ans += num
		}
	}

	fmt.Fprintln(writer, ans)
}

```

**为什么下面的代码更快，是什么原理？**
> fmt.Scanf每次都会解析个失传，并在反射里做参数派发，解析格式的成本高，直接使用fmt.Fscan(reader, &n)，少了格式串解析开销，反射成本更低

> 使用bufio.NewReaderSize(os.Stdin, 1<<20)，把输入一次读入1MiB的缓冲区，循环里读取数据不再频繁系统调用，相比于fmt.Scanf的逐个字符阻塞读取，系统调用的数量大大下降

> 输出也是这样减少系统调用，用bufio.NewWriterSize把fmt.Fprintln写入缓冲区，最后一次性Flush





## 313.传送门2

## 314.爱读书

## 315.座位安排